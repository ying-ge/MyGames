<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mario’s CNS Sprint</title>
    <style>
      :root {
        color-scheme: light;
        --bg: #f3f6ff;
        --panel: rgba(255, 255, 255, 0.92);
        --accent: #4165ff;
        --accent-dark: #1f2d70;
        --text: #1b1d33;
        --muted: #5a6386;
        --success: #21a179;
        --danger: #e04040;
        font-family: "Nunito", "PingFang SC", "Microsoft YaHei", sans-serif;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        background: linear-gradient(135deg, #e0e8ff, #faf5ff 60%);
        color: var(--text);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 24px 16px 48px;
      }

      .wrapper {
        width: min(1100px, 100%);
        display: grid;
        gap: 20px;
      }

      .back-button {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        width: fit-content;
        padding: 8px 18px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.9);
        color: var(--accent);
        font-weight: 600;
        text-decoration: none;
        box-shadow: 0 8px 22px rgba(65, 101, 255, 0.2);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .back-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 12px 28px rgba(65, 101, 255, 0.28);
      }

      .restart-button {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        width: fit-content;
        padding: 8px 18px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.9);
        color: var(--accent);
        font-weight: 600;
        text-decoration: none;
        border: none;
        cursor: pointer;
        font-size: 14px;
        font-family: inherit;
        box-shadow: 0 8px 22px rgba(65, 101, 255, 0.2);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .restart-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 12px 28px rgba(65, 101, 255, 0.28);
      }

      .level-selector {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-top: 12px;
        flex-wrap: wrap;
      }

      .level-selector label {
        font-size: 14px;
        font-weight: 600;
        color: var(--text);
      }

      .level-selector select {
        padding: 8px 16px;
        border-radius: 12px;
        border: 2px solid rgba(65, 101, 255, 0.3);
        background: rgba(255, 255, 255, 0.9);
        color: var(--accent);
        font-weight: 600;
        font-size: 14px;
        font-family: inherit;
        cursor: pointer;
        outline: none;
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
      }

      .level-selector select:hover {
        border-color: rgba(65, 101, 255, 0.5);
        box-shadow: 0 4px 12px rgba(65, 101, 255, 0.15);
      }

      .level-selector select:focus {
        border-color: var(--accent);
        box-shadow: 0 4px 12px rgba(65, 101, 255, 0.25);
      }

      .panel {
        background: var(--panel);
        border-radius: 28px;
        padding: 24px 28px;
        box-shadow: 0 22px 46px rgba(34, 48, 120, 0.15);
        display: grid;
        gap: 18px;
      }

      h1 {
        margin: 0;
        font-size: clamp(28px, 6vw, 42px);
        font-weight: 800;
        letter-spacing: 1px;
      }

      .subtitle {
        margin: 0;
        color: var(--muted);
        font-size: clamp(16px, 4vw, 18px);
        line-height: 1.6;
        max-width: 760px;
      }

      .hud {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 12px;
      }

      .hud-item {
        padding: 12px 18px;
        border-radius: 18px;
        background: rgba(255, 255, 255, 0.9);
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6), 0 10px 18px rgba(25, 32, 80, 0.12);
        text-align: center;
        font-size: 14px;
        font-variant-numeric: tabular-nums;
      }

      .hud-item strong {
        display: block;
        margin-top: 4px;
        font-size: 20px;
        color: var(--accent);
      }

      .controls {
        display: grid;
        gap: 12px;
        font-size: 14px;
        color: var(--muted);
      }

      .controls ul {
        list-style: none;
        padding: 0;
        margin: 0;
        display: grid;
        gap: 8px;
      }

      .controls li {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      .key {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 4px 10px;
        border-radius: 10px;
        border: 1px solid rgba(65, 101, 255, 0.3);
        background: rgba(65, 101, 255, 0.08);
        font-weight: 600;
        color: var(--accent);
      }

      .notice {
        padding: 12px 16px;
        border-radius: 16px;
        background: rgba(65, 101, 255, 0.12);
        color: var(--accent-dark);
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6);
        font-size: 14px;
      }

      .canvas-wrapper {
        position: relative;
        width: 100%;
        border-radius: 24px;
        overflow: hidden;
        box-shadow: 0 18px 42px rgba(26, 33, 90, 0.18);
      }

      canvas {
        display: block;
        width: 100%;
        height: auto;
        background: radial-gradient(circle at 20% 15%, #ffffff, #d8e6ff 80%);
      }

      .toast {
        position: fixed;
        bottom: 32px;
        left: 50%;
        transform: translateX(-50%) translateY(20px);
        background: rgba(31, 45, 110, 0.88);
        color: #fff;
        padding: 12px 20px;
        border-radius: 999px;
        box-shadow: 0 12px 30px rgba(31, 45, 110, 0.35);
        font-size: 14px;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.25s ease, transform 0.25s ease;
        z-index: 20;
      }

      .toast.show {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }

      @media (max-width: 768px) {
        .panel {
          padding: 20px 22px;
        }

        .hud-item {
          padding: 10px 14px;
        }
      }
    </style>
  </head>
  <body>
    <div class="wrapper">
      <a class="back-button" href="../index.html">
        <span>←</span>
        More Games
      </a>
      <div class="panel">
        <h1>Mario’s CNS Sprint</h1>
        <p class="subtitle">
          Guide Researcher Mario through the FigureYa lab, stomp mischievous Goombas, collect scattered figures, unleash fireballs, and sprint to the finish to publish that CNS paper!
        </p>
        <div class="hud" role="status" aria-live="polite">
          <div class="hud-item">
            Score
            <strong id="hud-score">000000</strong>
          </div>
          <div class="hud-item">
            Figures
            <strong id="hud-coins">×00</strong>
          </div>
          <div class="hud-item">
            Ammo
            <strong id="hud-ammo">×00</strong>
          </div>
          <div class="hud-item">
            Lives
            <strong id="hud-life">×01</strong>
          </div>
          <div class="hud-item">
            Time
            <strong id="hud-time">300</strong>
          </div>
          <div class="hud-item">
            World
            <strong id="hud-world">1-1</strong>
          </div>
        </div>
        <div class="controls">
          <div>
            <strong>Controls</strong>
            <ul>
              <li>
                <span class="key">WASD</span>
                or
                <span class="key">Arrow Keys</span>
                : Move & Jump
              </li>
              <li>
                <span class="key">Space</span>
                or
                <span class="key">K</span>
                : Jump
              </li>
              <li>
                <span class="key">F</span>
                : Fire research fireballs (requires ammo)
              </li>
              <li>
                <span class="key">T</span>
                : Return to 1-1 and restart
              </li>
            </ul>
          </div>
          <div style="margin-top: 12px;">
            <button class="restart-button" id="restart-current-level" type="button">
              <span>↻</span>
              Restart Current Level
            </button>
          </div>
          <div class="level-selector">
            <label for="level-select">Start Level:</label>
            <select id="level-select">
              <option value="0">1-1 FigureYa Plains</option>
              <option value="1">1-2 Underground Lab</option>
              <option value="2">1-3 Cloudtop Testbed</option>
              <option value="3">1-4 Candy House</option>
              <option value="4">1-5 Haunted Mansion</option>
              <option value="5">1-6 Underwater Lab</option>
              <option value="6">1-7 Mountain Climb</option>
              <option value="7">1-8 Ski Resort</option>
            </select>
          </div>
        </div>
        <div class="notice" role="note">
          <strong>Tip:</strong> Stomp Goombas by landing on them, hit "?" blocks or collect 10 figure sheets to earn a fireball, grab mushrooms to grow or gain lives, and watch the candy house erupt in CNS fireworks at the finish!
        </div>
        <div class="canvas-wrapper">
          <canvas
            id="game"
            width="960"
            height="540"
            aria-label="Mario’s CNS Sprint game canvas"
          ></canvas>
        </div>
      </div>
    </div>
    <div class="toast" id="toast" role="status" aria-live="polite"></div>
    <script>
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      const hudScore = document.getElementById("hud-score");
      const hudCoins = document.getElementById("hud-coins");
      const hudAmmo = document.getElementById("hud-ammo");
      const hudLife = document.getElementById("hud-life");
      const hudTime = document.getElementById("hud-time");
      const hudWorld = document.getElementById("hud-world");
      const toast = document.getElementById("toast");

      const figureGalleryFiles = [
        "FigureYa108RNAseqChIP.webp",
        "FigureYa115cofactor.webp",
        "FigureYa121MethCGIcluster.webp",
        "FigureYa233genepair.webp",
        "FigureYa285scRNA_monocle.webp",
        "FigureYa323STpathseq.webp",
      ];

      const figureGallery = figureGalleryFiles
        .map((file) => {
          const img = new Image();
          img.src = `./gallery_compress/${file}`;
          img.alt = file;
          return img;
        })
        .filter(Boolean);

      function getRandomFigureImage() {
        if (!figureGallery.length) return null;
        const index = Math.floor(Math.random() * figureGallery.length);
        return figureGallery[index];
      }

      const world = {
        gravity: 1600,
        friction: 0.86,
        width: canvas.width,
        height: canvas.height,
        camera: { x: 0, y: 0 },
        goalX: 3300,
        timeLimit: 300,
      };

      let activeTheme = null;

      const keyState = new Set();

      function showToast(message, duration = 1600) {
        toast.textContent = message;
        toast.classList.add("show");
        clearTimeout(showToast.timer);
        showToast.timer = setTimeout(() => toast.classList.remove("show"), duration);
      }

      function clamp(value, min, max) {
        return Math.min(Math.max(value, min), max);
      }

      function updateAmmoHUD() {
        if (!player) return;
        hudAmmo.textContent = `×${player.ammo.toString().padStart(2, "0")}`;
        hudLife.textContent = `×${(player.extraLives + 1).toString().padStart(2, "0")}`;
      }

      class Entity {
        constructor(x, y, width, height) {
          this.x = x;
          this.y = y;
          this.width = width;
          this.height = height;
          this.vx = 0;
          this.vy = 0;
          this.removed = false;
        }

        get left() {
          return this.x;
        }
        get right() {
          return this.x + this.width;
        }
        get top() {
          return this.y;
        }
        get bottom() {
          return this.y + this.height;
        }
      }

      class Player extends Entity {
        constructor(x, y) {
          super(x, y, 38, 48);
          this.onGround = false;
          this.score = 0;
          this.coins = 0;
          this.state = "idle";
          this.invincibleTimer = 0;
          this.animationTimer = 0;
          this.facing = 1;
          this.size = "small";
          this.dimensions = {
            small: { width: 38, height: 48 },
            big: { width: 46, height: 78 },
          };
          this.extraLives = 0;
          this.ammo = 0;
          this.collectibles = 0;
          this.onSkateboard = false;
          this.skateboardTimer = 0;
          this.updateDimensions("small");
        }

        updateDimensions(size) {
          const { width, height } = this.dimensions[size];
          const bottom = this.bottom;
          this.width = width;
          this.height = height;
          this.y = bottom - height;
        }

        setSize(size, { silent = false } = {}) {
          if (this.size === size) return;
          this.size = size;
          this.updateDimensions(size);
          if (!silent) {
            if (size === "big") {
              showToast("Research Mario leveled up—extra protection gained!", 1400);
            } else if (size === "small") {
              showToast("Ouch! Shrunk back down—stay alert!", 1400);
            }
          }
          this.onGround = false;
        }

        grow() {
          if (this.size === "small") {
            this.setSize("big");
            this.invincibleTimer = 2.2;
          } else {
            this.extraLives += 1;
            this.addScore(400);
            updateAmmoHUD();
            showToast("Research blossom acquired! Extra life +1!", 1600);
          }
        }

        update(dt) {
          const isSnow = activeTheme && activeTheme.key === "snow";
          
          // 滑板状态更新
          if (this.onSkateboard) {
            this.skateboardTimer += dt;
            // 滑板持续10秒
            if (this.skateboardTimer > 10) {
              this.onSkateboard = false;
              this.skateboardTimer = 0;
              showToast("Skateboard worn out!", 1200);
            }
          }
          
          // 滑雪场速度更快，滑板上更快
          const baseSpeed = this.size === "big" ? 300 : 280;
          let speed = isSnow ? baseSpeed * 1.3 : baseSpeed;
          if (this.onSkateboard) {
            speed = baseSpeed * 2.0; // 滑板上速度翻倍
          }
          const accel = this.onGround ? 1400 : 860;
          const maxSpeed = this.onGround ? speed : speed - 40;

          if (keyState.has("ArrowLeft") || keyState.has("KeyA")) {
            this.vx = clamp(this.vx - accel * dt, -maxSpeed, maxSpeed);
            this.facing = -1;
          } else if (keyState.has("ArrowRight") || keyState.has("KeyD")) {
            this.vx = clamp(this.vx + accel * dt, -maxSpeed, maxSpeed);
            this.facing = 1;
          } else if (this.onGround) {
            // 滑板上摩擦力更低
            const friction = this.onSkateboard ? 0.96 : world.friction;
            this.vx *= friction;
            // 滑板上需要更小的速度阈值才能停下
            const stopThreshold = this.onSkateboard ? 10 : (isSnow ? 15 : 40);
            if (Math.abs(this.vx) < stopThreshold) this.vx = 0;
          }

          const jumpVelocity = this.size === "big" ? -700 : -600;
          if (
            (keyState.has("ArrowUp") ||
              keyState.has("KeyW") ||
              keyState.has("Space") ||
              keyState.has("KeyK")) &&
            this.onGround
          ) {
            this.vy = jumpVelocity;
            this.onGround = false;
            showToast("Lift-off! Research Mario leaps into action!", 1000);
          }

          this.vy += world.gravity * dt;
          this.vy = Math.min(this.vy, 980);

          this.x += this.vx * dt;
          this.y += this.vy * dt;

          this.animationTimer += dt;
          if (this.vy < -60) {
            this.state = "jump";
          } else if (!this.onGround) {
            this.state = "fall";
          } else if (Math.abs(this.vx) > 20) {
            this.state = "run";
          } else {
            this.state = "idle";
          }

          if (this.invincibleTimer > 0) {
            this.invincibleTimer = Math.max(0, this.invincibleTimer - dt);
          }
        }

        addScore(points) {
          this.score += points;
          hudScore.textContent = this.score.toString().padStart(6, "0");
        }

        addCoin(count = 1, { track = true } = {}) {
          this.coins += count;
          hudCoins.textContent = `×${this.coins.toString().padStart(2, "0")}`;
          this.addScore(200);
          if (track) {
            this.trackCollectible(count);
          }
        }

        bounce() {
          this.vy = this.size === "big" ? -540 : -480;
          this.onGround = false;
        }

        fire() {
          if (this.ammo <= 0) {
            showToast("Out of ammo—collect more figures and hit those question blocks!", 1400);
            return null;
          }
          const direction = this.facing === -1 ? -1 : 1;
          const originX = this.x + this.width / 2 - 11 + direction * 30;
          const originY = this.y + this.height / 2 - 11;
          const fireball = new Fireball(originX, originY, direction);
          this.ammo = Math.max(0, this.ammo - 1);
          updateAmmoHUD();
          return fireball;
        }

        trackCollectible(count = 1) {
          this.collectibles += count;
          while (this.collectibles >= 10) {
            this.collectibles -= 10;
            this.ammo += 1;
            updateAmmoHUD();
            showToast("Research ammo +1! Press F to launch fireballs!", 1400);
          }
        }
      }

      class Goomba extends Entity {
        constructor(x, y) {
          super(x, y, 40, 42);
          this.direction = -1;
          this.walkSpeed = 60;
          this.vx = this.direction * this.walkSpeed;
          this.state = "walk";
          this.animationTimer = 0;
          this.flattenTimer = 0.4;
        }

        update(dt) {
          if (this.state === "squashed") {
            this.flattenTimer -= dt;
            if (this.flattenTimer <= 0) {
              this.removed = true;
            }
            return;
          }
          this.vy += world.gravity * dt;
          this.vy = Math.min(this.vy, 700);
          this.vx = this.direction * this.walkSpeed;
          this.x += this.vx * dt;
          this.y += this.vy * dt;
          this.animationTimer += dt;
        }

        squash() {
          this.state = "squashed";
          this.vx = 0;
          this.vy = 0;
        }
      }

      class Monkey extends Entity {
        constructor(x, y) {
          super(x, y, 40, 42);
          this.direction = -1;
          this.walkSpeed = 70;
          this.vx = this.direction * this.walkSpeed;
          this.state = "walk";
          this.animationTimer = 0;
          this.flattenTimer = 0.4;
          this.jumpTimer = 0;
          this.jumpInterval = 0.8 + Math.random() * 1.2; // 0.8-2秒跳一次
          this.onGround = true; // 初始在地面上
          this.jumpPower = -550; // 跳跃力度
        }

        update(dt) {
          if (this.state === "squashed") {
            this.flattenTimer -= dt;
            if (this.flattenTimer <= 0) {
              this.removed = true;
            }
            return;
          }

          // 上蹿下跳：定期跳跃
          this.jumpTimer += dt;
          if (this.onGround && this.jumpTimer >= this.jumpInterval) {
            this.vy = this.jumpPower;
            this.onGround = false;
            this.jumpTimer = 0;
            this.jumpInterval = 0.8 + Math.random() * 1.2; // 重新设置跳跃间隔
          }

          // 应用重力
          this.vy += world.gravity * dt;
          this.vy = Math.min(this.vy, 700);
          
          // 水平移动
          this.vx = this.direction * this.walkSpeed;
          
          this.x += this.vx * dt;
          this.y += this.vy * dt;
          this.animationTimer += dt;
        }

        squash() {
          this.state = "squashed";
          this.vx = 0;
          this.vy = 0;
        }
      }

      class Shark extends Entity {
        constructor(x, y) {
          super(x, y, 48, 36);
          this.directionX = Math.random() > 0.5 ? 1 : -1;
          this.directionY = Math.random() > 0.5 ? 1 : -1;
          this.swimSpeedX = 50 + Math.random() * 30;
          this.swimSpeedY = 40 + Math.random() * 30;
          this.vx = this.directionX * this.swimSpeedX;
          this.vy = this.directionY * this.swimSpeedY;
          this.state = "swimming";
          this.animationTimer = 0;
          this.flattenTimer = 0.4;
          this.swimTimer = 0;
          this.changeDirectionTimer = 1 + Math.random() * 2; // 1-3秒后改变方向
          this.startY = y; // 记录初始Y位置
          this.swimRange = 200; // 游动范围（上下），在水中可以游得更自由
          this.startX = x; // 记录初始X位置
          this.swimRangeX = 300; // 水平游动范围
        }

        update(dt) {
          if (this.state === "squashed") {
            this.flattenTimer -= dt;
            if (this.flattenTimer <= 0) {
              this.removed = true;
            }
            return;
          }

          // 在水中游动，不受重力影响
          // 减少重力影响（浮力效果）
          this.vy += world.gravity * dt * 0.3; // 只有30%的重力影响
          this.vy = Math.min(this.vy, 400); // 限制最大下降速度
          this.vy = Math.max(this.vy, -400); // 限制最大上升速度

          // 定期改变游动方向
          this.swimTimer += dt;
          if (this.swimTimer >= this.changeDirectionTimer) {
            // 随机改变水平方向
            if (Math.random() > 0.5) {
              this.directionX *= -1;
            }
            // 随机改变垂直方向
            if (Math.random() > 0.5) {
              this.directionY *= -1;
            }
            // 随机调整速度
            this.swimSpeedX = 50 + Math.random() * 30;
            this.swimSpeedY = 40 + Math.random() * 30;
            this.changeDirectionTimer = 1 + Math.random() * 2;
            this.swimTimer = 0;
          }

          // 如果离初始位置太远，向回游（垂直方向）
          const distanceFromStartY = this.y - this.startY;
          if (Math.abs(distanceFromStartY) > this.swimRange) {
            this.directionY = distanceFromStartY > 0 ? -1 : 1;
          }
          
          // 如果离初始位置太远，向回游（水平方向）
          const distanceFromStartX = this.x - this.startX;
          if (Math.abs(distanceFromStartX) > this.swimRangeX) {
            this.directionX = distanceFromStartX > 0 ? -1 : 1;
          }

          // 应用游动速度
          this.vx = this.directionX * this.swimSpeedX;
          // 垂直方向：结合主动游动和重力
          const targetVy = this.directionY * this.swimSpeedY;
          this.vy = this.vy * 0.7 + targetVy * 0.3; // 平滑过渡

          // 添加一些随机波动，让游动更自然（减少波动幅度，让游动更平滑）
          const waveOffsetY = Math.sin(this.animationTimer * 2) * 5;
          this.vy += waveOffsetY * dt;
          // 水平方向也有轻微波动
          const waveOffsetX = Math.sin(this.animationTimer * 2.5) * 3;
          this.vx += waveOffsetX * dt;

          this.x += this.vx * dt;
          this.y += this.vy * dt;
          this.animationTimer += dt;
        }

        squash() {
          this.state = "squashed";
          this.vx = 0;
          this.vy = 0;
        }
      }

      class Coin extends Entity {
        constructor(x, y) {
          super(x, y, 42, 42);
          this.baseY = y;
          this.timer = 0;
          this.texture = getRandomFigureImage();
          this.spin = Math.random() * Math.PI * 2;
        }

        update(dt) {
          this.timer += dt * 4;
          this.y = this.baseY + Math.sin(this.timer) * 6;
          this.spin += dt * 0.8;
        }
      }

      class Mushroom extends Entity {
        constructor(x, y) {
          super(x, y, 34, 34);
          this.direction = 1;
          this.walkSpeed = 90;
        }

        update(dt) {
          if (this.float) {
            this.timer = (this.timer || 0) + dt * 2;
            this.y += Math.sin(this.timer) * 12 * dt;
            this.vx = 0;
          } else {
            this.vy += world.gravity * dt;
            this.vy = Math.min(this.vy, 680);
            this.vx = this.direction * this.walkSpeed;
            this.x += this.vx * dt;
            this.y += this.vy * dt;
          }
        }
      }

      class Fireball extends Entity {
        constructor(x, y, direction) {
          super(x, y, 22, 22);
          this.direction = direction;
          this.speed = 660;
          this.life = 4;
          this.rotation = 0;
        }

        update(dt) {
          this.x += this.direction * this.speed * dt;
          this.rotation += dt * 6;
          this.life -= dt;
        }
      }

      class Skateboard extends Entity {
        constructor(x, y) {
          super(x, y, 50, 12);
          this.rotation = 0;
          this.floatTimer = 0;
        }

        update(dt) {
          this.floatTimer += dt * 3;
          this.rotation = Math.sin(this.floatTimer) * 0.1;
        }
      }

      class SnowPile extends Entity {
        constructor(x, y) {
          super(x, y, 60, 40);
        }
      }

      class IcePillar extends Entity {
        constructor(x, y) {
          super(x, y, 32, 80);
        }
      }

      class Brick extends Entity {
        constructor(x, y, { kind = "solid", reward = null } = {}) {
          super(x, y, 48, 48);
          this.kind = kind;
          this.reward = reward ?? (kind === "question" ? "coin" : null);
          this.bump = 0;
          this.active = true;
        }

        trigger(player) {
          if (!this.active) return;
          if (this.kind === "question") {
            this.active = false;
            this.kind = "empty";
            this.bump = 0.18;
            player.trackCollectible();
            if (this.reward === "coin") {
              player.addCoin(1, { track: false });
            showToast("FigureYa figure collected!", 900);
            } else if (this.reward === "mushroom") {
              spawnMushroom(this);
            }
          } else if (this.kind === "solid") {
            this.bump = 0.12;
          }
        }

        update(dt) {
          if (this.bump > 0) {
            this.bump = Math.max(0, this.bump - dt * 2);
          }
        }
      }

      class Flag extends Entity {
        constructor(x, y) {
          super(x, y, 24, 180);
          this.flagY = y + 16;
          this.flagOffset = 0;
        }

        update(dt) {
          this.flagOffset = Math.sin(Date.now() / 400) * 6;
        }
      }

      const level = {
        platforms: [],
        entities: [],
        coins: [],
        bricks: [],
        pipes: [],
        powerups: [],
        projectiles: [],
        skateboards: [],
        snowPiles: [],
        icePillars: [],
        flag: null,
      };

      const levelCelebration = {
        papers: [],
        active: false,
        origin: null,
        timer: 0,
        spawn() {
          const flag = level.flag;
          if (!flag) return;
          this.active = true;
          this.origin = { x: flag.x, y: flag.y - 32 };
          this.timer = 0;
          this.papers = [];
        },
        update(dt) {
          if (!this.active) return;
          this.timer += dt;
          const interval = activeTheme && activeTheme.key === "candy" ? 0.18 : 0.22;
          const burstSize = activeTheme && activeTheme.key === "candy" ? 18 : 12;
          const labels =
            activeTheme && activeTheme.key === "candy"
              ? ["C", "N", "S", "Impact"]
              : ["Cell", "Nature", "Science"];
          const flag = level.flag;
          if (flag) {
            this.origin = { x: flag.x, y: flag.y - 32 };
          }
          if (this.timer >= interval && this.origin) {
            this.timer = 0;
            for (let i = 0; i < burstSize; i++) {
              const angle = Math.random() * Math.PI * 2;
              const speed = 200 + Math.random() * 180;
              const vx = Math.cos(angle) * speed;
              const vy = Math.sin(angle) * speed - 220;
              this.papers.push({
                x: this.origin.x,
                y: this.origin.y,
                vx,
                vy,
                rotation: (Math.random() - 0.5) * 1.6,
                rotationSpeed: (Math.random() - 0.5) * 2,
                life: 2.5 + Math.random() * 0.8,
                label: labels[i % labels.length],
              });
            }
          }
          this.papers.forEach((paper) => {
            paper.vy += world.gravity * 0.5 * dt;
            paper.x += paper.vx * dt;
            paper.y += paper.vy * dt;
            paper.rotation += paper.rotationSpeed * dt;
            paper.life -= dt;
          });
          this.papers = this.papers.filter((paper) => paper.life > 0);
        },
        draw() {
          if (!this.active || !this.papers.length) return;
          this.papers.forEach((paper) => {
            const x = paper.x - world.camera.x;
            const y = paper.y;
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(paper.rotation);
            const width = 74;
            const height = 54;
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(-width / 2, -height / 2, width, height);
            ctx.strokeStyle = "#d1d1d1";
            ctx.strokeRect(-width / 2, -height / 2, width, height);
            ctx.fillStyle =
              activeTheme && activeTheme.key === "candy" ? "#ff5d8f" : "#1a237e";
            ctx.font = "bold 18px Nunito";
            ctx.textAlign = "center";
            ctx.fillText(paper.label, 0, 6);
            ctx.restore();
          });
        },
      };

      function createGround(segments = 80) {
        for (let i = 0; i < segments; i++) {
          level.platforms.push({
            x: i * 64,
            y: world.height - 64,
            width: 64,
            height: 64,
          });
        }
      }

      function createPlatform(x, y, tiles) {
        level.platforms.push({
          x,
          y,
          width: tiles * 48,
          height: 16,
        });
      }

      function spawnMushroom(brick) {
        const mushroom = new Mushroom(
          brick.x + brick.width / 2 - 17,
          brick.y - 34,
        );
        level.powerups.push(mushroom);
        showToast("Research mushroom spotted—grow bigger or grab an extra life!", 1100);
      }

      const H = world.height;
      const levelDefinitions = [
        {
          name: "1-1",
          theme: "surface",
          intro: "FigureYa Plains 1-1: dash to the flag and publish!",
          goalX: 3300,
          timeLimit: 300,
          groundSegments: 80,
          start: { x: 120, y: H - 140 },
          platforms: [
            { x: 420, y: H - 200, tiles: 2 },
            { x: 720, y: H - 260, tiles: 3 },
            { x: 1020, y: H - 320, tiles: 2 },
            { x: 1380, y: H - 260, tiles: 4 },
            { x: 1700, y: H - 200, tiles: 2 },
            { x: 2060, y: H - 220, tiles: 2 },
            { x: 2360, y: H - 200, tiles: 2 },
          ],
          bricks: [
            { x: 600, y: H - 260, kind: "question", reward: "mushroom" },
            { x: 648, y: H - 260, kind: "solid" },
            { x: 696, y: H - 260, kind: "question", reward: "coin" },
            { x: 744, y: H - 260, kind: "solid" },
            { x: 792, y: H - 260, kind: "question", reward: "coin" },
            { x: 1100, y: H - 320, kind: "question", reward: "coin" },
            { x: 1148, y: H - 320, kind: "question", reward: "coin" },
            { x: 1520, y: H - 260, kind: "solid" },
            { x: 1568, y: H - 260, kind: "question", reward: "coin" },
            { x: 1616, y: H - 260, kind: "solid" },
          ],
          coins: [
            [500, H - 140],
            [560, H - 160],
            [620, H - 180],
            [840, H - 220],
            [880, H - 240],
            [920, H - 260],
            [1900, H - 220],
            [1960, H - 240],
            [2020, H - 260],
          ],
          goombas: [
            { x: 780, y: H - 110 },
            { x: 1260, y: H - 110 },
            { x: 2000, y: H - 110 },
          ],
          flag: { x: 3300, y: H - 256 },
        },
        {
          name: "1-2",
          theme: "underground",
          intro: "Underground Lab 1-2: mind the shadowy experiments!",
          goalX: 2600,
          timeLimit: 250,
          groundSegments: 70,
          start: { x: 180, y: H - 140 },
          platforms: [
            { x: 360, y: H - 220, tiles: 3 },
            { x: 760, y: H - 240, tiles: 2 },
            { x: 1100, y: H - 220, tiles: 3 },
            { x: 1480, y: H - 200, tiles: 3 },
            { x: 1880, y: H - 220, tiles: 2 },
            { x: 2140, y: H - 240, tiles: 3 },
          ],
          bricks: [
            { x: 520, y: H - 220, kind: "question", reward: "coin" },
            { x: 568, y: H - 220, kind: "question", reward: "mushroom" },
            { x: 616, y: H - 220, kind: "solid" },
            { x: 1200, y: H - 220, kind: "question", reward: "coin" },
            { x: 1248, y: H - 220, kind: "question", reward: "coin" },
            { x: 1296, y: H - 220, kind: "question", reward: "coin" },
            { x: 1660, y: H - 200, kind: "question", reward: "mushroom" },
          ],
          coins: [
            [420, H - 140],
            [460, H - 160],
            [820, H - 200],
            [860, H - 220],
            [900, H - 200],
            [1500, H - 200],
            [1540, H - 220],
            [1580, H - 240],
            [2000, H - 260],
            [2040, H - 240],
          ],
          goombas: [
            { x: 900, y: H - 110 },
            { x: 1380, y: H - 110 },
            { x: 1900, y: H - 110 },
          ],
          flag: { x: 2600, y: H - 256 },
        },
        {
          name: "1-3",
          theme: "sky",
          intro: "Cloudtop Testbed 1-3: rhythm jumps win the day!",
          goalX: 3600,
          timeLimit: 260,
          groundSegments: 85,
          start: { x: 140, y: H - 200 },
          platforms: [
            { x: 260, y: H - 280, tiles: 2 },
            { x: 520, y: H - 240, tiles: 3 },
            { x: 820, y: H - 300, tiles: 2 },
            { x: 1080, y: H - 260, tiles: 3 },
            { x: 1400, y: H - 320, tiles: 3 },
            { x: 1740, y: H - 280, tiles: 3 },
            { x: 2080, y: H - 260, tiles: 2 },
            { x: 2360, y: H - 300, tiles: 2 },
            { x: 2680, y: H - 260, tiles: 3 },
            { x: 3040, y: H - 280, tiles: 2 },
          ],
          bricks: [
            { x: 520, y: H - 260, kind: "question", reward: "coin" },
            { x: 568, y: H - 260, kind: "question", reward: "mushroom" },
            { x: 1120, y: H - 280, kind: "question", reward: "coin" },
            { x: 1500, y: H - 340, kind: "question", reward: "coin" },
            { x: 1548, y: H - 340, kind: "question", reward: "coin" },
            { x: 1780, y: H - 300, kind: "question", reward: "mushroom" },
            { x: 2460, y: H - 320, kind: "question", reward: "coin" },
          ],
          coins: [
            [320, H - 260],
            [360, H - 280],
            [400, H - 260],
            [900, H - 320],
            [940, H - 300],
            [980, H - 320],
            [1320, H - 280],
            [1360, H - 300],
            [1400, H - 280],
            [1880, H - 280],
            [1920, H - 300],
            [1960, H - 280],
            [2260, H - 280],
            [2300, H - 300],
            [2340, H - 280],
            [2760, H - 260],
            [2800, H - 280],
            [2840, H - 260],
          ],
          goombas: [
            { x: 600, y: H - 160 },
            { x: 1220, y: H - 160 },
            { x: 1700, y: H - 160 },
            { x: 2320, y: H - 160 },
            { x: 2900, y: H - 160 },
          ],
          flag: { x: 3600, y: H - 256 },
        },
        {
          name: "1-4",
          theme: "candy",
          intro: "Candy House Celebration 1-4: present your manuscript on the CNS stage!",
          goalX: 3200,
          timeLimit: 320,
          groundSegments: 75,
          start: { x: 160, y: H - 140 },
          platforms: [
            { x: 320, y: H - 240, tiles: 3 },
            { x: 680, y: H - 220, tiles: 2 },
            { x: 960, y: H - 260, tiles: 3 },
            { x: 1340, y: H - 280, tiles: 3 },
            { x: 1680, y: H - 240, tiles: 3 },
            { x: 2020, y: H - 260, tiles: 3 },
            { x: 2360, y: H - 220, tiles: 2 },
            { x: 2680, y: H - 240, tiles: 2 },
          ],
          bricks: [
            { x: 520, y: H - 240, kind: "question", reward: "coin" },
            { x: 568, y: H - 240, kind: "question", reward: "coin" },
            { x: 616, y: H - 240, kind: "question", reward: "mushroom" },
            { x: 1120, y: H - 280, kind: "question", reward: "coin" },
            { x: 1168, y: H - 280, kind: "solid" },
            { x: 1520, y: H - 320, kind: "question", reward: "coin" },
            { x: 1568, y: H - 320, kind: "question", reward: "coin" },
            { x: 1820, y: H - 260, kind: "question", reward: "mushroom" },
            { x: 2140, y: H - 280, kind: "question", reward: "coin" },
            { x: 2188, y: H - 280, kind: "solid" },
            { x: 2460, y: H - 240, kind: "question", reward: "coin" },
          ],
          coins: [
            [360, H - 200],
            [400, H - 220],
            [440, H - 240],
            [780, H - 220],
            [820, H - 240],
            [860, H - 260],
            [1180, H - 260],
            [1220, H - 280],
            [1260, H - 260],
            [1640, H - 240],
            [1680, H - 260],
            [1720, H - 240],
            [2060, H - 260],
            [2100, H - 240],
            [2300, H - 200],
            [2340, H - 220],
            [2380, H - 200],
            [2700, H - 220],
            [2740, H - 240],
            [2780, H - 220],
          ],
          goombas: [
            { x: 620, y: H - 110 },
            { x: 980, y: H - 110 },
            { x: 1420, y: H - 110 },
            { x: 1880, y: H - 110 },
            { x: 2260, y: H - 110 },
          ],
          flag: { x: 3200, y: H - 256 },
        },
        {
          name: "1-5",
          theme: "ghost",
          intro: "Haunted Mansion 1-5: brave the spooky corridors and escape!",
          goalX: 3800,
          timeLimit: 280,
          groundSegments: 90,
          start: { x: 140, y: H - 140 },
          platforms: [
            { x: 380, y: H - 240, tiles: 2 },
            { x: 680, y: H - 280, tiles: 3 },
            { x: 1040, y: H - 220, tiles: 2 },
            { x: 1380, y: H - 300, tiles: 2 },
            { x: 1720, y: H - 260, tiles: 3 },
            { x: 2100, y: H - 240, tiles: 2 },
            { x: 2480, y: H - 280, tiles: 3 },
            { x: 2880, y: H - 220, tiles: 2 },
            { x: 3240, y: H - 260, tiles: 3 },
          ],
          bricks: [
            { x: 520, y: H - 240, kind: "question", reward: "coin" },
            { x: 568, y: H - 240, kind: "question", reward: "mushroom" },
            { x: 800, y: H - 300, kind: "question", reward: "coin" },
            { x: 848, y: H - 300, kind: "solid" },
            { x: 896, y: H - 300, kind: "question", reward: "coin" },
            { x: 1200, y: H - 240, kind: "question", reward: "coin" },
            { x: 1248, y: H - 240, kind: "question", reward: "mushroom" },
            { x: 1500, y: H - 320, kind: "question", reward: "coin" },
            { x: 1548, y: H - 320, kind: "question", reward: "coin" },
            { x: 1860, y: H - 280, kind: "question", reward: "coin" },
            { x: 1908, y: H - 280, kind: "solid" },
            { x: 1956, y: H - 280, kind: "question", reward: "mushroom" },
            { x: 2240, y: H - 260, kind: "question", reward: "coin" },
            { x: 2620, y: H - 300, kind: "question", reward: "coin" },
            { x: 2668, y: H - 300, kind: "question", reward: "coin" },
            { x: 3020, y: H - 240, kind: "question", reward: "mushroom" },
            { x: 3400, y: H - 280, kind: "question", reward: "coin" },
          ],
          coins: [
            [420, H - 200],
            [460, H - 220],
            [500, H - 240],
            [900, H - 280],
            [940, H - 300],
            [980, H - 280],
            [1280, H - 200],
            [1320, H - 220],
            [1360, H - 240],
            [1640, H - 300],
            [1680, H - 320],
            [1720, H - 300],
            [2000, H - 220],
            [2040, H - 240],
            [2080, H - 220],
            [2380, H - 260],
            [2420, H - 280],
            [2460, H - 260],
            [2780, H - 200],
            [2820, H - 220],
            [2860, H - 200],
            [3180, H - 240],
            [3220, H - 260],
            [3260, H - 240],
          ],
          goombas: [
            { x: 800, y: H - 110 },
            { x: 1200, y: H - 110 },
            { x: 1600, y: H - 110 },
            { x: 2200, y: H - 110 },
            { x: 2800, y: H - 110 },
            { x: 3400, y: H - 110 },
          ],
          flag: { x: 3800, y: H - 256 },
        },
        {
          name: "1-6",
          theme: "water",
          intro: "Underwater Lab 1-6: dive deep and explore the aquatic research facility!",
          goalX: 4000,
          timeLimit: 300,
          groundSegments: 95,
          start: { x: 160, y: H - 200 },
          platforms: [
            { x: 400, y: H - 280, tiles: 3 },
            { x: 800, y: H - 240, tiles: 2 },
            { x: 1200, y: H - 320, tiles: 3 },
            { x: 1600, y: H - 260, tiles: 2 },
            { x: 2000, y: H - 300, tiles: 3 },
            { x: 2400, y: H - 220, tiles: 2 },
            { x: 2800, y: H - 280, tiles: 3 },
            { x: 3200, y: H - 240, tiles: 2 },
            { x: 3600, y: H - 300, tiles: 3 },
          ],
          bricks: [
            { x: 520, y: H - 300, kind: "question", reward: "coin" },
            { x: 568, y: H - 300, kind: "question", reward: "mushroom" },
            { x: 616, y: H - 300, kind: "question", reward: "coin" },
            { x: 920, y: H - 260, kind: "question", reward: "coin" },
            { x: 968, y: H - 260, kind: "solid" },
            { x: 1320, y: H - 340, kind: "question", reward: "mushroom" },
            { x: 1368, y: H - 340, kind: "question", reward: "coin" },
            { x: 1416, y: H - 340, kind: "question", reward: "coin" },
            { x: 1720, y: H - 280, kind: "question", reward: "coin" },
            { x: 1768, y: H - 280, kind: "question", reward: "mushroom" },
            { x: 2120, y: H - 320, kind: "question", reward: "coin" },
            { x: 2168, y: H - 320, kind: "solid" },
            { x: 2216, y: H - 320, kind: "question", reward: "coin" },
            { x: 2520, y: H - 240, kind: "question", reward: "mushroom" },
            { x: 2920, y: H - 300, kind: "question", reward: "coin" },
            { x: 2968, y: H - 300, kind: "question", reward: "coin" },
            { x: 3320, y: H - 260, kind: "question", reward: "mushroom" },
            { x: 3720, y: H - 320, kind: "question", reward: "coin" },
          ],
          coins: [
            [440, H - 260],
            [480, H - 280],
            [520, H - 300],
            [840, H - 220],
            [880, H - 240],
            [920, H - 260],
            [1280, H - 300],
            [1320, H - 320],
            [1360, H - 300],
            [1680, H - 240],
            [1720, H - 260],
            [1760, H - 240],
            [2080, H - 280],
            [2120, H - 300],
            [2160, H - 280],
            [2480, H - 200],
            [2520, H - 220],
            [2560, H - 200],
            [2880, H - 260],
            [2920, H - 280],
            [2960, H - 260],
            [3280, H - 220],
            [3320, H - 240],
            [3360, H - 220],
            [3680, H - 280],
            [3720, H - 300],
            [3760, H - 280],
          ],
          goombas: [
            { x: 700, y: H - 110 },
            { x: 1100, y: H - 110 },
            { x: 1500, y: H - 110 },
            { x: 1900, y: H - 110 },
            { x: 2300, y: H - 110 },
            { x: 2700, y: H - 110 },
            { x: 3100, y: H - 110 },
            { x: 3500, y: H - 110 },
          ],
          flag: { x: 4000, y: H - 256 },
        },
        {
          name: "1-7",
          theme: "climb",
          intro: "Mountain Climb 1-7: scale the peaks and reach the summit!",
          goalX: 4200,
          timeLimit: 320,
          groundSegments: 100,
          start: { x: 140, y: H - 140 },
          platforms: [
            { x: 400, y: H - 200, tiles: 2 },
            { x: 700, y: H - 260, tiles: 2 },
            { x: 1000, y: H - 240, tiles: 3 },
            { x: 1400, y: H - 280, tiles: 2 },
            { x: 1800, y: H - 260, tiles: 2 },
            { x: 2200, y: H - 300, tiles: 2 },
            { x: 2600, y: H - 280, tiles: 3 },
            { x: 3000, y: H - 320, tiles: 2 },
            { x: 3400, y: H - 300, tiles: 2 },
            { x: 3800, y: H - 320, tiles: 3 },
          ],
          bricks: [
            { x: 520, y: H - 220, kind: "question", reward: "coin" },
            { x: 568, y: H - 220, kind: "question", reward: "mushroom" },
            { x: 820, y: H - 280, kind: "question", reward: "coin" },
            { x: 868, y: H - 280, kind: "solid" },
            { x: 1120, y: H - 260, kind: "question", reward: "coin" },
            { x: 1168, y: H - 260, kind: "question", reward: "mushroom" },
            { x: 1216, y: H - 260, kind: "question", reward: "coin" },
            { x: 1520, y: H - 300, kind: "question", reward: "coin" },
            { x: 1568, y: H - 300, kind: "question", reward: "coin" },
            { x: 1920, y: H - 280, kind: "question", reward: "mushroom" },
            { x: 2320, y: H - 320, kind: "question", reward: "coin" },
            { x: 2368, y: H - 320, kind: "solid" },
            { x: 2720, y: H - 300, kind: "question", reward: "coin" },
            { x: 2768, y: H - 300, kind: "question", reward: "mushroom" },
            { x: 3120, y: H - 340, kind: "question", reward: "coin" },
            { x: 3168, y: H - 340, kind: "question", reward: "coin" },
            { x: 3520, y: H - 320, kind: "question", reward: "mushroom" },
            { x: 3920, y: H - 340, kind: "question", reward: "coin" },
          ],
          coins: [
            [420, H - 180],
            [460, H - 200],
            [500, H - 220],
            [780, H - 240],
            [820, H - 260],
            [860, H - 240],
            [1080, H - 220],
            [1120, H - 240],
            [1160, H - 220],
            [1480, H - 260],
            [1520, H - 280],
            [1560, H - 260],
            [1880, H - 240],
            [1920, H - 260],
            [1960, H - 240],
            [2280, H - 280],
            [2320, H - 300],
            [2360, H - 280],
            [2680, H - 260],
            [2720, H - 280],
            [2760, H - 260],
            [3080, H - 300],
            [3120, H - 320],
            [3160, H - 300],
            [3480, H - 280],
            [3520, H - 300],
            [3560, H - 280],
            [3880, H - 300],
            [3920, H - 320],
            [3960, H - 300],
          ],
          goombas: [
            { x: 650, y: H - 110 },
            { x: 950, y: H - 110 },
            { x: 1350, y: H - 110 },
            { x: 1750, y: H - 110 },
            { x: 2150, y: H - 110 },
            { x: 2550, y: H - 110 },
            { x: 2950, y: H - 110 },
            { x: 3350, y: H - 110 },
            { x: 3750, y: H - 110 },
          ],
          flag: { x: 4200, y: H - 256 },
        },
        {
          name: "1-8",
          theme: "snow",
          intro: "Ski Resort 1-8: glide through the snowy slopes and reach the finish!",
          goalX: 4500,
          timeLimit: 300,
          groundSegments: 105,
          start: { x: 120, y: H - 140 },
          platforms: [
            { x: 500, y: H - 180, tiles: 2 },
            { x: 900, y: H - 180, tiles: 2 },
            { x: 1400, y: H - 180, tiles: 2 },
            { x: 1900, y: H - 180, tiles: 2 },
            { x: 2400, y: H - 180, tiles: 2 },
            { x: 3000, y: H - 180, tiles: 2 },
            { x: 3500, y: H - 180, tiles: 2 },
            { x: 4000, y: H - 180, tiles: 2 },
          ],
          bricks: [
            { x: 600, y: H - 200, kind: "question", reward: "coin" },
            { x: 1000, y: H - 200, kind: "question", reward: "mushroom" },
            { x: 1500, y: H - 200, kind: "question", reward: "coin" },
            { x: 2000, y: H - 200, kind: "question", reward: "coin" },
            { x: 2500, y: H - 200, kind: "question", reward: "mushroom" },
            { x: 3100, y: H - 200, kind: "question", reward: "coin" },
            { x: 3600, y: H - 200, kind: "question", reward: "coin" },
            { x: 4100, y: H - 200, kind: "question", reward: "mushroom" },
          ],
          snowPiles: [
            { x: 700, y: H - 104 },
            { x: 1100, y: H - 104 },
            { x: 1600, y: H - 104 },
            { x: 2100, y: H - 104 },
            { x: 2600, y: H - 104 },
            { x: 3200, y: H - 104 },
            { x: 3700, y: H - 104 },
            { x: 4200, y: H - 104 },
          ],
          icePillars: [
            { x: 800, y: H - 144 },
            { x: 1300, y: H - 144 },
            { x: 1800, y: H - 144 },
            { x: 2300, y: H - 144 },
            { x: 2800, y: H - 144 },
            { x: 3300, y: H - 144 },
            { x: 3800, y: H - 144 },
          ],
          coins: [
            [400, H - 180],
            [440, H - 200],
            [480, H - 220],
            [720, H - 220],
            [760, H - 240],
            [800, H - 220],
            [1040, H - 200],
            [1080, H - 220],
            [1120, H - 200],
            [1440, H - 240],
            [1480, H - 260],
            [1520, H - 240],
            [1800, H - 180],
            [1840, H - 200],
            [1880, H - 180],
            [2180, H - 220],
            [2220, H - 240],
            [2260, H - 220],
            [2560, H - 200],
            [2600, H - 220],
            [2640, H - 200],
            [2960, H - 240],
            [3000, H - 260],
            [3040, H - 240],
            [3360, H - 180],
            [3400, H - 200],
            [3440, H - 180],
            [3760, H - 220],
            [3800, H - 240],
            [3840, H - 220],
            [4160, H - 200],
            [4200, H - 220],
            [4240, H - 200],
          ],
          goombas: [
            { x: 600, y: H - 110 },
            { x: 900, y: H - 110 },
            { x: 1300, y: H - 110 },
            { x: 1700, y: H - 110 },
            { x: 2100, y: H - 110 },
            { x: 2500, y: H - 110 },
            { x: 2900, y: H - 110 },
            { x: 3300, y: H - 110 },
            { x: 3700, y: H - 110 },
            { x: 4100, y: H - 110 },
          ],
          skateboards: [
            { x: 600, y: H - 128 },
            { x: 1800, y: H - 128 },
            { x: 3200, y: H - 128 },
          ],
          flag: { x: 4500, y: H - 256 },
        },
      ];

      const levelState = {
        platforms: [],
        entities: [],
        coins: [],
        bricks: [],
        pipes: [],
        powerups: [],
        projectiles: [],
        flag: null,
      };

      function buildLevel(definition) {
        level.platforms = [];
        level.entities = [];
        level.coins = [];
        level.bricks = [];
        level.pipes = [];
        level.powerups = [];
        level.projectiles = [];
        level.skateboards = [];
        level.snowPiles = [];
        level.icePillars = [];
        level.flag = null;
        levelCelebration.active = false;
        levelCelebration.papers = [];

        createGround(definition.groundSegments ?? 80);

        (definition.platforms ?? []).forEach(({ x, y, tiles }) => createPlatform(x, y, tiles));

        (definition.bricks ?? []).forEach(({ x, y, kind, reward }) =>
          level.bricks.push(new Brick(x, y, { kind, reward })),
        );

        (definition.coins ?? []).forEach(([x, y]) => level.coins.push(new Coin(x, y)));

        // 第六关（water主题）使用Shark，第七关（climb主题）使用Monkey，其他关卡使用Goomba
        (definition.goombas ?? []).forEach(({ x, y }) => {
          if (definition.theme === "water") {
            level.entities.push(new Shark(x, y));
          } else if (definition.theme === "climb") {
            level.entities.push(new Monkey(x, y));
          } else {
            level.entities.push(new Goomba(x, y));
          }
        });

        // 管道功能已禁用
        // (definition.pipes ?? []).forEach(({ x, y, width, height, warpTo }) =>
        //   level.pipes.push(new Pipe(x, y, width, height, { warpTo })),
        // );

        (definition.skateboards ?? []).forEach(({ x, y }) =>
          level.skateboards.push(new Skateboard(x, y)),
        );

        (definition.snowPiles ?? []).forEach(({ x, y }) =>
          level.snowPiles.push(new SnowPile(x, y)),
        );

        (definition.icePillars ?? []).forEach(({ x, y }) =>
          level.icePillars.push(new IcePillar(x, y)),
        );

        if (definition.flag) {
          level.flag = new Flag(definition.flag.x, definition.flag.y);
        }
      }

      class Pipe extends Entity {
        constructor(x, y, width, height, { warpTo = null } = {}) {
          super(x, y, width, height);
          this.warpTo = warpTo;
        }
      }

      const player = new Player(120, world.height - 140);
      let elapsedTime = 0;
      let running = true;
      let currentLevelIndex = 0;
      let pendingLevelTimer = null;

      function loadLevel(index, { resetStats = false, showIntro = true, respawn = false } = {}) {
        if (pendingLevelTimer) {
          clearTimeout(pendingLevelTimer);
          pendingLevelTimer = null;
        }
        const definition = levelDefinitions[index];
        if (!definition) return;
        currentLevelIndex = index;
        applyTheme(definition.theme);
        world.goalX = definition.goalX;
        world.timeLimit = definition.timeLimit;
        world.camera.x = 0;
        buildLevel(definition);

        if (resetStats) {
          player.score = 0;
          player.coins = 0;
          hudScore.textContent = "000000";
          hudCoins.textContent = "×00";
          player.setSize("small", { silent: true });
          player.extraLives = 0;
          player.ammo = 0;
          player.collectibles = 0;
          updateAmmoHUD();
        } else {
          hudScore.textContent = player.score.toString().padStart(6, "0");
          hudCoins.textContent = `×${player.coins.toString().padStart(2, "0")}`;
          if (respawn) {
            player.setSize("small", { silent: true });
          } else {
            player.updateDimensions(player.size);
          }
          updateAmmoHUD();
        }

        const start = definition.start ?? { x: 120, y: world.height - 140 };
        player.x = start.x;
        player.y = start.y;
        player.vx = 0;
        player.vy = 0;
        player.onGround = false;
        player.invincibleTimer = 0;
        player.onSkateboard = false;
        player.skateboardTimer = 0;
        elapsedTime = 0;
        running = true;
        hudWorld.textContent = definition.name ?? `1-${index + 1}`;
        hudTime.textContent = `${world.timeLimit}`.padStart(3, "0");

        // 更新关卡选择器
        const levelSelect = document.getElementById("level-select");
        if (levelSelect) {
          levelSelect.value = index.toString();
        }

        if (definition.intro && showIntro) {
          showToast(definition.intro, 1800);
        }
      }

      function resetGame({ showMessage = true, startLevel = 0 } = {}) {
        const levelIndex = clamp(startLevel, 0, levelDefinitions.length - 1);
        loadLevel(levelIndex, { resetStats: true, showIntro: !showMessage });
        if (showMessage) {
          if (levelIndex === 0) {
            showToast("Back to 1-1—research adventure rebooted!", 1600);
          } else {
            showToast(`Warped straight to ${levelDefinitions[levelIndex].name}!`, 1500);
          }
        }
      }

      function restartCurrentLevel() {
        if (currentLevelIndex < 0 || currentLevelIndex >= levelDefinitions.length) return;
        const levelName = levelDefinitions[currentLevelIndex].name;
        loadLevel(currentLevelIndex, { resetStats: false, showIntro: false, respawn: false });
        showToast(`${levelName} restarted!`, 1200);
      }

      function tryEnterPipe() {
        // 管道功能已禁用
        return false;
      }

      function enterPipe(pipe) {
        // 管道功能已禁用
        return;
      }

      function applyTheme(themeKey) {
        const themes = {
          surface: {
            sky: ["#9cd3ff", "#d4efff"],
            isUnderground: false,
            hillLight: "rgba(105, 193, 128, 0.78)",
            hillDark: "rgba(86, 175, 104, 0.8)",
            cloud: "#74aaff",
            groundTop: "#6f4c2f",
            groundBody: "#905c36",
            groundStripe: "#5a462f",
            platformTop: "#c45f24",
            platformBody: "#e17844",
          },
          underground: {
            sky: ["#1b1a2f", "#0f0d1c"],
            isUnderground: true,
            hillLight: null,
            hillDark: null,
            cloud: null,
            groundTop: "#3d3a54",
            groundBody: "#25223a",
            groundStripe: "#18152b",
            platformTop: "#5a4d82",
            platformBody: "#403765",
          },
          sky: {
            sky: ["#87b9ff", "#dbe9ff"],
            isUnderground: false,
            hillLight: "rgba(224, 244, 255, 0.8)",
            hillDark: "rgba(176, 216, 255, 0.6)",
            cloud: "#ffffff",
            groundTop: "#d5e6ff",
            groundBody: "#b0c9ff",
            groundStripe: "#94afe7",
            platformTop: "#f3f6ff",
            platformBody: "#d0ddff",
          },
          candy: {
            sky: ["#ffe6f4", "#fff8e8"],
            isUnderground: false,
            hillLight: "rgba(255, 209, 220, 0.75)",
            hillDark: "rgba(255, 182, 193, 0.75)",
            cloud: "#ffffff",
            groundTop: "#f8a5c2",
            groundBody: "#ffb8d2",
            groundStripe: "#f582a7",
            platformTop: "#ffd1dc",
            platformBody: "#ff9ec4",
          },
          ghost: {
            sky: ["#2d1b3d", "#1a0f26"],
            isUnderground: true,
            hillLight: null,
            hillDark: null,
            cloud: null,
            groundTop: "#4a3a5a",
            groundBody: "#3a2d4a",
            groundStripe: "#2a1f3a",
            platformTop: "#6b5b7b",
            platformBody: "#5a4a6a",
          },
          water: {
            sky: ["#1a4a6a", "#0d2d4a"],
            isUnderground: true,
            hillLight: null,
            hillDark: null,
            cloud: null,
            groundTop: "#2d5a7a",
            groundBody: "#1d3a5a",
            groundStripe: "#0d2a4a",
            platformTop: "#4d7a9a",
            platformBody: "#3d6a8a",
          },
          climb: {
            sky: ["#87ceeb", "#e0f6ff"],
            isUnderground: false,
            hillLight: "rgba(120, 120, 130, 0.8)",
            hillDark: "rgba(100, 100, 110, 0.8)",
            cloud: "#ffffff",
            groundTop: "#8b7355",
            groundBody: "#6b5a45",
            groundStripe: "#5a4a35",
            platformTop: "#9b8a6a",
            platformBody: "#7b6a5a",
          },
          snow: {
            sky: ["#b8d4f0", "#e8f4ff"],
            isUnderground: false,
            hillLight: "rgba(240, 240, 250, 0.9)",
            hillDark: "rgba(220, 220, 230, 0.9)",
            cloud: "#ffffff",
            groundTop: "#f0f8ff",
            groundBody: "#e0e8f0",
            groundStripe: "#d0d8e0",
            platformTop: "#ffffff",
            platformBody: "#f0f0f8",
          },
        };
        const selected = themes[themeKey] ?? themes.surface;
        activeTheme = { ...selected, key: themeKey };
        
        // 水下关卡调整重力
        if (themeKey === "water") {
          world.gravity = 600; // 水下重力更小
          world.friction = 0.86; // 恢复正常摩擦力
        } else if (themeKey === "snow") {
          world.gravity = 1600; // 正常重力
          world.friction = 0.92; // 滑雪场摩擦力更低（更滑）
        } else {
          world.gravity = 1600; // 恢复正常重力
          world.friction = 0.86; // 恢复正常摩擦力
        }
      }

      function completeLevel() {
        if (!running) return;
        running = false;
        player.addScore(400);
        const nextIndex = currentLevelIndex + 1;
        if (nextIndex < levelDefinitions.length) {
          showToast(`Flag reached! Heading to ${levelDefinitions[nextIndex].name}`, 2200);
          pendingLevelTimer = setTimeout(() => {
            pendingLevelTimer = null;
            loadLevel(nextIndex);
          }, 1200);
        } else {
          levelCelebration.spawn();
          showToast("Candy house fireworks! CNS publication secured!", 2600);
        }
      }

      function handleCollisions() {
        player.onGround = false;
        const entities = [player, ...level.entities, ...level.powerups];
        const colliders = [...level.platforms, ...level.bricks, ...level.skateboards, ...level.snowPiles, ...level.icePillars];

        entities.forEach((entity) => {
          colliders.forEach((platform) => {
            if (
              entity.right > platform.x &&
              entity.left < platform.x + platform.width &&
              entity.bottom > platform.y &&
              entity.top < platform.y + platform.height
            ) {
              const overlapX =
                entity.vx > 0
                  ? platform.x - entity.right
                  : platform.x + platform.width - entity.left;
              const overlapY =
                entity.vy > 0
                  ? platform.y - entity.bottom
                  : platform.y + platform.height - entity.top;

              const horizontalCollision = Math.abs(overlapX) < Math.abs(overlapY);
              if (horizontalCollision) {
                if (entity === player) {
                  const platformTop = platform.y;
                  const playerBottom = player.bottom;
                  const stepHeight = platformTop - playerBottom;
                  const canStep =
                    stepHeight > -26 &&
                    stepHeight <= 0 &&
                    player.vy >= -40 &&
                    playerBottom >= platformTop - 32;
                  if (canStep) {
                    player.y = platformTop - player.height;
                    player.onGround = true;
                    player.vy = 0;
                    return;
                  }
                }
                entity.x += overlapX;
                if (entity instanceof Shark) {
                  // 鲨鱼在水中遇到障碍时改变方向，但可以上下游动绕过
                  entity.directionX *= -1;
                  entity.vx = entity.directionX * entity.swimSpeedX;
                  // 有时也改变垂直方向，尝试绕过障碍
                  if (Math.random() > 0.5) {
                    entity.directionY *= -1;
                  }
                } else if (entity instanceof Monkey || entity instanceof Goomba || entity instanceof Mushroom) {
                  entity.direction *= -1;
                  entity.vx = entity.direction * entity.walkSpeed;
                } else {
                  entity.vx = 0;
                }
              } else {
                entity.y += overlapY;
                if (entity instanceof Shark) {
                  // 鲨鱼在水中遇到上下障碍时改变垂直方向
                  entity.directionY *= -1;
                  entity.vy = entity.directionY * entity.swimSpeedY;
                } else if (entity instanceof Monkey) {
                  // 猴子落地时设置onGround状态
                  entity.vy = 0;
                  entity.onGround = true;
                } else {
                  entity.vy = 0;
                }
                if (entity === player) {
                  if (overlapY < 0) {
                    player.onGround = true;
                  } else if (overlapY > 0) {
                    const brick = level.bricks.find((b) => b === platform);
                    if (brick) brick.trigger(player);
                  }
                }
              }
            }
          });
        });
      }

      function handleEntityInteractions(dt) {
        level.entities.forEach((entity) => {
          if ((entity instanceof Goomba || entity instanceof Shark || entity instanceof Monkey) && !entity.removed) {
            if (
              player.right > entity.left &&
              player.left < entity.right &&
              player.bottom > entity.top &&
              player.top < entity.bottom
            ) {
              if (player.vy > 120 && player.bottom - entity.top < 20) {
                entity.squash();
                player.bounce();
                player.addScore(100);
                let message = "Goomba squashed! +100 points!";
                if (entity instanceof Shark) {
                  message = "Shark defeated! +100 points!";
                } else if (entity instanceof Monkey) {
                  message = "Monkey defeated! +100 points!";
                }
                showToast(message, 1000);
              } else if (player.invincibleTimer === 0) {
                if (player.size === "big") {
                  player.setSize("small");
                  player.invincibleTimer = 2.2;
                  updateAmmoHUD();
                } else if (player.extraLives > 0) {
                  player.extraLives -= 1;
                  updateAmmoHUD();
                  showToast("Backup life activated—back to the lab!", 1600);
                  loadLevel(currentLevelIndex, { respawn: true, showIntro: false });
                  return;
                } else {
                  running = false;
                  showToast("Out of lives—restarting current level...", 1600);
                  setTimeout(() => loadLevel(currentLevelIndex, { respawn: true, showIntro: false }), 180);
                  return;
                }
              }
            }
          }
        });

        level.projectiles = level.projectiles.filter((fireball) => {
          if (fireball.life <= 0) return false;
          let hit = false;
          level.entities.forEach((entity) => {
            if ((entity instanceof Goomba || entity instanceof Shark || entity instanceof Monkey) && !entity.removed) {
              const marginX = 18;
              const marginY = 18;
              const xOverlap =
                fireball.right > entity.left - marginX &&
                fireball.left < entity.right + marginX;
              const yOverlap =
                fireball.bottom > entity.top - marginY &&
                fireball.top < entity.bottom + marginY;
              if (xOverlap && yOverlap) {
                entity.squash();
                entity.removed = true;
                fireball.life = 0;
                player.addScore(150);
                hit = true;
              }
            }
          });
          return fireball.life > 0 && !hit;
        });

        level.powerups.forEach((powerup) => {
          if (
            player.right > powerup.left &&
            player.left < powerup.right &&
            player.bottom > powerup.top &&
            player.top < powerup.bottom
          ) {
            powerup.removed = true;
            player.grow();
            player.addScore(1000);
            updateAmmoHUD();
          }
        });

        level.powerups = level.powerups.filter((powerup) => !powerup.removed);

        level.coins.forEach((coin) => {
          if (
            player.right > coin.left &&
            player.left < coin.right &&
            player.bottom > coin.top &&
            player.top < coin.bottom
          ) {
            coin.removed = true;
            player.addCoin();
            updateAmmoHUD();
          }
        });

        level.coins = level.coins.filter((coin) => !coin.removed);

        // 滑板收集
        level.skateboards.forEach((skateboard) => {
          if (
            player.right > skateboard.left &&
            player.left < skateboard.right &&
            player.bottom > skateboard.top &&
            player.top < skateboard.bottom
          ) {
            skateboard.removed = true;
            player.onSkateboard = true;
            player.skateboardTimer = 0;
            player.addScore(500);
            showToast("Skateboard collected! Dash through enemies!", 1600);
          }
        });

        level.skateboards = level.skateboards.filter((skateboard) => !skateboard.removed);

        // 滑板冲走敌人
        if (player.onSkateboard && Math.abs(player.vx) > 200) {
          level.entities.forEach((entity) => {
            if ((entity instanceof Goomba || entity instanceof Shark || entity instanceof Monkey) && !entity.removed) {
              const marginX = 30;
              const marginY = 20;
              const xOverlap =
                player.right > entity.left - marginX &&
                player.left < entity.right + marginX;
              const yOverlap =
                player.bottom > entity.top - marginY &&
                player.top < entity.bottom + marginY;
              if (xOverlap && yOverlap) {
                // 冲走敌人
                entity.removed = true;
                entity.squash();
                player.addScore(200);
                showToast("Skateboard dash! Enemy knocked out!", 1000);
              }
            }
          });
        }
      }

      function update(dt) {
        if (!running) return;

        elapsedTime += dt;
        const timeRemaining = Math.max(0, Math.floor(world.timeLimit - elapsedTime));
        hudTime.textContent = timeRemaining.toString().padStart(3, "0");
        if (timeRemaining === 0) {
          if (player.extraLives > 0) {
            player.extraLives -= 1;
            updateAmmoHUD();
            showToast("Backup life triggered—timer reset!", 1600);
            loadLevel(currentLevelIndex, { respawn: true, showIntro: false });
            return;
          }
          running = false;
          showToast("Time's up—restarting current level...", 1600);
          setTimeout(() => loadLevel(currentLevelIndex, { respawn: true, showIntro: false }), 180);
          return;
        }

        player.update(dt);
        level.entities.forEach((entity) => entity.update(dt));
        level.bricks.forEach((brick) => brick.update(dt));
        level.coins.forEach((coin) => coin.update(dt));
        level.powerups.forEach((powerup) => powerup.update(dt));
        level.projectiles.forEach((projectile) => projectile.update(dt));
        level.skateboards.forEach((skateboard) => skateboard.update(dt));
        if (level.flag) {
          level.flag.update(dt);
        }

        handleCollisions();
        handleEntityInteractions(dt);
        level.entities = level.entities.filter((entity) => !entity.removed);
        level.projectiles = level.projectiles.filter(
          (projectile) =>
            projectile.life > 0 &&
            projectile.x > -100 &&
            projectile.x < world.goalX + 200,
        );

        world.camera.x = clamp(
          player.x - canvas.width / 2,
          0,
          world.goalX - canvas.width + 200,
        );

        if (player.x >= world.goalX - 40) {
          completeLevel();
        }

        if (player.y > world.height + 160) {
          if (player.extraLives > 0) {
          player.extraLives -= 1;
          updateAmmoHUD();
          showToast("Backup life to the rescue—watch your footing!", 1600);
            loadLevel(currentLevelIndex, { respawn: true, showIntro: false });
            return;
          }
          running = false;
          showToast("Fell into the abyss—restarting current level...", 1600);
          setTimeout(() => loadLevel(currentLevelIndex, { respawn: true, showIntro: false }), 180);
          return;
        }
      }

      function drawBackground() {
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, activeTheme.sky[0]);
        gradient.addColorStop(1, activeTheme.sky[1]);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const cameraX = world.camera.x;
        if (!activeTheme.isUnderground) {
          const drawHill = (x, y, radius, color) => {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x - cameraX, y, radius, Math.PI, Math.PI * 2);
            ctx.fill();
          };

          drawHill(280, world.height - 64, 180, activeTheme.hillDark);
          drawHill(900, world.height - 64, 220, activeTheme.hillLight);
          drawHill(1300, world.height - 64, 160, "rgba(72, 160, 90, 0.78)");
          drawHill(2200, world.height - 64, 240, activeTheme.hillDark);
          drawHill(2800, world.height - 64, 180, activeTheme.hillLight);

          if (activeTheme.key === "candy") {
            const candyPositions = [
              { x: 400, y: world.height - 120, radius: 60, color: "#ff9ec4" },
              { x: 980, y: world.height - 140, radius: 48, color: "#ffd166" },
              { x: 1680, y: world.height - 150, radius: 54, color: "#a29bfe" },
              { x: 2280, y: world.height - 130, radius: 66, color: "#ff92a5" },
            ];
            candyPositions.forEach((candy, index) => {
              const cx = candy.x - cameraX;
              const cy = candy.y;
              ctx.save();
              ctx.translate(cx, cy);
              ctx.fillStyle = "#f7d6ff";
              ctx.fillRect(-8, -candy.radius * 1.6, 16, candy.radius * 1.6);
              ctx.lineWidth = 4;
              ctx.strokeStyle = index % 2 === 0 ? "#ff6f91" : "#ffa26b";
              ctx.beginPath();
              ctx.moveTo(-8, -candy.radius * 1.6);
              ctx.lineTo(8, -candy.radius * 1.2);
              ctx.moveTo(-8, -candy.radius * 1.2);
              ctx.lineTo(8, -candy.radius * 0.8);
              ctx.moveTo(-8, -candy.radius * 0.8);
              ctx.lineTo(8, -candy.radius * 0.4);
              ctx.stroke();
              ctx.fillStyle = candy.color;
              ctx.beginPath();
              ctx.arc(0, -candy.radius * 1.7, candy.radius, 0, Math.PI * 2);
              ctx.fill();
              ctx.strokeStyle = "rgba(255,255,255,0.8)";
              ctx.lineWidth = 3;
              for (let i = 0; i < 6; i++) {
                const angle = (Math.PI * 2 * i) / 6;
                ctx.beginPath();
                ctx.moveTo(
                  Math.cos(angle) * candy.radius * 0.3,
                  -candy.radius * 1.7 + Math.sin(angle) * candy.radius * 0.3,
                );
                ctx.lineTo(
                  Math.cos(angle) * candy.radius * 0.8,
                  -candy.radius * 1.7 + Math.sin(angle) * candy.radius * 0.8,
                );
                ctx.stroke();
              }
              ctx.restore();
            });
          }

          if (activeTheme.key === "climb") {
            // 攀岩主题：绘制高耸的山峰
            const mountainPeaks = [
              { x: 200, height: 180, width: 300 },
              { x: 800, height: 220, width: 350 },
              { x: 1500, height: 200, width: 320 },
              { x: 2400, height: 240, width: 380 },
              { x: 3200, height: 190, width: 310 },
            ];
            mountainPeaks.forEach((peak) => {
              const mx = peak.x - cameraX;
              if (mx + peak.width > -100 && mx < canvas.width + 100) {
                ctx.save();
                // 山峰主体
                ctx.fillStyle = "rgba(100, 100, 110, 0.7)";
                ctx.beginPath();
                ctx.moveTo(mx, world.height - 64);
                ctx.lineTo(mx + peak.width / 2, world.height - 64 - peak.height);
                ctx.lineTo(mx + peak.width, world.height - 64);
                ctx.closePath();
                ctx.fill();
                // 山峰阴影
                ctx.fillStyle = "rgba(80, 80, 90, 0.5)";
                ctx.beginPath();
                ctx.moveTo(mx + peak.width / 2, world.height - 64 - peak.height);
                ctx.lineTo(mx + peak.width, world.height - 64);
                ctx.lineTo(mx + peak.width * 0.7, world.height - 64 - peak.height * 0.3);
                ctx.closePath();
                ctx.fill();
                // 雪顶
                ctx.fillStyle = "rgba(240, 240, 250, 0.9)";
                ctx.beginPath();
                ctx.moveTo(mx + peak.width / 2 - 20, world.height - 64 - peak.height);
                ctx.lineTo(mx + peak.width / 2, world.height - 64 - peak.height - 15);
                ctx.lineTo(mx + peak.width / 2 + 20, world.height - 64 - peak.height);
                ctx.closePath();
                ctx.fill();
                // 岩石纹理
                ctx.strokeStyle = "rgba(70, 70, 80, 0.4)";
                ctx.lineWidth = 2;
                for (let i = 0; i < 3; i++) {
                  const rockY = world.height - 64 - (peak.height / 4) * (i + 1);
                  ctx.beginPath();
                  ctx.moveTo(mx + peak.width * 0.2 + i * 20, rockY);
                  ctx.lineTo(mx + peak.width * 0.8 - i * 20, rockY);
                  ctx.stroke();
                }
                ctx.restore();
              }
            });
            
            // 攀岩点/抓手点
            const climbingHolds = [
              { x: 450, y: H - 240 },
              { x: 750, y: H - 300 },
              { x: 1050, y: H - 280 },
              { x: 1450, y: H - 320 },
              { x: 1850, y: H - 300 },
              { x: 2250, y: H - 340 },
              { x: 2650, y: H - 320 },
              { x: 3050, y: H - 360 },
              { x: 3450, y: H - 340 },
              { x: 3850, y: H - 360 },
            ];
            climbingHolds.forEach((hold) => {
              const hx = hold.x - cameraX;
              if (hx > -30 && hx < canvas.width + 30) {
                ctx.save();
                ctx.fillStyle = "rgba(150, 150, 160, 0.8)";
                ctx.strokeStyle = "rgba(120, 120, 130, 0.9)";
                ctx.lineWidth = 2;
                // 攀岩点主体
                ctx.beginPath();
                ctx.arc(hx, hold.y, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                // 高光
                ctx.fillStyle = "rgba(200, 200, 210, 0.6)";
                ctx.beginPath();
                ctx.arc(hx - 3, hold.y - 3, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
              }
            });
            
            // 云朵（在较低位置）
            if (activeTheme.cloud) {
              ctx.fillStyle = activeTheme.cloud;
              for (let i = 0; i < 12; i++) {
                const x = (cameraX / 3 + i * 220) % (canvas.width + 220) - 220;
                const y = 200 + Math.sin((Date.now() / 2500 + i) % Math.PI) * 15;
                ctx.beginPath();
                ctx.ellipse(x + 120, y, 100, 35, 0, 0, Math.PI * 2);
                ctx.fill();
              }
            }
          } else if (activeTheme.key === "snow") {
            // 滑雪场主题：绘制雪景
            // 雪山背景
            const snowMountains = [
              { x: 100, height: 150, width: 280 },
              { x: 600, height: 180, width: 320 },
              { x: 1200, height: 160, width: 300 },
              { x: 2000, height: 190, width: 340 },
              { x: 2800, height: 170, width: 310 },
              { x: 3600, height: 200, width: 330 },
            ];
            snowMountains.forEach((mountain) => {
              const mx = mountain.x - cameraX;
              if (mx + mountain.width > -100 && mx < canvas.width + 100) {
                ctx.save();
                // 雪山主体
                ctx.fillStyle = "rgba(240, 240, 250, 0.8)";
                ctx.beginPath();
                ctx.moveTo(mx, world.height - 64);
                ctx.lineTo(mx + mountain.width / 2, world.height - 64 - mountain.height);
                ctx.lineTo(mx + mountain.width, world.height - 64);
                ctx.closePath();
                ctx.fill();
                // 雪顶高光
                ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
                ctx.beginPath();
                ctx.moveTo(mx + mountain.width / 2 - 15, world.height - 64 - mountain.height);
                ctx.lineTo(mx + mountain.width / 2, world.height - 64 - mountain.height - 10);
                ctx.lineTo(mx + mountain.width / 2 + 15, world.height - 64 - mountain.height);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
              }
            });
            
            // 雪人
            const snowmanPositions = [
              { x: 500, y: world.height - 120 },
              { x: 1500, y: world.height - 115 },
              { x: 3000, y: world.height - 125 },
            ];
            snowmanPositions.forEach((snowman) => {
              const sx = snowman.x - cameraX;
              if (sx > -80 && sx < canvas.width + 80) {
                ctx.save();
                ctx.translate(sx, snowman.y);
                // 雪人身体（下）
                ctx.fillStyle = "#ffffff";
                ctx.beginPath();
                ctx.arc(0, 0, 25, 0, Math.PI * 2);
                ctx.fill();
                // 雪人身体（中）
                ctx.beginPath();
                ctx.arc(0, -30, 20, 0, Math.PI * 2);
                ctx.fill();
                // 雪人头部
                ctx.beginPath();
                ctx.arc(0, -55, 15, 0, Math.PI * 2);
                ctx.fill();
                // 雪人眼睛
                ctx.fillStyle = "#1a0f26";
                ctx.beginPath();
                ctx.arc(-5, -58, 2, 0, Math.PI * 2);
                ctx.arc(5, -58, 2, 0, Math.PI * 2);
                ctx.fill();
                // 雪人鼻子（胡萝卜）
                ctx.fillStyle = "#ff8c00";
                ctx.beginPath();
                ctx.moveTo(0, -55);
                ctx.lineTo(8, -52);
                ctx.lineTo(0, -50);
                ctx.closePath();
                ctx.fill();
                // 雪人帽子
                ctx.fillStyle = "#8b4513";
                ctx.fillRect(-12, -70, 24, 8);
                ctx.fillRect(-8, -75, 16, 5);
                ctx.restore();
              }
            });
            
            // 雪花飘落效果
            const snowflakeCount = 30;
            for (let i = 0; i < snowflakeCount; i++) {
              const snowX = (cameraX * 0.1 + i * 150) % (canvas.width + 150) - 150;
              const snowY = (Date.now() / 20 + i * 50) % (canvas.height + 100) - 100;
              const snowSize = 2 + Math.sin((Date.now() / 1000 + i) % (Math.PI * 2)) * 1;
              
              ctx.save();
              ctx.globalAlpha = 0.8;
              ctx.fillStyle = "#ffffff";
              ctx.beginPath();
              ctx.arc(snowX, snowY, snowSize, 0, Math.PI * 2);
              ctx.fill();
              ctx.restore();
            }
            
            // 云朵
            if (activeTheme.cloud) {
              ctx.fillStyle = activeTheme.cloud;
              for (let i = 0; i < 14; i++) {
                const x = (cameraX / 4 + i * 200) % (canvas.width + 200) - 200;
                const y = 100 + Math.sin((Date.now() / 3000 + i) % Math.PI) * 10;
                ctx.beginPath();
                ctx.ellipse(x + 100, y, 110, 38, 0, 0, Math.PI * 2);
                ctx.fill();
              }
            }
          } else if (activeTheme.cloud) {
            ctx.fillStyle = activeTheme.cloud;
            for (let i = 0; i < 16; i++) {
              const x = (cameraX / 4 + i * 180) % (canvas.width + 180) - 180;
              ctx.beginPath();
              ctx.ellipse(
                x + 100,
                120 + Math.sin((Date.now() / 2000 + i) % Math.PI) * 12,
                120,
                40,
                0,
                0,
                Math.PI * 2,
              );
              ctx.fill();
            }
          }
        } else {
          if (activeTheme.key === "ghost") {
            ctx.fillStyle = "rgba(60, 40, 80, 0.7)";
            for (let i = 0; i < 8; i++) {
              const x = (cameraX / 5 + i * 200) % (canvas.width + 200) - 200;
              ctx.fillRect(x + 30, canvas.height - 240, 180, 220);
            }
            ctx.strokeStyle = "rgba(150, 100, 180, 0.12)";
            for (let y = 60; y < canvas.height; y += 50) {
              ctx.beginPath();
              ctx.moveTo(0, y);
              ctx.lineTo(canvas.width, y);
              ctx.stroke();
            }
            ctx.strokeStyle = "rgba(150, 100, 180, 0.08)";
            for (let x = 0; x < canvas.width; x += 70) {
              ctx.beginPath();
              ctx.moveTo(x, 0);
              ctx.lineTo(x, canvas.height);
              ctx.stroke();
            }
            
            // 万圣节月亮
            const moonX = canvas.width - 120 - cameraX * 0.1;
            const moonY = 80;
            ctx.fillStyle = "rgba(255, 240, 200, 0.4)";
            ctx.beginPath();
            ctx.arc(moonX, moonY, 45, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "rgba(255, 220, 150, 0.3)";
            ctx.beginPath();
            ctx.arc(moonX - 15, moonY - 10, 35, 0, Math.PI * 2);
            ctx.fill();
            
            // 蝙蝠
            for (let i = 0; i < 6; i++) {
              const batX = (cameraX * 0.3 + i * 350) % (canvas.width + 350) - 350;
              const batY = 100 + Math.sin((Date.now() / 800 + i) % (Math.PI * 2)) * 25;
              ctx.save();
              ctx.translate(batX, batY);
              ctx.fillStyle = "rgba(20, 20, 30, 0.8)";
              // 蝙蝠身体
              ctx.beginPath();
              ctx.ellipse(0, 0, 8, 12, 0, 0, Math.PI * 2);
              ctx.fill();
              // 蝙蝠翅膀
              ctx.beginPath();
              ctx.ellipse(-12, -4, 10, 6, -0.3, 0, Math.PI * 2);
              ctx.ellipse(12, -4, 10, 6, 0.3, 0, Math.PI * 2);
              ctx.fill();
              ctx.restore();
            }
            
            // 墓碑
            const tombstonePositions = [
              { x: 500, y: world.height - 120 },
              { x: 1200, y: world.height - 110 },
              { x: 2100, y: world.height - 125 },
              { x: 3000, y: world.height - 115 },
            ];
            tombstonePositions.forEach((tomb) => {
              const tx = tomb.x - cameraX;
              if (tx > -100 && tx < canvas.width + 100) {
                ctx.fillStyle = "rgba(120, 120, 130, 0.7)";
                // 墓碑顶部（弧形）
                ctx.beginPath();
                ctx.arc(tx, tomb.y - 25, 20, Math.PI, 0, false);
                ctx.fill();
                // 墓碑主体
                ctx.fillRect(tx - 20, tomb.y - 25, 40, 50);
                // 十字架
                ctx.fillStyle = "rgba(80, 80, 90, 0.8)";
                ctx.fillRect(tx - 2, tomb.y - 35, 4, 15);
                ctx.fillRect(tx - 6, tomb.y - 30, 12, 4);
                // RIP文字
                ctx.fillStyle = "rgba(40, 40, 50, 0.9)";
                ctx.font = "bold 10px Nunito";
                ctx.textAlign = "center";
                ctx.fillText("RIP", tx, tomb.y - 5);
              }
            });
            
            // 南瓜灯
            const pumpkinPositions = [
              { x: 800, y: world.height - 100 },
              { x: 1600, y: world.height - 95 },
              { x: 2500, y: world.height - 105 },
              { x: 3400, y: world.height - 100 },
            ];
            pumpkinPositions.forEach((pumpkin) => {
              const px = pumpkin.x - cameraX;
              if (px > -80 && px < canvas.width + 80) {
                ctx.save();
                ctx.translate(px, pumpkin.y);
                // 南瓜主体
                ctx.fillStyle = "#ff8c00";
                ctx.beginPath();
                ctx.ellipse(0, 0, 30, 35, 0, 0, Math.PI * 2);
                ctx.fill();
                // 南瓜条纹
                ctx.strokeStyle = "#ff6b00";
                ctx.lineWidth = 3;
                for (let i = -1; i <= 1; i++) {
                  ctx.beginPath();
                  ctx.moveTo(i * 10, -35);
                  ctx.lineTo(i * 10, 35);
                  ctx.stroke();
                }
                // 南瓜眼睛
                ctx.fillStyle = "#1a0f26";
                ctx.beginPath();
                ctx.arc(-10, -8, 6, 0, Math.PI * 2);
                ctx.arc(10, -8, 6, 0, Math.PI * 2);
                ctx.fill();
                // 南瓜嘴巴
                ctx.beginPath();
                ctx.arc(0, 8, 12, 0, Math.PI, false);
                ctx.fill();
                // 南瓜牙齿
                ctx.fillStyle = "#ff8c00";
                ctx.fillRect(-3, 8, 6, 4);
                // 南瓜茎
                ctx.fillStyle = "#2d5016";
                ctx.fillRect(-4, -38, 8, 8);
                ctx.restore();
              }
            });
            
            // 蜘蛛网
            const webPositions = [
              { x: 600, y: 150 },
              { x: 1800, y: 140 },
              { x: 2700, y: 160 },
            ];
            webPositions.forEach((web) => {
              const wx = web.x - cameraX;
              if (wx > -100 && wx < canvas.width + 100) {
                ctx.save();
                ctx.translate(wx, web.y);
                ctx.strokeStyle = "rgba(200, 200, 220, 0.4)";
                ctx.lineWidth = 1.5;
                // 蜘蛛网辐射线
                for (let i = 0; i < 8; i++) {
                  const angle = (Math.PI * 2 * i) / 8;
                  ctx.beginPath();
                  ctx.moveTo(0, 0);
                  ctx.lineTo(Math.cos(angle) * 40, Math.sin(angle) * 40);
                  ctx.stroke();
                }
                // 蜘蛛网螺旋
                for (let r = 8; r <= 40; r += 8) {
                  ctx.beginPath();
                  ctx.arc(0, 0, r, 0, Math.PI * 2);
                  ctx.stroke();
                }
                ctx.restore();
              }
            });
            
            // 飘浮的幽灵（背景）
            ctx.fillStyle = "rgba(200, 150, 220, 0.15)";
            for (let i = 0; i < 4; i++) {
              const ghostX = (cameraX / 3 + i * 400) % (canvas.width + 400) - 400;
              const ghostY = 120 + Math.sin((Date.now() / 1500 + i * 0.8) % (Math.PI * 2)) * 30;
              ctx.beginPath();
              ctx.arc(ghostX + 200, ghostY, 18, Math.PI, 0, false);
              ctx.lineTo(ghostX + 200 - 18, ghostY + 20);
              ctx.quadraticCurveTo(ghostX + 200 - 12, ghostY + 15, ghostX + 200 - 6, ghostY + 18);
              ctx.quadraticCurveTo(ghostX + 200, ghostY + 15, ghostX + 200 + 6, ghostY + 18);
              ctx.quadraticCurveTo(ghostX + 200 + 12, ghostY + 15, ghostX + 200 + 18, ghostY + 20);
              ctx.closePath();
              ctx.fill();
              // 眼睛
              ctx.fillStyle = "rgba(40, 20, 60, 0.6)";
              ctx.beginPath();
              ctx.arc(ghostX + 200 - 6, ghostY - 2, 3, 0, Math.PI * 2);
              ctx.arc(ghostX + 200 + 6, ghostY - 2, 3, 0, Math.PI * 2);
              ctx.fill();
              ctx.fillStyle = "rgba(200, 150, 220, 0.15)";
            }
          } else if (activeTheme.key === "water") {
            // 水下场景背景
            ctx.fillStyle = "rgba(30, 60, 90, 0.5)";
            for (let i = 0; i < 10; i++) {
              const x = (cameraX / 4 + i * 150) % (canvas.width + 150) - 150;
              ctx.fillRect(x + 20, canvas.height - 250, 130, 250);
            }
            
            // 水波纹效果
            ctx.strokeStyle = "rgba(100, 180, 255, 0.2)";
            ctx.lineWidth = 2;
            for (let y = 50; y < canvas.height; y += 80) {
              const waveOffset = Math.sin((Date.now() / 1000 + y * 0.01) % (Math.PI * 2)) * 15;
              ctx.beginPath();
              for (let x = 0; x < canvas.width; x += 5) {
                const waveY = y + Math.sin((x + cameraX) * 0.02 + Date.now() / 800) * 8 + waveOffset;
                if (x === 0) {
                  ctx.moveTo(x, waveY);
                } else {
                  ctx.lineTo(x, waveY);
                }
              }
              ctx.stroke();
            }
            
            // 气泡效果
            const bubbleCount = 15;
            for (let i = 0; i < bubbleCount; i++) {
              const bubbleX = (cameraX * 0.2 + i * 200) % (canvas.width + 200) - 200;
              const bubbleY = canvas.height - 100 - (Date.now() / 50 + i * 100) % (canvas.height - 200);
              const bubbleSize = 4 + Math.sin((Date.now() / 500 + i) % (Math.PI * 2)) * 2;
              
              ctx.save();
              ctx.globalAlpha = 0.4;
              ctx.fillStyle = "rgba(200, 240, 255, 0.6)";
              ctx.strokeStyle = "rgba(150, 220, 255, 0.8)";
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
              ctx.fill();
              ctx.stroke();
              // 气泡高光
              ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
              ctx.beginPath();
              ctx.arc(bubbleX - bubbleSize * 0.3, bubbleY - bubbleSize * 0.3, bubbleSize * 0.3, 0, Math.PI * 2);
              ctx.fill();
              ctx.restore();
            }
            
            // 水草/海草
            const seaweedPositions = [
              { x: 300, height: 80 },
              { x: 900, height: 100 },
              { x: 1500, height: 70 },
              { x: 2100, height: 90 },
              { x: 2700, height: 85 },
              { x: 3300, height: 95 },
            ];
            seaweedPositions.forEach((seaweed) => {
              const sx = seaweed.x - cameraX;
              if (sx > -50 && sx < canvas.width + 50) {
                ctx.save();
                ctx.strokeStyle = "rgba(50, 150, 80, 0.6)";
                ctx.lineWidth = 4;
                ctx.lineCap = "round";
                const sway = Math.sin((Date.now() / 1200 + seaweed.x * 0.01) % (Math.PI * 2)) * 12;
                ctx.beginPath();
                ctx.moveTo(sx, world.height - 64);
                for (let i = 0; i < 8; i++) {
                  const segmentY = world.height - 64 - (seaweed.height / 8) * i;
                  const segmentX = sx + sway * (i / 8);
                  ctx.lineTo(segmentX, segmentY);
                }
                ctx.stroke();
                // 海草叶子
                ctx.fillStyle = "rgba(40, 130, 70, 0.7)";
                for (let i = 2; i < 7; i++) {
                  const leafY = world.height - 64 - (seaweed.height / 8) * i;
                  const leafX = sx + sway * (i / 8);
                  ctx.beginPath();
                  ctx.ellipse(leafX + (i % 2 === 0 ? 8 : -8), leafY, 6, 12, (i % 2 === 0 ? 0.3 : -0.3), 0, Math.PI * 2);
                  ctx.fill();
                }
                ctx.restore();
              }
            });
            
            // 鱼类
            for (let i = 0; i < 5; i++) {
              const fishX = (cameraX * 0.5 + i * 500) % (canvas.width + 500) - 500;
              const fishY = 150 + Math.sin((Date.now() / 2000 + i) % (Math.PI * 2)) * 50;
              const fishDirection = i % 2 === 0 ? 1 : -1;
              
              ctx.save();
              ctx.translate(fishX, fishY);
              ctx.scale(fishDirection, 1);
              // 鱼身体
              ctx.fillStyle = "rgba(255, 150, 50, 0.7)";
              ctx.beginPath();
              ctx.ellipse(0, 0, 20, 12, 0, 0, Math.PI * 2);
              ctx.fill();
              // 鱼尾
              ctx.beginPath();
              ctx.moveTo(-20, 0);
              ctx.lineTo(-30, -8);
              ctx.lineTo(-25, 0);
              ctx.lineTo(-30, 8);
              ctx.closePath();
              ctx.fill();
              // 鱼眼睛
              ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
              ctx.beginPath();
              ctx.arc(8, -4, 4, 0, Math.PI * 2);
              ctx.fill();
              ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
              ctx.beginPath();
              ctx.arc(9, -4, 2, 0, Math.PI * 2);
              ctx.fill();
              ctx.restore();
            }
            
            // 水下光线效果
            ctx.fillStyle = "rgba(100, 200, 255, 0.1)";
            for (let i = 0; i < 3; i++) {
              const lightX = (cameraX * 0.1 + i * 400) % (canvas.width + 400) - 400;
              ctx.beginPath();
              ctx.moveTo(lightX + 200, 0);
              ctx.lineTo(lightX + 180, canvas.height);
              ctx.lineTo(lightX + 220, canvas.height);
              ctx.closePath();
              ctx.fill();
            }
          } else {
            ctx.fillStyle = "rgba(40, 36, 66, 0.6)";
            for (let i = 0; i < 6; i++) {
              const x = (cameraX / 6 + i * 240) % (canvas.width + 240) - 240;
              ctx.fillRect(x + 40, canvas.height - 220, 200, 200);
            }
            ctx.strokeStyle = "rgba(120, 120, 200, 0.08)";
            for (let y = 80; y < canvas.height; y += 60) {
              ctx.beginPath();
              ctx.moveTo(0, y);
              ctx.lineTo(canvas.width, y);
              ctx.stroke();
            }
            ctx.strokeStyle = "rgba(120, 120, 200, 0.05)";
            for (let x = 0; x < canvas.width; x += 80) {
              ctx.beginPath();
              ctx.moveTo(x, 0);
              ctx.lineTo(x, canvas.height);
              ctx.stroke();
            }
          }
        }
      }

      function drawGround() {
        const tileSize = 64;
        const start = Math.floor(world.camera.x / tileSize);
        const end = start + Math.ceil(canvas.width / tileSize) + 2;
        for (let i = start; i < end; i++) {
          const x = i * tileSize - world.camera.x;
          ctx.fillStyle = activeTheme.groundBody;
          ctx.fillRect(x, world.height - tileSize, tileSize, tileSize);
          ctx.fillStyle = activeTheme.groundTop;
          ctx.fillRect(x, world.height - tileSize, tileSize, tileSize / 3);
          ctx.fillStyle = activeTheme.groundStripe;
          for (let j = 0; j < 3; j++) {
            ctx.fillRect(
              x,
              world.height - tileSize + tileSize / 3 + (tileSize / 3) * j,
              tileSize,
              4,
            );
          }
        }
      }

      function drawPlatforms() {
        const bodyColor = activeTheme.platformBody;
        const topColor = activeTheme.platformTop;
        level.platforms.forEach((platform) => {
          const x = platform.x - world.camera.x;
          if (x + platform.width < -64 || x > canvas.width + 64) return;
          ctx.fillStyle = bodyColor;
          ctx.fillRect(x, platform.y, platform.width, platform.height);
          ctx.fillStyle = topColor;
          ctx.fillRect(x, platform.y, platform.width, 8);
        });
      }

      function drawPipes() {
        level.pipes.forEach((pipe) => {
          const x = pipe.x - world.camera.x;
          if (x + pipe.width < -64 || x > canvas.width + 64) return;
          const isCandy = activeTheme.key === "candy";
          const isGhost = activeTheme.key === "ghost";
          const isWater = activeTheme.key === "water";
          const isClimb = activeTheme.key === "climb";
          const isSnow = activeTheme.key === "snow";
          const bodyColor = isWater
            ? "#3d6a8a"
            : isGhost
            ? "#6b5b7b"
            : isClimb
            ? "#7b6a5a"
            : isSnow
            ? "#d0d8e0"
            : activeTheme.isUnderground
            ? "#4f6ed8"
            : isCandy
            ? "#ff80ab"
            : "#2dac4a";
          const topColor = isWater
            ? "#5d8aaa"
            : isGhost
            ? "#8b7b9b"
            : isClimb
            ? "#9b8a6a"
            : isSnow
            ? "#f0f0f8"
            : activeTheme.isUnderground
            ? "#6f8df0"
            : isCandy
            ? "#ffc2d7"
            : "#4ed76d";
          ctx.fillStyle = bodyColor;
          ctx.fillRect(x, pipe.y + 18, pipe.width, pipe.height - 18);
          ctx.fillStyle = topColor;
          ctx.fillRect(x - 6, pipe.y, pipe.width + 12, 18);
          ctx.fillStyle = "rgba(255,255,255,0.2)";
          ctx.fillRect(x + pipe.width * 0.2, pipe.y + 24, 6, pipe.height - 40);
        });
      }

      function drawBricks() {
        level.bricks.forEach((brick) => {
          const x = brick.x - world.camera.x;
          if (x + brick.width < -64 || x > canvas.width + 64) return;
          const bumpOffset = brick.bump > 0 ? Math.sin(brick.bump * Math.PI) * 8 : 0;
          const y = brick.y - bumpOffset;
          if (brick.kind === "empty") {
            ctx.fillStyle = "#b0b0b0";
            ctx.fillRect(x, y, brick.width, brick.height);
            ctx.strokeStyle = "#8f8f8f";
            ctx.strokeRect(x, y, brick.width, brick.height);
            return;
          }
          ctx.fillStyle = brick.kind === "question" ? "#ffac33" : "#c86428";
          ctx.fillRect(x, y, brick.width, brick.height);
          ctx.strokeStyle = brick.kind === "question" ? "#d78217" : "#9c4214";
          ctx.lineWidth = 4;
          ctx.strokeRect(x + 2, y + 2, brick.width - 4, brick.height - 4);
          if (brick.kind === "question") {
            ctx.fillStyle = "#fff5d6";
            ctx.font = "bold 32px Nunito";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("?", x + brick.width / 2, y + brick.height / 2);
          } else if (brick.kind === "solid") {
            ctx.strokeStyle = "#e28a4b";
            for (let i = 1; i < 3; i++) {
              ctx.beginPath();
              ctx.moveTo(x + (brick.width / 3) * i, y + 6);
              ctx.lineTo(x + (brick.width / 3) * i, y + brick.height - 6);
              ctx.stroke();
            }
            ctx.beginPath();
            ctx.moveTo(x + 6, y + brick.height / 2);
            ctx.lineTo(x + brick.width - 6, y + brick.height / 2);
            ctx.stroke();
          }
        });
      }

      function drawCoins() {
        level.coins.forEach((coin) => {
          const x = coin.x - world.camera.x + coin.width / 2;
          const y = coin.y + coin.height / 2;
          const texture = coin.texture;
          const pulse = 1 + Math.sin(coin.timer * 2) * 0.06;
          const size = 42 * pulse;
          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(Math.sin(coin.spin) * 0.2);
          if (texture && texture.complete) {
            ctx.drawImage(texture, -size / 2, -size / 2, size, size);
          } else {
            ctx.beginPath();
            ctx.ellipse(0, 0, size / 2.2, size / 1.8, 0, 0, Math.PI * 2);
            ctx.fillStyle = "#ffd447";
            ctx.fill();
            ctx.strokeStyle = "#e3b12d";
            ctx.lineWidth = 4;
            ctx.stroke();
          }
          ctx.restore();
        });
      }

      function drawMushrooms() {
        level.powerups.forEach((mushroom) => {
          const x = mushroom.x - world.camera.x + mushroom.width / 2;
          const y = mushroom.y + mushroom.height / 2;
          ctx.save();
          ctx.translate(x, y);
          ctx.beginPath();
          ctx.fillStyle = "#ff6b6b";
          ctx.arc(0, -6, 18, Math.PI, 0);
          ctx.fill();
          ctx.fillStyle = "#ffe0b2";
          ctx.fillRect(-18, -6, 36, 22);
          ctx.fillStyle = "#ffffff";
          ctx.beginPath();
          ctx.arc(-10, -2, 6, 0, Math.PI * 2);
          ctx.arc(10, -2, 6, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#8d5524";
          ctx.fillRect(-12, 4, 24, 12);
          ctx.restore();
        });
      }

      function drawSkateboards() {
        level.skateboards.forEach((skateboard) => {
          const x = skateboard.x - world.camera.x;
          if (x + skateboard.width < -64 || x > canvas.width + 64) return;
          ctx.save();
          ctx.translate(x + skateboard.width / 2, skateboard.y + skateboard.height / 2);
          ctx.rotate(skateboard.rotation);
          // 滑板板面
          ctx.fillStyle = "#8b4513";
          ctx.fillRect(-25, -6, 50, 12);
          // 滑板轮子
          ctx.fillStyle = "#2c2c2c";
          ctx.beginPath();
          ctx.arc(-18, 0, 5, 0, Math.PI * 2);
          ctx.arc(-6, 0, 5, 0, Math.PI * 2);
          ctx.arc(6, 0, 5, 0, Math.PI * 2);
          ctx.arc(18, 0, 5, 0, Math.PI * 2);
          ctx.fill();
          // 轮子高光
          ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
          ctx.beginPath();
          ctx.arc(-18, -2, 2, 0, Math.PI * 2);
          ctx.arc(-6, -2, 2, 0, Math.PI * 2);
          ctx.arc(6, -2, 2, 0, Math.PI * 2);
          ctx.arc(18, -2, 2, 0, Math.PI * 2);
          ctx.fill();
          // 滑板装饰
          ctx.strokeStyle = "#654321";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(-20, 0);
          ctx.lineTo(20, 0);
          ctx.stroke();
          ctx.restore();
        });
      }

      function drawSnowPiles() {
        level.snowPiles.forEach((pile) => {
          const x = pile.x - world.camera.x;
          if (x + pile.width < -64 || x > canvas.width + 64) return;
          ctx.save();
          // 雪堆主体（椭圆形）
          ctx.fillStyle = "#ffffff";
          ctx.beginPath();
          ctx.ellipse(x + pile.width / 2, pile.y + pile.height / 2, pile.width / 2, pile.height / 2, 0, 0, Math.PI * 2);
          ctx.fill();
          // 雪堆高光
          ctx.fillStyle = "rgba(240, 248, 255, 0.8)";
          ctx.beginPath();
          ctx.ellipse(x + pile.width / 2 - 8, pile.y + pile.height / 2 - 8, pile.width / 3, pile.height / 3, 0, 0, Math.PI * 2);
          ctx.fill();
          // 雪堆阴影
          ctx.fillStyle = "rgba(200, 220, 240, 0.4)";
          ctx.beginPath();
          ctx.ellipse(x + pile.width / 2 + 5, pile.y + pile.height / 2 + 5, pile.width / 2.5, pile.height / 2.5, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        });
      }

      function drawIcePillars() {
        level.icePillars.forEach((pillar) => {
          const x = pillar.x - world.camera.x;
          if (x + pillar.width < -64 || x > canvas.width + 64) return;
          ctx.save();
          // 冰柱主体
          ctx.fillStyle = "rgba(200, 240, 255, 0.7)";
          ctx.fillRect(x, pillar.y, pillar.width, pillar.height);
          // 冰柱高光
          ctx.fillStyle = "rgba(240, 250, 255, 0.9)";
          ctx.fillRect(x + 4, pillar.y + 4, pillar.width - 8, 12);
          // 冰柱纹理
          ctx.strokeStyle = "rgba(150, 220, 255, 0.5)";
          ctx.lineWidth = 2;
          for (let i = 0; i < 4; i++) {
            const y = pillar.y + 20 + i * 15;
            ctx.beginPath();
            ctx.moveTo(x + 6, y);
            ctx.lineTo(x + pillar.width - 6, y);
            ctx.stroke();
          }
          // 冰柱顶部
          ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
          ctx.beginPath();
          ctx.moveTo(x, pillar.y);
          ctx.lineTo(x + pillar.width / 2, pillar.y - 8);
          ctx.lineTo(x + pillar.width, pillar.y);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        });
      }

      function drawFireballs() {
        level.projectiles.forEach((projectile) => {
          const x = projectile.x - world.camera.x + projectile.width / 2;
          const y = projectile.y + projectile.height / 2;
          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(projectile.rotation);
          const radius = projectile.width / 2;
          const gradient = ctx.createRadialGradient(0, 0, radius * 0.2, 0, 0, radius);
          gradient.addColorStop(0, "#fff5d6");
          gradient.addColorStop(0.5, "#ff9f43");
          gradient.addColorStop(1, "#ff5733");
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(0, 0, radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = "rgba(255, 255, 255, 0.6)";
          ctx.lineWidth = 2;
          ctx.stroke();
          ctx.restore();
        });
      }

      function drawFlag() {
        if (!level.flag) return;
        const flag = level.flag;
        const x = flag.x - world.camera.x;
        ctx.fillStyle = "#d7d7d7";
        ctx.fillRect(x, flag.y, 6, flag.height);

        ctx.fillStyle = "#ff5252";
        ctx.beginPath();
        ctx.moveTo(x + 6, flag.flagY + flag.flagOffset);
        ctx.lineTo(x + 130, flag.flagY + 20 + flag.flagOffset);
        ctx.lineTo(x + 6, flag.flagY + 40 + flag.flagOffset);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = "#ffffff";
        ctx.font = "bold 22px Nunito";
        ctx.fillText("FY", x + 50, flag.flagY + 27 + flag.flagOffset);
      }

      function drawPlayer() {
        const x = player.x - world.camera.x;
        const y = player.y;
        ctx.save();
        const baseWidth = 38;
        const baseHeight = 48;
        const scaleX = player.width / baseWidth;
        const scaleY = player.height / baseHeight;
        ctx.translate(x + player.width / 2, y + player.height / 2);
        ctx.scale((player.facing === -1 ? -1 : 1) * scaleX, scaleY);
        if (player.invincibleTimer > 0 && Math.floor(player.invincibleTimer * 20) % 2 === 0) {
          ctx.globalAlpha = 0.5;
        }
        ctx.translate(-baseWidth / 2, -baseHeight / 2);

        ctx.fillStyle = "#2b2b3a";
        ctx.beginPath();
        ctx.moveTo(6, 4);
        ctx.lineTo(24, -6);
        ctx.lineTo(42, 4);
        ctx.lineTo(24, 14);
        ctx.closePath();
        ctx.fill();
        ctx.fillRect(20, 10, 8, 10);
        ctx.strokeStyle = "#f5c542";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(24, 14);
        ctx.lineTo(24, 26);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(24, 28, 3, 0, Math.PI * 2);
        ctx.fillStyle = "#f5c542";
        ctx.fill();

        ctx.fillStyle = "#ffe0b2";
        ctx.beginPath();
        ctx.arc(24, 18, 12, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillRect(18, 18, 12, 10);

        ctx.fillStyle = "#f7f7fb";
        ctx.fillRect(10, 20, 28, 28);
        ctx.strokeStyle = "#d1d1df";
        ctx.lineWidth = 2;
        ctx.strokeRect(10, 20, 28, 28);
        ctx.fillRect(12, 36, 8, 14);
        ctx.fillRect(26, 36, 8, 14);
        ctx.fillStyle = "#c2c2d6";
        ctx.fillRect(18, 22, 12, 4);
        ctx.fillRect(20, 30, 8, 10);

        ctx.fillStyle = "#6d4c41";
        ctx.fillRect(6, 38, 12, 10);
        ctx.fillRect(32, 38, 12, 10);

        ctx.fillStyle = "#263238";
        ctx.beginPath();
        ctx.arc(20, 16, 2, 0, Math.PI * 2);
        ctx.arc(28, 16, 2, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = "#d84315";
        ctx.beginPath();
        ctx.moveTo(18, 22);
        ctx.quadraticCurveTo(24, 28, 30, 22);
        ctx.stroke();

        // 如果玩家在滑板上，绘制滑板
        if (player.onSkateboard) {
          ctx.save();
          ctx.translate(0, baseHeight - 6);
          // 滑板板面
          ctx.fillStyle = "#8b4513";
          ctx.fillRect(-25, -6, 50, 12);
          // 滑板轮子
          ctx.fillStyle = "#2c2c2c";
          ctx.beginPath();
          ctx.arc(-18, 0, 5, 0, Math.PI * 2);
          ctx.arc(-6, 0, 5, 0, Math.PI * 2);
          ctx.arc(6, 0, 5, 0, Math.PI * 2);
          ctx.arc(18, 0, 5, 0, Math.PI * 2);
          ctx.fill();
          // 轮子高光
          ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
          ctx.beginPath();
          ctx.arc(-18, -2, 2, 0, Math.PI * 2);
          ctx.arc(-6, -2, 2, 0, Math.PI * 2);
          ctx.arc(6, -2, 2, 0, Math.PI * 2);
          ctx.arc(18, -2, 2, 0, Math.PI * 2);
          ctx.fill();
          // 滑板装饰
          ctx.strokeStyle = "#654321";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(-20, 0);
          ctx.lineTo(20, 0);
          ctx.stroke();
          ctx.restore();
        }

        ctx.restore();
      }

      function drawGoombas() {
        level.entities.forEach((entity) => {
          if (!(entity instanceof Goomba || entity instanceof Shark || entity instanceof Monkey)) return;
          const x = entity.x - world.camera.x;
          if (x + entity.width < -64 || x > canvas.width + 64) return;
          ctx.save();
          ctx.translate(x + entity.width / 2, entity.y + entity.height);
          
          if (entity instanceof Shark) {
            // 绘制鲨鱼
            // 先应用方向翻转（鲨鱼默认面向右侧，directionX为-1时向左移动，需要翻转）
            const direction = entity.directionX > 0 ? 1 : -1;
            ctx.scale(direction, 1);
            // 然后应用压扁效果
            ctx.scale(1, entity.state === "squashed" ? 0.3 : 1);
            
            // 绘制鲨鱼身体（椭圆形，身体中心偏右）
            ctx.fillStyle = entity.state === "squashed" ? "#4a5568" : "#5a6c7d";
            ctx.beginPath();
            ctx.ellipse(2, -18, 22, 16, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // 鲨鱼头部（尖锐的嘴巴在右侧）
            ctx.beginPath();
            ctx.moveTo(18, -18);
            ctx.lineTo(26, -12);
            ctx.lineTo(24, -6);
            ctx.lineTo(16, -8);
            ctx.closePath();
            ctx.fill();
            
            // 鲨鱼嘴巴（张开的嘴巴）
            ctx.fillStyle = "#1a1a2e";
            ctx.beginPath();
            ctx.arc(22, -10, 7, 0, Math.PI * 2);
            ctx.fill();
            
            // 牙齿（锋利的牙齿）
            ctx.fillStyle = "#ffffff";
            ctx.beginPath();
            ctx.moveTo(18, -12);
            ctx.lineTo(20, -8);
            ctx.lineTo(22, -10);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(22, -10);
            ctx.lineTo(24, -8);
            ctx.lineTo(26, -12);
            ctx.closePath();
            ctx.fill();
            
            // 眼睛（在身体左侧）
            ctx.fillStyle = "#ffffff";
            ctx.beginPath();
            ctx.arc(-6, -20, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#000000";
            ctx.beginPath();
            ctx.arc(-6, -20, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#ffffff";
            ctx.beginPath();
            ctx.arc(-5, -21, 1.5, 0, Math.PI * 2);
            ctx.fill();
            
            // 背鳍（在身体上方）
            ctx.fillStyle = entity.state === "squashed" ? "#3d4a5c" : "#4a5c6d";
            ctx.beginPath();
            ctx.moveTo(0, -30);
            ctx.lineTo(0, -24);
            ctx.lineTo(-6, -26);
            ctx.closePath();
            ctx.fill();
            
            // 侧鳍（在身体下方左侧）
            ctx.beginPath();
            ctx.moveTo(-10, -14);
            ctx.lineTo(-14, -10);
            ctx.lineTo(-12, -6);
            ctx.closePath();
            ctx.fill();
            
            // 尾巴（会摆动）
            if (entity.state !== "squashed") {
              const tailOffset = Math.sin(entity.animationTimer * 8) * 2;
              ctx.beginPath();
              ctx.moveTo(-18, -18);
              ctx.lineTo(-24 + tailOffset, -22);
              ctx.lineTo(-22 + tailOffset, -14);
              ctx.closePath();
              ctx.fill();
            }
          } else if (entity instanceof Monkey) {
            // 绘制猴子
            ctx.scale(entity.state === "squashed" ? 1 : 1, entity.state === "squashed" ? 0.3 : 1);
            
            // 猴子身体（棕色）
            ctx.fillStyle = entity.state === "squashed" ? "#8b6f47" : "#a67c52";
            ctx.beginPath();
            ctx.ellipse(0, -18, 18, 20, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // 猴子头部（圆形，稍微向上）
            ctx.fillStyle = entity.state === "squashed" ? "#8b6f47" : "#a67c52";
            ctx.beginPath();
            ctx.arc(0, -32, 14, 0, Math.PI * 2);
            ctx.fill();
            
            // 猴子脸部（浅棕色）
            ctx.fillStyle = "#d4a574";
            ctx.beginPath();
            ctx.ellipse(0, -30, 10, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // 猴子眼睛
            ctx.fillStyle = "#000000";
            ctx.beginPath();
            ctx.arc(-5, -32, 2.5, 0, Math.PI * 2);
            ctx.arc(5, -32, 2.5, 0, Math.PI * 2);
            ctx.fill();
            
            // 眼睛高光
            ctx.fillStyle = "#ffffff";
            ctx.beginPath();
            ctx.arc(-4, -33, 1, 0, Math.PI * 2);
            ctx.arc(6, -33, 1, 0, Math.PI * 2);
            ctx.fill();
            
            // 猴子鼻子（小三角形）
            ctx.fillStyle = "#8b6f47";
            ctx.beginPath();
            ctx.moveTo(0, -28);
            ctx.lineTo(-3, -26);
            ctx.lineTo(3, -26);
            ctx.closePath();
            ctx.fill();
            
            // 猴子嘴巴
            ctx.strokeStyle = "#8b6f47";
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.arc(0, -24, 4, 0, Math.PI);
            ctx.stroke();
            
            // 猴子手臂（根据跳跃状态调整位置）
            const armOffset = entity.onGround ? 0 : Math.sin(entity.animationTimer * 8) * 5;
            ctx.fillStyle = entity.state === "squashed" ? "#8b6f47" : "#a67c52";
            // 左手臂
            ctx.beginPath();
            ctx.ellipse(-14 + armOffset, -16, 6, 12, -0.3, 0, Math.PI * 2);
            ctx.fill();
            // 右手臂
            ctx.beginPath();
            ctx.ellipse(14 - armOffset, -16, 6, 12, 0.3, 0, Math.PI * 2);
            ctx.fill();
            
            // 猴子腿
            ctx.fillStyle = entity.state === "squashed" ? "#8b6f47" : "#a67c52";
            ctx.fillRect(-10, -4, 8, 14);
            ctx.fillRect(2, -4, 8, 14);
            
            // 猴子尾巴（会摆动）
            if (entity.state !== "squashed") {
              const tailOffset = Math.sin(entity.animationTimer * 6) * 8;
              ctx.strokeStyle = entity.state === "squashed" ? "#8b6f47" : "#a67c52";
              ctx.lineWidth = 4;
              ctx.beginPath();
              ctx.moveTo(-12, -8);
              ctx.quadraticCurveTo(-18 + tailOffset, -12, -20 + tailOffset, -4);
              ctx.stroke();
            }
          } else {
            // 绘制Goomba
            const isGhost = activeTheme && activeTheme.key === "ghost";
            
            if (isGhost) {
              // 绘制幽灵形象
              ctx.scale(entity.state === "squashed" ? 1 : 1, entity.state === "squashed" ? 0.3 : 1);
              
              // 幽灵主体 - 半透明白色/淡紫色
              ctx.globalAlpha = 0.85;
              ctx.fillStyle = entity.state === "squashed" ? "rgba(220, 200, 255, 0.6)" : "rgba(240, 230, 255, 0.9)";
              
              // 绘制幽灵身体（上半部分圆形，下半部分波浪形）
              ctx.beginPath();
              // 从左边开始画半圆（上半部分）
              ctx.arc(0, -25, 18, Math.PI, 0, false);
              
              // 波浪形底部（从右到左）
              const waveOffset = entity.state === "squashed" ? 0 : Math.sin((Date.now() / 300 + entity.x * 0.01) % (Math.PI * 2)) * 3;
              const baseY = -10;
              ctx.lineTo(18, baseY + waveOffset);
              ctx.quadraticCurveTo(12, baseY - 3 + waveOffset, 6, baseY + waveOffset);
              ctx.quadraticCurveTo(0, baseY - 3 + waveOffset, -6, baseY + waveOffset);
              ctx.quadraticCurveTo(-12, baseY - 3 + waveOffset, -18, baseY + waveOffset);
              ctx.closePath();
              ctx.fill();
              
              // 幽灵眼睛
              ctx.globalAlpha = 1;
              ctx.fillStyle = "#1a0f26";
              ctx.beginPath();
              ctx.arc(-8, -22, 4, 0, Math.PI * 2);
              ctx.arc(8, -22, 4, 0, Math.PI * 2);
              ctx.fill();
              
              // 眼睛高光
              ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
              ctx.beginPath();
              ctx.arc(-7, -23, 1.5, 0, Math.PI * 2);
              ctx.arc(9, -23, 1.5, 0, Math.PI * 2);
              ctx.fill();
              
              // 幽灵外发光效果
              if (entity.state !== "squashed") {
                ctx.shadowBlur = 15;
                ctx.shadowColor = "rgba(200, 150, 255, 0.6)";
                ctx.strokeStyle = "rgba(200, 150, 255, 0.4)";
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.shadowBlur = 0;
              }
            } else {
              // 原来的Goomba形象
              ctx.scale(entity.state === "squashed" ? 1 : 1, entity.state === "squashed" ? 0.3 : 1);

              ctx.fillStyle = "#a45c2a";
              ctx.beginPath();
              ctx.ellipse(0, -20, 20, 24, 0, 0, Math.PI * 2);
              ctx.fill();
              ctx.fillRect(-22, -26, 44, 20);

              ctx.fillStyle = "#fdf4ed";
              ctx.fillRect(-14, -32, 12, 16);
              ctx.fillRect(2, -32, 12, 16);
              ctx.fillStyle = "#2c2c2c";
              ctx.beginPath();
              ctx.arc(-8, -24, 4, 0, Math.PI * 2);
              ctx.arc(8, -24, 4, 0, Math.PI * 2);
              ctx.fill();

              ctx.fillStyle = "#5d3d20";
              ctx.fillRect(-18, -6, 12, 16);
              ctx.fillRect(6, -6, 12, 16);
            }
          }
          
          ctx.restore();
        });
      }

      function drawFlag() {
        if (!level.flag) return;
        const flag = level.flag;
        const x = flag.x - world.camera.x;
        ctx.fillStyle = "#d7d7d7";
        ctx.fillRect(x, flag.y, 6, flag.height);

        ctx.fillStyle = "#ff5252";
        ctx.beginPath();
        ctx.moveTo(x + 6, flag.flagY + flag.flagOffset);
        ctx.lineTo(x + 130, flag.flagY + 20 + flag.flagOffset);
        ctx.lineTo(x + 6, flag.flagY + 40 + flag.flagOffset);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = "#ffffff";
        ctx.font = "bold 22px Nunito";
        ctx.fillText("FY", x + 50, flag.flagY + 27 + flag.flagOffset);
      }

      function draw() {
        drawBackground();
        drawGround();
        drawPlatforms();
        drawBricks();
        drawCoins();
        drawMushrooms();
        drawSkateboards();
        drawSnowPiles();
        drawIcePillars();
        levelCelebration.draw();
        drawFireballs();
        drawFlag();
        drawGoombas();
        drawPlayer();
      }

      function loop(timestamp) {
        if (!loop.lastTime) loop.lastTime = timestamp;
        const delta = Math.min(0.05, (timestamp - loop.lastTime) / 1000);
        loop.lastTime = timestamp;

        if (running) {
          update(delta);
        }
        levelCelebration.update(delta);
        draw();
        requestAnimationFrame(loop);
      }

      document.addEventListener("keydown", (event) => {
        const code = event.code;
        if (
          ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Space"].includes(code)
        ) {
          event.preventDefault();
        }
        if (code === "KeyT") {
          event.preventDefault();
          resetGame();
          return;
        }
        if (code === "KeyF") {
          const fireball = player.fire();
          if (fireball) {
            level.projectiles.push(fireball);
            showToast("Research fireball launched!", 900);
          }
          return;
        }
        // 管道功能已禁用
        // if (code === "ArrowDown" || code === "KeyS") {
        //   if (tryEnterPipe()) {
        //     event.preventDefault();
        //     return;
        //   }
        // }
        keyState.add(code);
      });

      document.addEventListener("keyup", (event) => {
        keyState.delete(event.code);
      });

      window.addEventListener("blur", () => {
        keyState.clear();
      });

      const restartButton = document.getElementById("restart-current-level");
      if (restartButton) {
        restartButton.addEventListener("click", () => {
          restartCurrentLevel();
        });
      }

      const levelSelect = document.getElementById("level-select");
      if (levelSelect) {
        levelSelect.addEventListener("change", (event) => {
          const selectedLevel = parseInt(event.target.value, 10);
          if (!isNaN(selectedLevel) && selectedLevel >= 0 && selectedLevel < levelDefinitions.length) {
            resetGame({ showMessage: true, startLevel: selectedLevel });
            levelSelect.value = selectedLevel.toString();
          }
        });
      }


      resetGame({ showMessage: false, startLevel: 2 });
      requestAnimationFrame(loop);
    </script>
  </body>
</html>
