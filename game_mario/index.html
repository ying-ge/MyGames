<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mario’s CNS Sprint</title>
    <style>
      :root {
        color-scheme: light;
        --bg: #f3f6ff;
        --panel: rgba(255, 255, 255, 0.92);
        --accent: #4165ff;
        --accent-dark: #1f2d70;
        --text: #1b1d33;
        --muted: #5a6386;
        --success: #21a179;
        --danger: #e04040;
        font-family: "Nunito", "PingFang SC", "Microsoft YaHei", sans-serif;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        background: linear-gradient(135deg, #e0e8ff, #faf5ff 60%);
        color: var(--text);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 24px 16px 48px;
      }

      .wrapper {
        width: min(1100px, 100%);
        display: grid;
        gap: 20px;
      }

      .back-button {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        width: fit-content;
        padding: 8px 18px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.9);
        color: var(--accent);
        font-weight: 600;
        text-decoration: none;
        box-shadow: 0 8px 22px rgba(65, 101, 255, 0.2);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .back-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 12px 28px rgba(65, 101, 255, 0.28);
      }

      .restart-button {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        width: fit-content;
        padding: 8px 18px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.9);
        color: var(--accent);
        font-weight: 600;
        text-decoration: none;
        border: none;
        cursor: pointer;
        font-size: 14px;
        font-family: inherit;
        box-shadow: 0 8px 22px rgba(65, 101, 255, 0.2);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }

      .restart-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 12px 28px rgba(65, 101, 255, 0.28);
      }

      .level-selector {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-top: 12px;
        flex-wrap: wrap;
      }

      .level-selector label {
        font-size: 14px;
        font-weight: 600;
        color: var(--text);
      }

      .level-selector select {
        padding: 8px 16px;
        border-radius: 12px;
        border: 2px solid rgba(65, 101, 255, 0.3);
        background: rgba(255, 255, 255, 0.9);
        color: var(--accent);
        font-weight: 600;
        font-size: 14px;
        font-family: inherit;
        cursor: pointer;
        outline: none;
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
      }

      .level-selector select:hover {
        border-color: rgba(65, 101, 255, 0.5);
        box-shadow: 0 4px 12px rgba(65, 101, 255, 0.15);
      }

      .level-selector select:focus {
        border-color: var(--accent);
        box-shadow: 0 4px 12px rgba(65, 101, 255, 0.25);
      }

      .panel {
        background: var(--panel);
        border-radius: 28px;
        padding: 24px 28px;
        box-shadow: 0 22px 46px rgba(34, 48, 120, 0.15);
        display: grid;
        gap: 18px;
      }

      h1 {
        margin: 0;
        font-size: clamp(28px, 6vw, 42px);
        font-weight: 800;
        letter-spacing: 1px;
      }

      .subtitle {
        margin: 0;
        color: var(--muted);
        font-size: clamp(16px, 4vw, 18px);
        line-height: 1.6;
        max-width: 760px;
      }

      .hud {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 12px;
      }

      .hud-item {
        padding: 12px 18px;
        border-radius: 18px;
        background: rgba(255, 255, 255, 0.9);
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6), 0 10px 18px rgba(25, 32, 80, 0.12);
        text-align: center;
        font-size: 14px;
        font-variant-numeric: tabular-nums;
      }

      .hud-item strong {
        display: block;
        margin-top: 4px;
        font-size: 20px;
        color: var(--accent);
      }

      .controls {
        display: grid;
        gap: 12px;
        font-size: 14px;
        color: var(--muted);
      }

      .controls ul {
        list-style: none;
        padding: 0;
        margin: 0;
        display: grid;
        gap: 8px;
      }

      .controls li {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      .key {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 4px 10px;
        border-radius: 10px;
        border: 1px solid rgba(65, 101, 255, 0.3);
        background: rgba(65, 101, 255, 0.08);
        font-weight: 600;
        color: var(--accent);
      }

      .notice {
        padding: 12px 16px;
        border-radius: 16px;
        background: rgba(65, 101, 255, 0.12);
        color: var(--accent-dark);
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6);
        font-size: 14px;
      }

      .canvas-wrapper {
        position: relative;
        width: 100%;
        border-radius: 24px;
        overflow: hidden;
        box-shadow: 0 18px 42px rgba(26, 33, 90, 0.18);
      }

      canvas {
        display: block;
        width: 100%;
        height: auto;
        background: radial-gradient(circle at 20% 15%, #ffffff, #d8e6ff 80%);
      }

      .toast {
        position: fixed;
        bottom: 32px;
        left: 50%;
        transform: translateX(-50%) translateY(20px);
        background: rgba(31, 45, 110, 0.88);
        color: #fff;
        padding: 12px 20px;
        border-radius: 999px;
        box-shadow: 0 12px 30px rgba(31, 45, 110, 0.35);
        font-size: 14px;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.25s ease, transform 0.25s ease;
        z-index: 20;
      }

      .toast.show {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }

      @media (max-width: 768px) {
        .panel {
          padding: 20px 22px;
        }

        .hud-item {
          padding: 10px 14px;
        }
      }
    </style>
  </head>
  <body>
    <div class="wrapper">
      <a class="back-button" href="../index.html">
        <span>←</span>
        More Games
      </a>
      <div class="panel">
        <h1>Mario’s CNS Sprint</h1>
        <p class="subtitle">
          Guide Researcher Mario through the FigureYa lab, stomp mischievous Goombas, collect scattered figures, unleash fireballs, and sprint to the finish to publish that CNS paper!
        </p>
        <div class="hud" role="status" aria-live="polite">
          <div class="hud-item">
            Score
            <strong id="hud-score">000000</strong>
          </div>
          <div class="hud-item">
            Figures
            <strong id="hud-coins">×00</strong>
          </div>
          <div class="hud-item">
            Ammo
            <strong id="hud-ammo">×00</strong>
          </div>
          <div class="hud-item">
            Lives
            <strong id="hud-life">×01</strong>
          </div>
          <div class="hud-item">
            Time
            <strong id="hud-time">300</strong>
          </div>
          <div class="hud-item">
            World
            <strong id="hud-world">1-1</strong>
          </div>
        </div>
        <div class="controls">
          <div>
            <strong>Controls</strong>
            <ul>
              <li>
                <span class="key">WASD</span>
                or
                <span class="key">Arrow Keys</span>
                : Move & Jump
              </li>
              <li>
                <span class="key">Space</span>
                or
                <span class="key">K</span>
                : Jump
              </li>
              <li>
                <span class="key">F</span>
                : Fire research fireballs (requires ammo)
              </li>
              <li>
                <span class="key">T</span>
                : Return to 1-1 and restart
              </li>
            </ul>
          </div>
          <div style="margin-top: 12px;">
            <button class="restart-button" id="restart-current-level" type="button">
              <span>↻</span>
              Restart Current Level
            </button>
          </div>
          <div class="level-selector">
            <label for="level-select">Start Level:</label>
            <select id="level-select">
              <option value="0">1-1 Research Field</option>
              <option value="1">1-2 Underground Lab</option>
              <option value="2">1-3 Cloudtop Testbed</option>
              <option value="3">1-4 Candy House</option>
              <option value="4">1-5 Haunted Mansion</option>
              <option value="5">1-6 Underwater Lab</option>
              <option value="6">1-7 Mountain Climb</option>
              <option value="7">1-8 Ski Resort</option>
            </select>
          </div>
        </div>
        <div class="notice" role="note">
          <strong>Tip:</strong> Stomp Goombas by landing on them, hit "?" blocks or collect 10 figure sheets to earn a fireball, grab mushrooms to grow or gain lives, and watch the candy house erupt in CNS fireworks at the finish!
        </div>
        <div class="canvas-wrapper">
          <canvas
            id="game"
            width="960"
            height="540"
            aria-label="Mario’s CNS Sprint game canvas"
          ></canvas>
        </div>
      </div>
    </div>
    <div class="toast" id="toast" role="status" aria-live="polite"></div>
    <script>
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      const hudScore = document.getElementById("hud-score");
      const hudCoins = document.getElementById("hud-coins");
      const hudAmmo = document.getElementById("hud-ammo");
      const hudLife = document.getElementById("hud-life");
      const hudTime = document.getElementById("hud-time");
      const hudWorld = document.getElementById("hud-world");
      const toast = document.getElementById("toast");

      const figureGalleryFiles = [
        "FigureYa108RNAseqChIP.webp",
        "FigureYa115cofactor.webp",
        "FigureYa121MethCGIcluster.webp",
        "FigureYa233genepair.webp",
        "FigureYa285scRNA_monocle.webp",
        "FigureYa323STpathseq.webp",
      ];

      const figureGallery = figureGalleryFiles
        .map((file) => {
          const img = new Image();
          img.src = `./gallery_compress/${file}`;
          img.alt = file;
          return img;
        })
        .filter(Boolean);

      function getRandomFigureImage() {
        if (!figureGallery.length) return null;
        const index = Math.floor(Math.random() * figureGallery.length);
        return figureGallery[index];
      }

      const world = {
        gravity: 1600,
        friction: 0.86,
        width: canvas.width,
        height: canvas.height,
        camera: { x: 0, y: 0 },
        goalX: 3300,
        timeLimit: 300,
      };

      let activeTheme = null;

      const keyState = new Set();

      function showToast(message, duration = 1600) {
        toast.textContent = message;
        toast.classList.add("show");
        clearTimeout(showToast.timer);
        showToast.timer = setTimeout(() => toast.classList.remove("show"), duration);
      }

      function clamp(value, min, max) {
        return Math.min(Math.max(value, min), max);
      }

      function updateAmmoHUD() {
        if (!player) return;
        hudAmmo.textContent = `×${player.ammo.toString().padStart(2, "0")}`;
        hudLife.textContent = `×${(player.extraLives + 1).toString().padStart(2, "0")}`;
      }

      class Entity {
        constructor(x, y, width, height) {
          this.x = x;
          this.y = y;
          this.width = width;
          this.height = height;
          this.vx = 0;
          this.vy = 0;
          this.removed = false;
        }

        get left() {
          return this.x;
        }
        get right() {
          return this.x + this.width;
        }
        get top() {
          return this.y;
        }
        get bottom() {
          return this.y + this.height;
        }
      }

      class Player extends Entity {
        constructor(x, y) {
          super(x, y, 38, 48);
          this.onGround = false;
          this.score = 0;
          this.coins = 0;
          this.impactFactor = 0; // Impact factor (0-100)
          this.state = "idle";
          this.invincibleTimer = 0;
          this.animationTimer = 0;
          this.facing = 1;
          this.size = "small";
          this.dimensions = {
            small: { width: 38, height: 48 },
            big: { width: 46, height: 78 },
          };
          this.extraLives = 0;
          this.ammo = 0;
          this.collectibles = 0;
          this.onSkateboard = false;
          this.skateboardTimer = 0;
          this.onBoat = false;
          this.currentBoat = null;
          this.lastBoat = null; // 记录最后所在的船（用于在障碍物上时让船跟随）
          this.updateDimensions("small");
        }

        updateDimensions(size) {
          const { width, height } = this.dimensions[size];
          const bottom = this.bottom;
          this.width = width;
          this.height = height;
          this.y = bottom - height;
        }

        setSize(size, { silent = false } = {}) {
          if (this.size === size) return;
          this.size = size;
          this.updateDimensions(size);
          if (!silent) {
            if (size === "big") {
              showToast("Research Mario leveled up—extra protection gained!", 1400);
            } else if (size === "small") {
              showToast("Ouch! Shrunk back down—stay alert!", 1400);
            }
          }
          this.onGround = false;
        }

        grow() {
          if (this.size === "small") {
            this.setSize("big");
            this.invincibleTimer = 2.2;
          } else {
            this.extraLives += 1;
            this.addScore(400);
            updateAmmoHUD();
            showToast("Research blossom acquired! Extra life +1!", 1600);
          }
        }

        update(dt) {
          const isSnow = activeTheme && activeTheme.key === "snow";
          const isWater = levelDefinitions[currentLevelIndex] && levelDefinitions[currentLevelIndex].theme === "water";
          const isBoat = levelDefinitions[currentLevelIndex] && levelDefinitions[currentLevelIndex].theme === "boat";
          
          // 滑板状态更新
          if (this.onSkateboard) {
            this.skateboardTimer += dt;
            // 滑板持续10秒
            if (this.skateboardTimer > 10) {
              this.onSkateboard = false;
              this.skateboardTimer = 0;
              showToast("Skateboard worn out!", 1200);
            }
          }
          
          // 在船上时，玩家控制船移动
          if (this.onBoat && this.currentBoat) {
            const boatAccel = 600; // 船的加速度
            const boatMaxSpeed = 250; // 船的最大速度
            
            // 检测前方是否有其他船（仅在向右移动时检测）
            let canMoveRight = true;
            if (level && level.boats) {
              for (const otherBoat of level.boats) {
                if (otherBoat === this.currentBoat) continue; // 跳过当前船
                
                // 检查前方是否有船（在右侧，且Y位置相近）
                const distanceX = otherBoat.x - (this.currentBoat.x + this.currentBoat.width);
                const distanceY = Math.abs(otherBoat.y - this.currentBoat.y);
                
                // 如果前方有船（距离小于100像素，且Y位置相近），阻止前进
                if (distanceX >= 0 && distanceX < 100 && distanceY < 30) {
                  canMoveRight = false;
                  // 如果船正在向右移动，立即停止
                  if (this.currentBoat.vx > 0) {
                    this.currentBoat.vx = 0;
                  }
                  // 确保船不会与前方船重叠
                  if (this.currentBoat.x + this.currentBoat.width > otherBoat.x) {
                    this.currentBoat.x = otherBoat.x - this.currentBoat.width - 1;
                  }
                  break;
                }
              }
            }
            
            if (keyState.has("ArrowLeft") || keyState.has("KeyA")) {
              this.currentBoat.vx = clamp(this.currentBoat.vx - boatAccel * dt, -boatMaxSpeed, boatMaxSpeed);
              this.facing = -1;
            } else if ((keyState.has("ArrowRight") || keyState.has("KeyD")) && canMoveRight) {
              // 只有在可以向右移动时才允许加速
              this.currentBoat.vx = clamp(this.currentBoat.vx + boatAccel * dt, -boatMaxSpeed, boatMaxSpeed);
              this.facing = 1;
            } else if (!canMoveRight && this.currentBoat.vx > 0) {
              // 如果前方有船，逐渐减速
              this.currentBoat.vx = Math.max(0, this.currentBoat.vx - boatAccel * dt * 2);
            }
            
            // 玩家跟随船移动（允许玩家在船上移动，以便调整位置跳跃到前方的船）
            // 允许玩家在船上自由移动，可以移动到船边缘
            const boatLeft = this.currentBoat.x + 2;
            const boatRight = this.currentBoat.x + this.currentBoat.width - 2;
            
            // 玩家在船上时的速度处理（必须在位置更新之前）
            // 关键：即使船被挡住了，玩家也可以积累速度，这样跳跃时才能跳到前方的船
            if (keyState.has("ArrowRight") || keyState.has("KeyD")) {
              // 玩家想向右移动，积累向右的速度（即使船被挡住也可以积累）
              // 初始化速度（如果之前是0或负数）
              if (this.vx <= 0) {
                this.vx = 150; // 给一个初始速度
              }
              // 积累速度（快速积累）
              this.vx = Math.min(this.vx + 1000 * dt, 600); // 积累速度，最大600
              this.facing = 1;
            } else if (keyState.has("ArrowLeft") || keyState.has("KeyA")) {
              // 玩家想向左移动
              if (this.vx >= 0) {
                this.vx = -50;
              }
              this.vx = Math.max(this.vx - 600 * dt, -200);
              this.facing = -1;
            } else {
              // 没有按键时，保持当前速度（不重置为船的速度，这样跳跃时才有速度）
              // 只应用轻微的阻力，保持速度以便跳跃
              this.vx *= 0.98;
              // 只有当速度非常小时才跟随船
              if (Math.abs(this.vx) < 5) {
                this.vx = this.currentBoat.vx;
              }
            }
            
            // 玩家可以在船上移动（速度更快，以便快速移动到船边缘）
            if (keyState.has("ArrowLeft") || keyState.has("KeyA")) {
              this.x = Math.max(boatLeft, this.x - 350 * dt);
            } else if (keyState.has("ArrowRight") || keyState.has("KeyD")) {
              this.x = Math.min(boatRight - this.width, this.x + 350 * dt);
            }
            // 确保玩家不会离开船（但允许在边缘）
            this.x = clamp(this.x, boatLeft, boatRight - this.width);
            
            // 玩家的Y位置跟随船的Y位置
            this.y = this.currentBoat.y - this.height;
            this.vy = 0;
            this.onGround = true;
            
            // 更新船的动画（这会在船的update中处理碰撞检测）
            this.currentBoat.update(dt);
          } else if (isBoat && !this.onBoat) {
            // 第9关：不在船上时
            if (this.onGround && this.lastBoat) {
              // 在障碍物上时，允许玩家移动，船跟随玩家
              const baseSpeed = this.size === "big" ? 300 : 280;
              const accel = 1400;
              const maxSpeed = baseSpeed;
              
              if (keyState.has("ArrowLeft") || keyState.has("KeyA")) {
                this.vx = clamp(this.vx - accel * dt, -maxSpeed, maxSpeed);
                this.facing = -1;
              } else if (keyState.has("ArrowRight") || keyState.has("KeyD")) {
                this.vx = clamp(this.vx + accel * dt, -maxSpeed, maxSpeed);
                this.facing = 1;
              } else {
                // 摩擦力
                this.vx *= world.friction;
                if (Math.abs(this.vx) < 40) this.vx = 0;
              }
              
              // 船跟随玩家同步移动
              this.lastBoat.vx = this.vx;
              this.lastBoat.x += this.lastBoat.vx * dt;
              // 更新船的动画
              this.lastBoat.update(dt);
            } else {
              // 在空中时，允许玩家控制水平移动（以便跳向前方的船）
              const baseSpeed = this.size === "big" ? 300 : 280;
              const airAccel = 1200; // 增加空中加速度，确保能够跳到前方的船
              const maxAirSpeed = baseSpeed * 1.2; // 增加空中最大速度
              
              if (keyState.has("ArrowLeft") || keyState.has("KeyA")) {
                this.vx = clamp(this.vx - airAccel * dt, -maxAirSpeed, maxAirSpeed);
                this.facing = -1;
              } else if (keyState.has("ArrowRight") || keyState.has("KeyD")) {
                this.vx = clamp(this.vx + airAccel * dt, -maxAirSpeed, maxAirSpeed);
                this.facing = 1;
              }
              // 在空中时保持水平速度（减少阻力，保持速度以便跳到前方的船）
              this.vx *= 0.99;
            }
            // 允许垂直移动（重力下落）
            this.vy += world.gravity * dt;
            this.vy = Math.min(this.vy, 980);
            this.x += this.vx * dt;
            this.y += this.vy * dt;
          } else {
            // 正常移动逻辑
            // 滑雪场速度更快，滑板上更快
            const baseSpeed = this.size === "big" ? 300 : 280;
            let speed = isSnow ? baseSpeed * 1.3 : baseSpeed;
            if (this.onSkateboard) {
              speed = baseSpeed * 2.0; // 滑板上速度翻倍
            }
            // 水下移动速度较慢
            if (isWater) {
              speed = baseSpeed * 0.7;
            }
          const accel = this.onGround ? 1400 : 860;
          const maxSpeed = this.onGround ? speed : speed - 40;

          if (keyState.has("ArrowLeft") || keyState.has("KeyA")) {
            this.vx = clamp(this.vx - accel * dt, -maxSpeed, maxSpeed);
            this.facing = -1;
          } else if (keyState.has("ArrowRight") || keyState.has("KeyD")) {
            this.vx = clamp(this.vx + accel * dt, -maxSpeed, maxSpeed);
            this.facing = 1;
          } else if (this.onGround) {
              // 滑板上摩擦力更低
              const friction = this.onSkateboard ? 0.96 : world.friction;
              this.vx *= friction;
              // 滑板上需要更小的速度阈值才能停下
              const stopThreshold = this.onSkateboard ? 10 : (isSnow ? 15 : 40);
              if (Math.abs(this.vx) < stopThreshold) this.vx = 0;
            }
          }

          // 水下可以上下移动
          if (isWater) {
            const verticalAccel = 800; // 上下移动加速度
            if (keyState.has("ArrowUp") || keyState.has("KeyW")) {
              this.vy -= verticalAccel * dt;
            } else if (keyState.has("ArrowDown") || keyState.has("KeyS")) {
              this.vy += verticalAccel * dt;
            }
            // 如果没有按上下键，添加轻微的水阻力
            if (!keyState.has("ArrowUp") && !keyState.has("KeyW") && 
                !keyState.has("ArrowDown") && !keyState.has("KeyS")) {
              this.vy *= 0.95; // 水阻力，逐渐减速
            }
          } else {
            // 非水下关卡的跳跃（第9关在船上时可以跳跃）
            const jumpVelocity = this.size === "big" ? -700 : -600;
            if (
              (keyState.has("ArrowUp") ||
                keyState.has("KeyW") ||
                keyState.has("Space") ||
                keyState.has("KeyK")) &&
              (this.onGround || (isBoat && this.onBoat))
            ) {
              this.vy = jumpVelocity;
              this.onGround = false;
              // 在船上跳跃时，使用玩家当前的速度（已经积累了速度）
              if (isBoat && this.onBoat && this.currentBoat) {
                // 使用玩家当前的速度（如果玩家按了方向键，已经有速度了）
                // 如果速度太小，至少给一个基础速度
                let jumpSpeed = this.vx; // 使用当前积累的速度
                
                if (keyState.has("ArrowRight") || keyState.has("KeyD")) {
                  // 确保有足够的速度跳到前方的船（至少500）
                  jumpSpeed = Math.max(jumpSpeed, 500);
                } else if (keyState.has("ArrowLeft") || keyState.has("KeyA")) {
                  jumpSpeed = Math.min(jumpSpeed, -150);
                } else {
                  // 没有按方向键，给一个基础向右速度
                  jumpSpeed = Math.max(jumpSpeed, 450);
                }
                
                this.vx = jumpSpeed;
                this.lastBoat = this.currentBoat; // 保存船的引用，用于后续同步
                
                // 立即清除船上状态，让玩家可以自由移动
                this.onBoat = false;
                this.currentBoat = null;
                
                // 立即更新玩家位置，离开船的碰撞范围
                this.y -= 15; // 向上移动更多，确保离开船的碰撞范围
                this.x += 5; // 稍微向右移动，避免立即检测到还在船上
              }
              showToast("Lift-off! Research Mario leaps into action!", 1000);
            }
          }

          // 在船上时不应用重力和移动（已在上面处理）
          if (!this.onBoat && !isBoat) {
            // 水下浮力效果：减少重力，添加浮力
            if (isWater) {
              // 减少重力影响（只有20%的重力）
              this.vy += world.gravity * dt * 0.2;
              // 添加浮力：抵消部分重力，让玩家能够悬浮
              const buoyancy = 320; // 浮力大小（约等于20%的重力，形成平衡）
              this.vy -= buoyancy * dt; // 持续向上的浮力
              // 限制水下最大速度
              this.vy = clamp(this.vy, -250, 250);
            } else {
              this.vy += world.gravity * dt;
              this.vy = Math.min(this.vy, 980);
            }

            this.x += this.vx * dt;
            this.y += this.vy * dt;
          }

          this.animationTimer += dt;
          if (this.vy < -60) {
            this.state = "jump";
          } else if (!this.onGround) {
            this.state = "fall";
          } else if (Math.abs(this.vx) > 20) {
            this.state = "run";
          } else {
            this.state = "idle";
          }

          if (this.invincibleTimer > 0) {
            this.invincibleTimer = Math.max(0, this.invincibleTimer - dt);
          }
        }

        addScore(points) {
          this.score += points;
          hudScore.textContent = this.score.toString().padStart(6, "0");
        }

        addCoin(count = 1, { track = true } = {}) {
          this.coins += count;
          hudCoins.textContent = `×${this.coins.toString().padStart(2, "0")}`;
          this.addScore(200);
          
          // 更新Impact factor：每关最多10分，重复过同一关不增长
          // 每个金币贡献约0.4分，这样每关25个金币最多10分
          const impactPerCoin = 0.4;
          const maxImpactPerLevel = 10; // 每关最多10分
          
          // 检查当前关卡是否已经达到上限（避免重复过同一关时增长）
          const levelAlreadyMaxed = levelImpacts[currentLevelIndex] >= maxImpactPerLevel;
          
          if (!levelAlreadyMaxed) {
            // 计算当前关卡可以增加的分数
            const remainingLevelImpact = maxImpactPerLevel - levelImpacts[currentLevelIndex];
            const impactToAdd = Math.min(count * impactPerCoin, remainingLevelImpact);
            
            // 更新当前关卡的贡献（永久记录）
            levelImpacts[currentLevelIndex] = Math.min(maxImpactPerLevel, levelImpacts[currentLevelIndex] + count * impactPerCoin);
            
            // 更新当前关卡的临时计数（用于显示）
            currentLevelImpact = levelImpacts[currentLevelIndex];
            currentLevelCoins += count;
            
            // 更新总Impact factor（最多80分，8关×10分）
            this.impactFactor = Math.min(80, this.impactFactor + impactToAdd);
          } else {
            // 如果当前关卡已经达到上限，只更新金币计数，不增加Impact factor
            currentLevelCoins += count;
          }
          
          if (track) {
            this.trackCollectible(count);
          }
        }

        bounce() {
          this.vy = this.size === "big" ? -540 : -480;
          this.onGround = false;
        }

        fire() {
          if (this.ammo <= 0) {
            showToast("Out of ammo—collect more figures and hit those question blocks!", 1400);
            return null;
          }
          const direction = this.facing === -1 ? -1 : 1;
          const originX = this.x + this.width / 2 - 11 + direction * 30;
          const originY = this.y + this.height / 2 - 11;
          const fireball = new Fireball(originX, originY, direction);
          this.ammo = Math.max(0, this.ammo - 1);
          updateAmmoHUD();
          return fireball;
        }

        trackCollectible(count = 1) {
          this.collectibles += count;
          while (this.collectibles >= 10) {
            this.collectibles -= 10;
            this.ammo += 1;
            updateAmmoHUD();
            showToast("Research ammo +1! Press F to launch fireballs!", 1400);
          }
        }
      }

      class Goomba extends Entity {
        constructor(x, y) {
          super(x, y, 40, 42);
          this.direction = -1;
          this.walkSpeed = 60;
          this.vx = this.direction * this.walkSpeed;
          this.state = "walk";
          this.animationTimer = 0;
          this.flattenTimer = 0.4;
          this.onGround = false;
          this.edgeCheckTimer = 0; // 边缘检测计时器，避免频繁检测
        }

        update(dt) {
          if (this.state === "squashed") {
            this.flattenTimer -= dt;
            if (this.flattenTimer <= 0) {
              this.removed = true;
            }
            return;
          }
          
          // 边缘检测：检查前方是否有地面（仅在第一关）
          this.edgeCheckTimer += dt;
          if (this.edgeCheckTimer >= 0.1) { // 每0.1秒检测一次
            this.edgeCheckTimer = 0;
            
            // 只在第一关（currentLevelIndex === 0）进行边缘检测
            if (currentLevelIndex === 0 && this.onGround) {
              // 检查前方是否有地面或平台
              const checkDistance = 20; // 检测距离
              const checkX = this.direction > 0 ? this.right + checkDistance : this.left - checkDistance;
              const checkY = this.bottom + 5; // 在脚下方一点检测
              
              // 检查是否有平台或地面
              let hasGroundAhead = false;
              const colliders = [...level.platforms, ...level.bricks];
              
              for (const platform of colliders) {
                if (
                  checkX >= platform.x &&
                  checkX < platform.x + platform.width &&
                  checkY >= platform.y &&
                  checkY < platform.y + platform.height
                ) {
                  hasGroundAhead = true;
                  break;
                }
              }
              
              // 如果没有地面，改变方向
              if (!hasGroundAhead) {
                this.direction *= -1;
                this.vx = this.direction * this.walkSpeed;
              }
            }
          }
          
          this.vy += world.gravity * dt;
          this.vy = Math.min(this.vy, 700);
          this.vx = this.direction * this.walkSpeed;
          this.x += this.vx * dt;
          this.y += this.vy * dt;
          this.animationTimer += dt;
        }

        squash() {
          this.state = "squashed";
          this.vx = 0;
          this.vy = 0;
        }
      }

      class Monkey extends Entity {
        constructor(x, y) {
          super(x, y, 40, 42);
          this.direction = -1;
          this.walkSpeed = 70;
          this.vx = this.direction * this.walkSpeed;
          this.state = "walk";
          this.animationTimer = 0;
          this.flattenTimer = 0.4;
          this.jumpTimer = 0;
          this.jumpInterval = 0.8 + Math.random() * 1.2; // 0.8-2秒跳一次
          this.onGround = true; // 初始在地面上
          this.jumpPower = -550; // 跳跃力度
        }

        update(dt) {
          if (this.state === "squashed") {
            this.flattenTimer -= dt;
            if (this.flattenTimer <= 0) {
              this.removed = true;
            }
            return;
          }

          // 上蹿下跳：定期跳跃
          this.jumpTimer += dt;
          if (this.onGround && this.jumpTimer >= this.jumpInterval) {
            this.vy = this.jumpPower;
            this.onGround = false;
            this.jumpTimer = 0;
            this.jumpInterval = 0.8 + Math.random() * 1.2; // 重新设置跳跃间隔
          }

          // 应用重力
          this.vy += world.gravity * dt;
          this.vy = Math.min(this.vy, 700);
          
          // 水平移动
          this.vx = this.direction * this.walkSpeed;
          
          this.x += this.vx * dt;
          this.y += this.vy * dt;
          this.animationTimer += dt;
        }

        squash() {
          this.state = "squashed";
          this.vx = 0;
          this.vy = 0;
        }
      }

      class Shark extends Entity {
        constructor(x, y) {
          super(x, y, 48, 36);
          this.directionX = Math.random() > 0.5 ? 1 : -1;
          this.directionY = Math.random() > 0.5 ? 1 : -1;
          this.swimSpeedX = 50 + Math.random() * 30;
          this.swimSpeedY = 40 + Math.random() * 30;
          this.vx = this.directionX * this.swimSpeedX;
          this.vy = this.directionY * this.swimSpeedY;
          this.state = "swimming";
          this.animationTimer = 0;
          this.flattenTimer = 0.4;
          this.swimTimer = 0;
          this.changeDirectionTimer = 1 + Math.random() * 2; // 1-3秒后改变方向
          this.startY = y; // 记录初始Y位置
          this.swimRange = 200; // 游动范围（上下），在水中可以游得更自由
          this.startX = x; // 记录初始X位置
          this.swimRangeX = 300; // 水平游动范围
        }

        update(dt) {
          if (this.state === "squashed") {
            this.flattenTimer -= dt;
            if (this.flattenTimer <= 0) {
              this.removed = true;
            }
            return;
          }

          // 在水中游动，不受重力影响
          // 减少重力影响（浮力效果）
          this.vy += world.gravity * dt * 0.3; // 只有30%的重力影响
          this.vy = Math.min(this.vy, 400); // 限制最大下降速度
          this.vy = Math.max(this.vy, -400); // 限制最大上升速度

          // 定期改变游动方向
          this.swimTimer += dt;
          if (this.swimTimer >= this.changeDirectionTimer) {
            // 随机改变水平方向
            if (Math.random() > 0.5) {
              this.directionX *= -1;
            }
            // 随机改变垂直方向
            if (Math.random() > 0.5) {
              this.directionY *= -1;
            }
            // 随机调整速度
            this.swimSpeedX = 50 + Math.random() * 30;
            this.swimSpeedY = 40 + Math.random() * 30;
            this.changeDirectionTimer = 1 + Math.random() * 2;
            this.swimTimer = 0;
          }

          // 如果离初始位置太远，向回游（垂直方向）
          const distanceFromStartY = this.y - this.startY;
          if (Math.abs(distanceFromStartY) > this.swimRange) {
            this.directionY = distanceFromStartY > 0 ? -1 : 1;
          }
          
          // 如果离初始位置太远，向回游（水平方向）
          const distanceFromStartX = this.x - this.startX;
          if (Math.abs(distanceFromStartX) > this.swimRangeX) {
            this.directionX = distanceFromStartX > 0 ? -1 : 1;
          }

          // 应用游动速度
          this.vx = this.directionX * this.swimSpeedX;
          // 垂直方向：结合主动游动和重力
          const targetVy = this.directionY * this.swimSpeedY;
          this.vy = this.vy * 0.7 + targetVy * 0.3; // 平滑过渡

          // 添加一些随机波动，让游动更自然（减少波动幅度，让游动更平滑）
          const waveOffsetY = Math.sin(this.animationTimer * 2) * 5;
          this.vy += waveOffsetY * dt;
          // 水平方向也有轻微波动
          const waveOffsetX = Math.sin(this.animationTimer * 2.5) * 3;
          this.vx += waveOffsetX * dt;

          this.x += this.vx * dt;
          this.y += this.vy * dt;
          this.animationTimer += dt;
        }

        squash() {
          this.state = "squashed";
          this.vx = 0;
          this.vy = 0;
        }
      }

      class Bat extends Entity {
        constructor(x, y) {
          super(x, y, 40, 32);
          this.directionX = Math.random() > 0.5 ? 1 : -1;
          this.directionY = Math.random() > 0.5 ? 1 : -1;
          this.flySpeedX = 60 + Math.random() * 40;
          this.flySpeedY = 50 + Math.random() * 40;
          this.vx = this.directionX * this.flySpeedX;
          this.vy = this.directionY * this.flySpeedY;
          this.state = "flying";
          this.animationTimer = 0;
          this.flattenTimer = 0.4;
          this.flyTimer = 0;
          this.changeDirectionTimer = 0.8 + Math.random() * 1.5; // 0.8-2.3秒后改变方向
          this.startY = y; // 记录初始Y位置
          this.flyRange = 250; // 飞行范围（上下）
          this.startX = x; // 记录初始X位置
          this.flyRangeX = 400; // 水平飞行范围
          this.wingFlapTimer = 0;
        }

        update(dt) {
          if (this.state === "squashed") {
            this.flattenTimer -= dt;
            if (this.flattenTimer <= 0) {
              this.removed = true;
            }
            return;
          }

          // 蝙蝠在空中飞舞，不受重力影响
          this.vy = Math.min(this.vy, 500); // 限制最大下降速度
          this.vy = Math.max(this.vy, -500); // 限制最大上升速度

          // 定期改变飞行方向
          this.flyTimer += dt;
          if (this.flyTimer >= this.changeDirectionTimer) {
            // 随机改变水平方向
            if (Math.random() > 0.5) {
              this.directionX *= -1;
            }
            // 随机改变垂直方向
            if (Math.random() > 0.5) {
              this.directionY *= -1;
            }
            // 随机调整速度
            this.flySpeedX = 60 + Math.random() * 40;
            this.flySpeedY = 50 + Math.random() * 40;
            this.changeDirectionTimer = 0.8 + Math.random() * 1.5;
            this.flyTimer = 0;
          }

          // 如果离初始位置太远，向回飞（垂直方向）
          const distanceFromStartY = this.y - this.startY;
          if (Math.abs(distanceFromStartY) > this.flyRange) {
            this.directionY = distanceFromStartY > 0 ? -1 : 1;
          }
          
          // 如果离初始位置太远，向回飞（水平方向）
          const distanceFromStartX = this.x - this.startX;
          if (Math.abs(distanceFromStartX) > this.flyRangeX) {
            this.directionX = distanceFromStartX > 0 ? -1 : 1;
          }

          // 应用飞行速度
          this.vx = this.directionX * this.flySpeedX;
          const targetVy = this.directionY * this.flySpeedY;
          this.vy = this.vy * 0.6 + targetVy * 0.4; // 平滑过渡

          // 添加一些随机波动，让飞行更自然
          const waveOffsetY = Math.sin(this.animationTimer * 3) * 8;
          this.vy += waveOffsetY * dt;
          const waveOffsetX = Math.sin(this.animationTimer * 2.8) * 5;
          this.vx += waveOffsetX * dt;

          this.x += this.vx * dt;
          this.y += this.vy * dt;
          this.animationTimer += dt;
          this.wingFlapTimer += dt * 10; // 翅膀扇动动画
        }

        squash() {
          this.state = "squashed";
          this.vx = 0;
          this.vy = 0;
        }
      }

      class Boat extends Entity {
        constructor(x, y) {
          super(x, y, 120, 40);
          this.vx = 0;
          this.vy = 0;
          this.bobTimer = 0; // 用于船的上下浮动动画
          this.baseY = y; // 记录船的基准Y位置
          this.waveOffset = 0; // 波浪偏移
        }

        update(dt) {
          // 船的上下浮动效果（模拟水面波浪）
          this.bobTimer += dt * 2;
          this.waveOffset = Math.sin(this.bobTimer) * 3; // 上下浮动3像素
          this.y = this.baseY + this.waveOffset;
          
          // 检测前方是否有其他船（仅在向右移动时检测）
          if (this.vx > 0 && level && level.boats) {
            for (const otherBoat of level.boats) {
              if (otherBoat === this) continue; // 跳过自己
              
              // 检查前方是否有船（在右侧，且Y位置相近）
              const distanceX = otherBoat.x - (this.x + this.width);
              const distanceY = Math.abs(otherBoat.y - this.y);
              
              // 如果前方有船（距离小于100像素，且Y位置相近），阻止前进
              if (distanceX >= 0 && distanceX < 100 && distanceY < 30) {
                // 阻止船继续前进
                this.vx = 0;
                // 确保船不会与前方船重叠
                if (this.x + this.width > otherBoat.x) {
                  this.x = otherBoat.x - this.width - 1;
                }
                return; // 直接返回，不执行后续移动
              }
            }
          }
          
          // 船的移动（由玩家控制）
          this.x += this.vx * dt;
          
          // 添加轻微的水阻力
          this.vx *= 0.95;
          if (Math.abs(this.vx) < 5) this.vx = 0;
        }
      }

      class Plane extends Entity {
        constructor(x, y) {
          super(x, y, 50, 30);
          this.direction = -1;
          this.horizontalSpeed = 80 + Math.random() * 40;
          this.vx = this.direction * this.horizontalSpeed;
          this.vy = 0;
          this.state = "taxiing"; // taxiing, takingOff, flying, landing
          this.animationTimer = 0;
          this.flattenTimer = 0.4;
          this.startY = y; // 地面高度
          this.flyingHeight = y - 200; // 飞行高度
          this.taxiingTimer = 0;
          this.taxiingDuration = 1.5 + Math.random() * 1.5; // 滑行1.5-3秒
          this.flyingTimer = 0;
          this.flyingDuration = 3 + Math.random() * 2; // 飞行3-5秒
          this.landingTimer = 0;
          this.landingDuration = 2; // 降落2秒
          this.takeoffSpeed = -300; // 起飞速度
          this.landingSpeed = 200; // 降落速度
          this.onGround = true;
        }

        update(dt) {
          if (this.state === "squashed") {
            this.flattenTimer -= dt;
            if (this.flattenTimer <= 0) {
              this.removed = true;
            }
            return;
          }

          this.animationTimer += dt;

          // 状态机：滑行 -> 起飞 -> 飞行 -> 降落 -> 滑行
          if (this.state === "taxiing") {
            // 在地面滑行
            this.vy = 0;
            this.y = this.startY;
            this.onGround = true;
            this.taxiingTimer += dt;
            
            if (this.taxiingTimer >= this.taxiingDuration) {
              this.state = "takingOff";
              this.taxiingTimer = 0;
              this.taxiingDuration = 1.5 + Math.random() * 1.5; // 重置下次滑行时间
            }
          } else if (this.state === "takingOff") {
            // 起飞阶段：向上飞
            this.vy = this.takeoffSpeed;
            this.onGround = false;
            
            if (this.y <= this.flyingHeight) {
              this.state = "flying";
              this.vy = 0;
              this.flyingTimer = 0;
              this.flyingDuration = 3 + Math.random() * 2; // 重置飞行时间
            }
          } else if (this.state === "flying") {
            // 在空中飞行
            this.vy = 0;
            this.y = this.flyingHeight;
            this.onGround = false;
            this.flyingTimer += dt;
            
            // 添加轻微的上下波动
            this.y = this.flyingHeight + Math.sin(this.animationTimer * 2) * 10;
            
            if (this.flyingTimer >= this.flyingDuration) {
              this.state = "landing";
              this.landingTimer = 0;
            }
          } else if (this.state === "landing") {
            // 降落阶段：向下飞
            this.vy = this.landingSpeed;
            this.onGround = false;
            
            if (this.y >= this.startY) {
              this.y = this.startY;
              this.vy = 0;
              this.state = "taxiing";
              this.taxiingTimer = 0;
              this.onGround = true;
            }
          }

          // 应用重力（只在起飞和降落时）
          if (this.state === "takingOff" || this.state === "landing") {
            this.vy += world.gravity * dt * 0.3; // 减少重力影响
          }

          // 水平移动
          this.vx = this.direction * this.horizontalSpeed;
          this.x += this.vx * dt;
          this.y += this.vy * dt;
        }

        squash() {
          this.state = "squashed";
          this.vx = 0;
          this.vy = 0;
        }
      }

      class Coin extends Entity {
        constructor(x, y) {
          super(x, y, 42, 42);
          this.baseY = y;
          this.timer = 0;
          this.texture = getRandomFigureImage();
          this.spin = Math.random() * Math.PI * 2;
        }

        update(dt) {
          this.timer += dt * 4;
          this.y = this.baseY + Math.sin(this.timer) * 6;
          this.spin += dt * 0.8;
        }
      }

      class Mushroom extends Entity {
        constructor(x, y) {
          super(x, y, 34, 34);
          this.direction = 1;
          this.walkSpeed = 90;
        }

        update(dt) {
          if (this.float) {
            this.timer = (this.timer || 0) + dt * 2;
            this.y += Math.sin(this.timer) * 12 * dt;
            this.vx = 0;
          } else {
            this.vy += world.gravity * dt;
            this.vy = Math.min(this.vy, 680);
            this.vx = this.direction * this.walkSpeed;
            this.x += this.vx * dt;
            this.y += this.vy * dt;
          }
        }
      }

      class Fireball extends Entity {
        constructor(x, y, direction) {
          super(x, y, 22, 22);
          this.direction = direction;
          this.speed = 660;
          this.life = 4;
          this.rotation = 0;
        }

        update(dt) {
          this.x += this.direction * this.speed * dt;
          this.rotation += dt * 6;
          this.life -= dt;
        }
      }

      class Skateboard extends Entity {
        constructor(x, y) {
          super(x, y, 50, 12);
          this.rotation = 0;
          this.floatTimer = 0;
        }

        update(dt) {
          this.floatTimer += dt * 3;
          this.rotation = Math.sin(this.floatTimer) * 0.1;
        }
      }

      class SnowPile extends Entity {
        constructor(x, y) {
          super(x, y, 60, 40);
        }
      }

      class IcePillar extends Entity {
        constructor(x, y) {
          super(x, y, 32, 80);
        }
      }

      class CandyObstacle extends Entity {
        constructor(x, y) {
          super(x, y, 48, 48);
          this.rotation = 0;
          this.rotationSpeed = (Math.random() - 0.5) * 2; // -1 到 1 的随机旋转速度
          this.bounceTimer = 0;
        }

        update(dt) {
          this.rotation += this.rotationSpeed * dt;
          this.bounceTimer += dt * 4;
          // 轻微的上下弹跳效果
          this.y = this.y + Math.sin(this.bounceTimer) * 0.5;
        }
      }

      class Brick extends Entity {
        constructor(x, y, { kind = "solid", reward = null } = {}) {
          super(x, y, 48, 48);
          this.kind = kind;
          this.reward = reward ?? (kind === "question" ? "coin" : null);
          this.bump = 0;
          this.active = true;
        }

        trigger(player) {
          if (!this.active) return;
          if (this.kind === "question") {
            this.active = false;
            this.kind = "empty";
            this.bump = 0.18;
            player.trackCollectible();
            if (this.reward === "coin") {
              player.addCoin(1, { track: false });
            showToast("FigureYa figure collected!", 900);
            } else if (this.reward === "mushroom") {
              spawnMushroom(this);
            }
          } else if (this.kind === "solid") {
            this.bump = 0.12;
          }
        }

        update(dt) {
          if (this.bump > 0) {
            this.bump = Math.max(0, this.bump - dt * 2);
          }
        }
      }

      class FallingCandy extends Entity {
        constructor(x, y) {
          super(x, y, 32, 32);
          this.rotation = Math.random() * Math.PI * 2;
          this.rotationSpeed = (Math.random() - 0.5) * 4;
          this.fallSpeed = 150 + Math.random() * 100;
          this.vy = this.fallSpeed;
          this.vx = (Math.random() - 0.5) * 30; // 轻微的横向飘动
        }

        update(dt) {
          this.rotation += this.rotationSpeed * dt;
          this.vy += world.gravity * dt * 0.5; // 重力加速
          this.vy = Math.min(this.vy, 400); // 限制最大速度
          this.x += this.vx * dt;
          this.y += this.vy * dt;
          
          // 如果掉出屏幕底部，标记为移除
          if (this.y > world.height + 100) {
            this.removed = true;
          }
        }
      }

      class PumpkinObstacle extends Entity {
        constructor(x, y) {
          super(x, y, 60, 70);
          this.rotation = 0;
          this.bounceTimer = 0;
          this.baseY = y;
        }

        update(dt) {
          // 旋转动画
          this.rotation += dt * 1.5;
          // 上下弹跳动画
          this.bounceTimer += dt * 2;
          this.y = this.baseY + Math.sin(this.bounceTimer) * 3;
        }
      }

      class CoralObstacle extends Entity {
        constructor(x, y) {
          super(x, y, 50, 70);
          this.swayTimer = 0;
          this.baseX = x;
          this.baseY = y;
          this.swayAmount = 2 + Math.random() * 3; // 轻微摆动幅度
        }

        update(dt) {
          // 水下摆动动画
          this.swayTimer += dt * 1.5;
          this.x = this.baseX + Math.sin(this.swayTimer) * this.swayAmount;
          this.y = this.baseY + Math.cos(this.swayTimer * 0.7) * 1;
        }
      }

      class RockObstacle extends Entity {
        constructor(x, y, width = 80, height = 120) {
          super(x, y, width, height);
          // 岩石可以攀爬，不需要特殊属性
        }

        update(dt) {
          // 岩石是静态的，不需要更新
        }
      }

      class TrashObstacle extends Entity {
        constructor(x, y) {
          super(x, y, 50, 40);
          // 垃圾障碍物，静态的
        }

        update(dt) {
          // 垃圾障碍物是静态的，不需要更新
        }
      }

      class Flag extends Entity {
        constructor(x, y) {
          super(x, y, 24, 180);
          this.flagY = y + 16;
          this.flagOffset = 0;
        }

        update(dt) {
          this.flagOffset = Math.sin(Date.now() / 400) * 6;
        }
      }

      const level = {
        platforms: [],
        entities: [],
        coins: [],
        bricks: [],
        pipes: [],
        powerups: [],
        projectiles: [],
        skateboards: [],
        snowPiles: [],
        icePillars: [],
        pumpkinObstacles: [],
        coralObstacles: [],
        rockObstacles: [],
        trashObstacles: [],
        flag: null,
      };

      const levelCelebration = {
        papers: [],
        active: false,
        origin: null,
        timer: 0,
        spawn() {
          const flag = level.flag;
          if (!flag) return;
          this.active = true;
          this.origin = { x: flag.x, y: flag.y - 32 };
          this.timer = 0;
          this.papers = [];
        },
        update(dt) {
          if (!this.active) return;
          this.timer += dt;
          const interval = activeTheme && activeTheme.key === "candy" ? 0.18 : 0.22;
          const burstSize = activeTheme && activeTheme.key === "candy" ? 18 : 12;
          const labels =
            activeTheme && activeTheme.key === "candy"
              ? ["C", "N", "S", "Impact"]
              : ["Cell", "Nature", "Science"];
          const flag = level.flag;
          if (flag) {
            this.origin = { x: flag.x, y: flag.y - 32 };
          }
          if (this.timer >= interval && this.origin) {
            this.timer = 0;
            for (let i = 0; i < burstSize; i++) {
              const angle = Math.random() * Math.PI * 2;
              const speed = 200 + Math.random() * 180;
              const vx = Math.cos(angle) * speed;
              const vy = Math.sin(angle) * speed - 220;
              this.papers.push({
                x: this.origin.x,
                y: this.origin.y,
                vx,
                vy,
                rotation: (Math.random() - 0.5) * 1.6,
                rotationSpeed: (Math.random() - 0.5) * 2,
                life: 2.5 + Math.random() * 0.8,
                label: labels[i % labels.length],
              });
            }
          }
          this.papers.forEach((paper) => {
            paper.vy += world.gravity * 0.5 * dt;
            paper.x += paper.vx * dt;
            paper.y += paper.vy * dt;
            paper.rotation += paper.rotationSpeed * dt;
            paper.life -= dt;
          });
          this.papers = this.papers.filter((paper) => paper.life > 0);
        },
        draw() {
          if (!this.active || !this.papers.length) return;
          this.papers.forEach((paper) => {
            const x = paper.x - world.camera.x;
            const y = paper.y;
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(paper.rotation);
            const width = 74;
            const height = 54;
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(-width / 2, -height / 2, width, height);
            ctx.strokeStyle = "#d1d1d1";
            ctx.strokeRect(-width / 2, -height / 2, width, height);
            ctx.fillStyle =
              activeTheme && activeTheme.key === "candy" ? "#ff5d8f" : "#1a237e";
            ctx.font = "bold 18px Nunito";
            ctx.textAlign = "center";
            ctx.fillText(paper.label, 0, 6);
            ctx.restore();
          });
        },
      };

      function createGround(segments = 80, pits = []) {
        for (let i = 0; i < segments; i++) {
          const x = i * 64;
          const isInPit = pits.some(pit => x >= pit.x && x < pit.x + pit.width);
          if (!isInPit) {
          level.platforms.push({
              x: x,
            y: world.height - 64,
            width: 64,
            height: 64,
          });
          }
        }
      }

      function createPlatform(x, y, tiles) {
        level.platforms.push({
          x,
          y,
          width: tiles * 48,
          height: 16,
        });
      }

      function spawnMushroom(brick) {
        const mushroom = new Mushroom(
          brick.x + brick.width / 2 - 17,
          brick.y - 34,
        );
        level.powerups.push(mushroom);
        showToast("Research mushroom spotted—grow bigger or grab an extra life!", 1100);
      }

      const H = world.height;
      const levelDefinitions = [
        {
          name: "1-1",
          theme: "research",
          intro: "Research Field 1-1: dash to the flag and publish!",
          goalX: 3300,
          timeLimit: 300,
          groundSegments: 80,
          pits: [
            { x: 1500, width: 128 },  // Pit at x=1500-1628 (2 tiles wide)
            { x: 2200, width: 192 },  // Pit at x=2200-2392 (3 tiles wide)
          ],
          start: { x: 120, y: H - 140 },
          platforms: [
            { x: 420, y: H - 200, tiles: 2 },
            { x: 720, y: H - 260, tiles: 3 },
            { x: 1020, y: H - 320, tiles: 2 },
            { x: 1380, y: H - 260, tiles: 4 },
            { x: 1700, y: H - 200, tiles: 2 },
            { x: 2060, y: H - 220, tiles: 2 },
            { x: 2360, y: H - 200, tiles: 2 },
          ],
          bricks: [
            { x: 600, y: H - 260, kind: "question", reward: "mushroom" },
            { x: 648, y: H - 260, kind: "solid" },
            { x: 696, y: H - 260, kind: "question", reward: "coin" },
            { x: 744, y: H - 260, kind: "solid" },
            { x: 792, y: H - 260, kind: "question", reward: "coin" },
            { x: 1100, y: H - 320, kind: "question", reward: "coin" },
            { x: 1148, y: H - 320, kind: "question", reward: "coin" },
            { x: 1520, y: H - 260, kind: "solid" },
            { x: 1568, y: H - 260, kind: "question", reward: "coin" },
            { x: 1616, y: H - 260, kind: "solid" },
          ],
          coins: [
            [500, H - 140],
            [560, H - 160],
            [620, H - 180],
            [840, H - 220],
            [880, H - 240],
            [920, H - 260],
            [1900, H - 220],
            [1960, H - 240],
            [2020, H - 260],
          ],
          goombas: [
            { x: 780, y: H - 110 },
            { x: 1260, y: H - 110 },
            { x: 2000, y: H - 110 },
          ],
          flag: { x: 3300, y: H - 256 },
        },
        {
          name: "1-2",
          theme: "underground",
          intro: "Underground Lab 1-2: mind the shadowy experiments!",
          goalX: 2600,
          timeLimit: 250,
          groundSegments: 70,
          start: { x: 180, y: H - 140 },
          platforms: [
            { x: 360, y: H - 220, tiles: 3 },
            { x: 760, y: H - 240, tiles: 2 },
            { x: 1100, y: H - 220, tiles: 3 },
            { x: 1480, y: H - 200, tiles: 3 },
            { x: 1880, y: H - 220, tiles: 2 },
            { x: 2140, y: H - 240, tiles: 3 },
          ],
          bricks: [
            { x: 520, y: H - 220, kind: "question", reward: "coin" },
            { x: 568, y: H - 220, kind: "question", reward: "mushroom" },
            { x: 616, y: H - 220, kind: "solid" },
            { x: 1200, y: H - 220, kind: "question", reward: "coin" },
            { x: 1248, y: H - 220, kind: "question", reward: "coin" },
            { x: 1296, y: H - 220, kind: "question", reward: "coin" },
            { x: 1660, y: H - 200, kind: "question", reward: "mushroom" },
          ],
          coins: [
            [420, H - 140],
            [460, H - 160],
            [820, H - 200],
            [860, H - 220],
            [900, H - 200],
            [1500, H - 200],
            [1540, H - 220],
            [1580, H - 240],
            [2000, H - 260],
            [2040, H - 240],
          ],
          bats: [
            { x: 900, y: H - 200 },
            { x: 1380, y: H - 180 },
            { x: 1900, y: H - 220 },
          ],
          trash: [
            { x: 600, y: H - 104 },  // y: H - 64 - 40，使垃圾袋底部贴地
            { x: 1000, y: H - 104 },
            { x: 1400, y: H - 104 },
            { x: 1800, y: H - 104 },
            { x: 2200, y: H - 104 },
          ],
          flag: { x: 2600, y: H - 256 },
        },
        {
          name: "1-3",
          theme: "sky",
          intro: "Cloudtop Testbed 1-3: rhythm jumps win the day!",
          goalX: 3600,
          timeLimit: 260,
          groundSegments: 85,
          start: { x: 140, y: H - 200 },
          platforms: [
            { x: 260, y: H - 280, tiles: 2 },
            { x: 520, y: H - 240, tiles: 3 },
            { x: 820, y: H - 300, tiles: 2 },
            { x: 1080, y: H - 260, tiles: 3 },
            { x: 1400, y: H - 320, tiles: 3 },
            { x: 1740, y: H - 280, tiles: 3 },
            { x: 2080, y: H - 260, tiles: 2 },
            { x: 2360, y: H - 300, tiles: 2 },
            { x: 2680, y: H - 260, tiles: 3 },
            { x: 3040, y: H - 280, tiles: 2 },
          ],
          bricks: [
            { x: 520, y: H - 260, kind: "question", reward: "coin" },
            { x: 568, y: H - 260, kind: "question", reward: "mushroom" },
            { x: 1120, y: H - 280, kind: "question", reward: "coin" },
            { x: 1500, y: H - 340, kind: "question", reward: "coin" },
            { x: 1548, y: H - 340, kind: "question", reward: "coin" },
            { x: 1780, y: H - 300, kind: "question", reward: "mushroom" },
            { x: 2460, y: H - 320, kind: "question", reward: "coin" },
          ],
          coins: [
            [320, H - 260],
            [360, H - 280],
            [400, H - 260],
            [900, H - 320],
            [940, H - 300],
            [980, H - 320],
            [1320, H - 280],
            [1360, H - 300],
            [1400, H - 280],
            [1880, H - 280],
            [1920, H - 300],
            [1960, H - 280],
            [2260, H - 280],
            [2300, H - 300],
            [2340, H - 280],
            [2760, H - 260],
            [2800, H - 280],
            [2840, H - 260],
          ],
          planes: [
            { x: 600, y: H - 110 },
            { x: 1220, y: H - 110 },
            { x: 1700, y: H - 110 },
            { x: 2320, y: H - 110 },
            { x: 2900, y: H - 110 },
          ],
          flag: { x: 3600, y: H - 256 },
        },
        {
          name: "1-4",
          theme: "candy",
          intro: "Candy House Celebration 1-4: present your manuscript on the CNS stage!",
          goalX: 3200,
          timeLimit: 320,
          groundSegments: 75,
          start: { x: 160, y: H - 140 },
          platforms: [
            { x: 320, y: H - 240, tiles: 3 },
            { x: 680, y: H - 220, tiles: 2 },
            { x: 960, y: H - 260, tiles: 3 },
            { x: 1340, y: H - 280, tiles: 3 },
            { x: 1680, y: H - 240, tiles: 3 },
            { x: 2020, y: H - 260, tiles: 3 },
            { x: 2360, y: H - 220, tiles: 2 },
            { x: 2680, y: H - 240, tiles: 2 },
          ],
          bricks: [
            { x: 520, y: H - 240, kind: "question", reward: "coin" },
            { x: 568, y: H - 240, kind: "question", reward: "coin" },
            { x: 616, y: H - 240, kind: "question", reward: "mushroom" },
            { x: 1120, y: H - 280, kind: "question", reward: "coin" },
            { x: 1168, y: H - 280, kind: "solid" },
            { x: 1520, y: H - 320, kind: "question", reward: "coin" },
            { x: 1568, y: H - 320, kind: "question", reward: "coin" },
            { x: 1820, y: H - 260, kind: "question", reward: "mushroom" },
            { x: 2140, y: H - 280, kind: "question", reward: "coin" },
            { x: 2188, y: H - 280, kind: "solid" },
            { x: 2460, y: H - 240, kind: "question", reward: "coin" },
          ],
          coins: [
            [360, H - 200],
            [400, H - 220],
            [440, H - 240],
            [780, H - 220],
            [820, H - 240],
            [860, H - 260],
            [1180, H - 260],
            [1220, H - 280],
            [1260, H - 260],
            [1640, H - 240],
            [1680, H - 260],
            [1720, H - 240],
            [2060, H - 260],
            [2100, H - 240],
            [2300, H - 200],
            [2340, H - 220],
            [2380, H - 200],
            [2700, H - 220],
            [2740, H - 240],
            [2780, H - 220],
          ],
          goombas: [
            { x: 620, y: H - 110 },
            { x: 980, y: H - 110 },
            { x: 1420, y: H - 110 },
            { x: 1880, y: H - 110 },
            { x: 2260, y: H - 110 },
          ],
          flag: { x: 3200, y: H - 256 },
        },
        {
          name: "1-5",
          theme: "ghost",
          intro: "Haunted Mansion 1-5: brave the spooky corridors and escape!",
          goalX: 3800,
          timeLimit: 280,
          groundSegments: 90,
          start: { x: 140, y: H - 140 },
          platforms: [
            { x: 380, y: H - 240, tiles: 2 },
            { x: 680, y: H - 280, tiles: 3 },
            { x: 1040, y: H - 220, tiles: 2 },
            { x: 1380, y: H - 300, tiles: 2 },
            { x: 1720, y: H - 260, tiles: 3 },
            { x: 2100, y: H - 240, tiles: 2 },
            { x: 2480, y: H - 280, tiles: 3 },
            { x: 2880, y: H - 220, tiles: 2 },
            { x: 3240, y: H - 260, tiles: 3 },
          ],
          bricks: [
            { x: 520, y: H - 240, kind: "question", reward: "coin" },
            { x: 568, y: H - 240, kind: "question", reward: "mushroom" },
            { x: 800, y: H - 300, kind: "question", reward: "coin" },
            { x: 848, y: H - 300, kind: "solid" },
            { x: 896, y: H - 300, kind: "question", reward: "coin" },
            { x: 1200, y: H - 240, kind: "question", reward: "coin" },
            { x: 1248, y: H - 240, kind: "question", reward: "mushroom" },
            { x: 1500, y: H - 320, kind: "question", reward: "coin" },
            { x: 1548, y: H - 320, kind: "question", reward: "coin" },
            { x: 1860, y: H - 280, kind: "question", reward: "coin" },
            { x: 1908, y: H - 280, kind: "solid" },
            { x: 1956, y: H - 280, kind: "question", reward: "mushroom" },
            { x: 2240, y: H - 260, kind: "question", reward: "coin" },
            { x: 2620, y: H - 300, kind: "question", reward: "coin" },
            { x: 2668, y: H - 300, kind: "question", reward: "coin" },
            { x: 3020, y: H - 240, kind: "question", reward: "mushroom" },
            { x: 3400, y: H - 280, kind: "question", reward: "coin" },
          ],
          coins: [
            [420, H - 200],
            [460, H - 220],
            [500, H - 240],
            [900, H - 280],
            [940, H - 300],
            [980, H - 280],
            [1280, H - 200],
            [1320, H - 220],
            [1360, H - 240],
            [1640, H - 300],
            [1680, H - 320],
            [1720, H - 300],
            [2000, H - 220],
            [2040, H - 240],
            [2080, H - 220],
            [2380, H - 260],
            [2420, H - 280],
            [2460, H - 260],
            [2780, H - 200],
            [2820, H - 220],
            [2860, H - 200],
            [3180, H - 240],
            [3220, H - 260],
            [3260, H - 240],
          ],
          goombas: [
            { x: 800, y: H - 110 },
            { x: 1200, y: H - 110 },
            { x: 1600, y: H - 110 },
            { x: 2200, y: H - 110 },
            { x: 2800, y: H - 110 },
            { x: 3400, y: H - 110 },
          ],
          pumpkins: [
            { x: 800, y: H - 100 },
            { x: 1600, y: H - 95 },
            { x: 2500, y: H - 105 },
            { x: 3400, y: H - 100 },
          ],
          flag: { x: 3800, y: H - 256 },
        },
        {
          name: "1-6",
          theme: "water",
          intro: "Underwater Lab 1-6: dive deep and explore the aquatic research facility!",
          goalX: 4000,
          timeLimit: 300,
          groundSegments: 95,
          start: { x: 160, y: H - 200 },
          platforms: [
            { x: 400, y: H - 280, tiles: 3 },
            { x: 800, y: H - 240, tiles: 2 },
            { x: 1200, y: H - 320, tiles: 3 },
            { x: 1600, y: H - 260, tiles: 2 },
            { x: 2000, y: H - 300, tiles: 3 },
            { x: 2400, y: H - 220, tiles: 2 },
            { x: 2800, y: H - 280, tiles: 3 },
            { x: 3200, y: H - 240, tiles: 2 },
            { x: 3600, y: H - 300, tiles: 3 },
          ],
          bricks: [
            { x: 520, y: H - 300, kind: "question", reward: "coin" },
            { x: 568, y: H - 300, kind: "question", reward: "mushroom" },
            { x: 616, y: H - 300, kind: "question", reward: "coin" },
            { x: 920, y: H - 260, kind: "question", reward: "coin" },
            { x: 968, y: H - 260, kind: "solid" },
            { x: 1320, y: H - 340, kind: "question", reward: "mushroom" },
            { x: 1368, y: H - 340, kind: "question", reward: "coin" },
            { x: 1416, y: H - 340, kind: "question", reward: "coin" },
            { x: 1720, y: H - 280, kind: "question", reward: "coin" },
            { x: 1768, y: H - 280, kind: "question", reward: "mushroom" },
            { x: 2120, y: H - 320, kind: "question", reward: "coin" },
            { x: 2168, y: H - 320, kind: "solid" },
            { x: 2216, y: H - 320, kind: "question", reward: "coin" },
            { x: 2520, y: H - 240, kind: "question", reward: "mushroom" },
            { x: 2920, y: H - 300, kind: "question", reward: "coin" },
            { x: 2968, y: H - 300, kind: "question", reward: "coin" },
            { x: 3320, y: H - 260, kind: "question", reward: "mushroom" },
            { x: 3720, y: H - 320, kind: "question", reward: "coin" },
          ],
          coins: [
            [440, H - 260],
            [480, H - 280],
            [520, H - 300],
            [840, H - 220],
            [880, H - 240],
            [920, H - 260],
            [1280, H - 300],
            [1320, H - 320],
            [1360, H - 300],
            [1680, H - 240],
            [1720, H - 260],
            [1760, H - 240],
            [2080, H - 280],
            [2120, H - 300],
            [2160, H - 280],
            [2480, H - 200],
            [2520, H - 220],
            [2560, H - 200],
            [2880, H - 260],
            [2920, H - 280],
            [2960, H - 260],
            [3280, H - 220],
            [3320, H - 240],
            [3360, H - 220],
            [3680, H - 280],
            [3720, H - 300],
            [3760, H - 280],
          ],
          goombas: [
            { x: 700, y: H - 110 },
            { x: 1100, y: H - 110 },
            { x: 1500, y: H - 110 },
            { x: 1900, y: H - 110 },
            { x: 2300, y: H - 110 },
            { x: 2700, y: H - 110 },
            { x: 3100, y: H - 110 },
            { x: 3500, y: H - 110 },
          ],
          upperSharks: [
            { x: 500, y: H - 300 },
            { x: 900, y: H - 280 },
            { x: 1300, y: H - 320 },
            { x: 1700, y: H - 290 },
            { x: 2100, y: H - 310 },
            { x: 2500, y: H - 280 },
            { x: 2900, y: H - 300 },
            { x: 3300, y: H - 290 },
            { x: 3700, y: H - 310 },
          ],
          corals: [
            { x: 600, y: H - 64 },
            { x: 1000, y: H - 64 },
            { x: 1400, y: H - 64 },
            { x: 1800, y: H - 64 },
            { x: 2200, y: H - 64 },
            { x: 2600, y: H - 64 },
            { x: 3000, y: H - 64 },
            { x: 3400, y: H - 64 },
            { x: 3800, y: H - 64 },
          ],
          flag: { x: 4000, y: H - 256 },
        },
        {
          name: "1-7",
          theme: "climb",
          intro: "Mountain Climb 1-7: scale the peaks and reach the summit!",
          goalX: 4200,
          timeLimit: 320,
          groundSegments: 100,
          start: { x: 140, y: H - 140 },
          platforms: [
            { x: 400, y: H - 200, tiles: 2 },
            { x: 700, y: H - 260, tiles: 2 },
            { x: 1000, y: H - 240, tiles: 3 },
            { x: 1400, y: H - 280, tiles: 2 },
            { x: 1800, y: H - 260, tiles: 2 },
            { x: 2200, y: H - 300, tiles: 2 },
            { x: 2600, y: H - 280, tiles: 3 },
            { x: 3000, y: H - 320, tiles: 2 },
            { x: 3400, y: H - 300, tiles: 2 },
            { x: 3800, y: H - 320, tiles: 3 },
          ],
          bricks: [
            { x: 520, y: H - 220, kind: "question", reward: "coin" },
            { x: 568, y: H - 220, kind: "question", reward: "mushroom" },
            { x: 820, y: H - 280, kind: "question", reward: "coin" },
            { x: 868, y: H - 280, kind: "solid" },
            { x: 1120, y: H - 260, kind: "question", reward: "coin" },
            { x: 1168, y: H - 260, kind: "question", reward: "mushroom" },
            { x: 1216, y: H - 260, kind: "question", reward: "coin" },
            { x: 1520, y: H - 300, kind: "question", reward: "coin" },
            { x: 1568, y: H - 300, kind: "question", reward: "coin" },
            { x: 1920, y: H - 280, kind: "question", reward: "mushroom" },
            { x: 2320, y: H - 320, kind: "question", reward: "coin" },
            { x: 2368, y: H - 320, kind: "solid" },
            { x: 2720, y: H - 300, kind: "question", reward: "coin" },
            { x: 2768, y: H - 300, kind: "question", reward: "mushroom" },
            { x: 3120, y: H - 340, kind: "question", reward: "coin" },
            { x: 3168, y: H - 340, kind: "question", reward: "coin" },
            { x: 3520, y: H - 320, kind: "question", reward: "mushroom" },
            { x: 3920, y: H - 340, kind: "question", reward: "coin" },
          ],
          coins: [
            [420, H - 180],
            [460, H - 200],
            [500, H - 220],
            [780, H - 240],
            [820, H - 260],
            [860, H - 240],
            [1080, H - 220],
            [1120, H - 240],
            [1160, H - 220],
            [1480, H - 260],
            [1520, H - 280],
            [1560, H - 260],
            [1880, H - 240],
            [1920, H - 260],
            [1960, H - 240],
            [2280, H - 280],
            [2320, H - 300],
            [2360, H - 280],
            [2680, H - 260],
            [2720, H - 280],
            [2760, H - 260],
            [3080, H - 300],
            [3120, H - 320],
            [3160, H - 300],
            [3480, H - 280],
            [3520, H - 300],
            [3560, H - 280],
            [3880, H - 300],
            [3920, H - 320],
            [3960, H - 300],
          ],
          goombas: [
            { x: 650, y: H - 110 },
            { x: 950, y: H - 110 },
            { x: 1350, y: H - 110 },
            { x: 1750, y: H - 110 },
            { x: 2150, y: H - 110 },
            { x: 2550, y: H - 110 },
            { x: 2950, y: H - 110 },
            { x: 3350, y: H - 110 },
            { x: 3750, y: H - 110 },
          ],
          rocks: [
            { x: 600, y: H - 140, width: 80, height: 120 },
            { x: 1200, y: H - 180, width: 80, height: 160 },
            { x: 2000, y: H - 160, width: 80, height: 140 },
            { x: 2800, y: H - 200, width: 80, height: 180 },
            { x: 3600, y: H - 180, width: 80, height: 160 },
          ],
          flag: { x: 4200, y: H - 256 },
        },
        {
          name: "1-8",
          theme: "snow",
          intro: "Ski Resort 1-8: glide through the snowy slopes and reach the finish!",
          goalX: 4500,
          timeLimit: 300,
          groundSegments: 105,
          start: { x: 120, y: H - 140 },
          platforms: [
            { x: 500, y: H - 180, tiles: 2 },
            { x: 900, y: H - 180, tiles: 2 },
            { x: 1400, y: H - 180, tiles: 2 },
            { x: 1900, y: H - 180, tiles: 2 },
            { x: 2400, y: H - 180, tiles: 2 },
            { x: 3000, y: H - 180, tiles: 2 },
            { x: 3500, y: H - 180, tiles: 2 },
            { x: 4000, y: H - 180, tiles: 2 },
          ],
          bricks: [
            { x: 600, y: H - 200, kind: "question", reward: "coin" },
            { x: 1000, y: H - 200, kind: "question", reward: "mushroom" },
            { x: 1500, y: H - 200, kind: "question", reward: "coin" },
            { x: 2000, y: H - 200, kind: "question", reward: "coin" },
            { x: 2500, y: H - 200, kind: "question", reward: "mushroom" },
            { x: 3100, y: H - 200, kind: "question", reward: "coin" },
            { x: 3600, y: H - 200, kind: "question", reward: "coin" },
            { x: 4100, y: H - 200, kind: "question", reward: "mushroom" },
          ],
          snowPiles: [
            { x: 700, y: H - 104 },
            { x: 1100, y: H - 104 },
            { x: 1600, y: H - 104 },
            { x: 2100, y: H - 104 },
            { x: 2600, y: H - 104 },
            { x: 3200, y: H - 104 },
            { x: 3700, y: H - 104 },
            { x: 4200, y: H - 104 },
          ],
          icePillars: [
            { x: 800, y: H - 144 },
            { x: 1300, y: H - 144 },
            { x: 1800, y: H - 144 },
            { x: 2300, y: H - 144 },
            { x: 2800, y: H - 144 },
            { x: 3300, y: H - 144 },
            { x: 3800, y: H - 144 },
          ],
          coins: [
            [400, H - 180],
            [440, H - 200],
            [480, H - 220],
            [720, H - 220],
            [760, H - 240],
            [800, H - 220],
            [1040, H - 200],
            [1080, H - 220],
            [1120, H - 200],
            [1440, H - 240],
            [1480, H - 260],
            [1520, H - 240],
            [1800, H - 180],
            [1840, H - 200],
            [1880, H - 180],
            [2180, H - 220],
            [2220, H - 240],
            [2260, H - 220],
            [2560, H - 200],
            [2600, H - 220],
            [2640, H - 200],
            [2960, H - 240],
            [3000, H - 260],
            [3040, H - 240],
            [3360, H - 180],
            [3400, H - 200],
            [3440, H - 180],
            [3760, H - 220],
            [3800, H - 240],
            [3840, H - 220],
            [4160, H - 200],
            [4200, H - 220],
            [4240, H - 200],
          ],
          goombas: [
            { x: 600, y: H - 110 },
            { x: 900, y: H - 110 },
            { x: 1300, y: H - 110 },
            { x: 1700, y: H - 110 },
            { x: 2100, y: H - 110 },
            { x: 2500, y: H - 110 },
            { x: 2900, y: H - 110 },
            { x: 3300, y: H - 110 },
            { x: 3700, y: H - 110 },
            { x: 4100, y: H - 110 },
          ],
          skateboards: [
            { x: 600, y: H - 128 },
            { x: 1800, y: H - 128 },
            { x: 3200, y: H - 128 },
          ],
          flag: { x: 4500, y: H - 256 },
        },
      ];

      const levelState = {
        platforms: [],
        entities: [],
        coins: [],
        bricks: [],
        pipes: [],
        powerups: [],
        projectiles: [],
        flag: null,
      };

      function buildLevel(definition) {
        level.platforms = [];
        level.entities = [];
        level.coins = [];
        level.bricks = [];
        level.pipes = [];
        level.powerups = [];
        level.projectiles = [];
        level.skateboards = [];
        level.snowPiles = [];
        level.icePillars = [];
        level.candyObstacles = [];
        level.fallingCandies = [];
        level.pumpkinObstacles = [];
        level.coralObstacles = [];
        level.rockObstacles = [];
        level.trashObstacles = [];
        level.boats = [];
        level.flag = null;
        level.pits = definition.pits ?? [];
        // 只在第四关初始化糖果雨相关属性
        if (definition.theme === "candy") {
          level.candyRainTimer = 0;
          level.candyRainInterval = 0.8 + Math.random() * 0.4; // 0.8-1.2秒生成一个糖果
        } else {
          level.candyRainTimer = 0;
          level.candyRainInterval = Infinity; // 非第四关不生成糖果
        }
        levelCelebration.active = false;
        levelCelebration.papers = [];

        createGround(definition.groundSegments ?? 80, definition.pits ?? []);

        (definition.platforms ?? []).forEach(({ x, y, tiles }) => createPlatform(x, y, tiles));

        (definition.bricks ?? []).forEach(({ x, y, kind, reward }) =>
          level.bricks.push(new Brick(x, y, { kind, reward })),
        );

        (definition.coins ?? []).forEach(([x, y]) => level.coins.push(new Coin(x, y)));

        // 第二关（underground主题）使用Bat，第三关（sky主题）使用Plane，第六关（water主题）使用Shark，第七关（climb主题）使用Monkey，其他关卡使用Goomba
        (definition.bats ?? []).forEach(({ x, y }) => {
          level.entities.push(new Bat(x, y));
        });

        (definition.planes ?? []).forEach(({ x, y }) => {
          level.entities.push(new Plane(x, y));
        });

        // 第六关上层水域的鲨鱼
        (definition.upperSharks ?? []).forEach(({ x, y }) => {
          if (definition.theme === "water") {
            level.entities.push(new Shark(x, y));
          }
        });

        (definition.goombas ?? []).forEach(({ x, y }) => {
          if (definition.theme === "water") {
            level.entities.push(new Shark(x, y));
          } else if (definition.theme === "climb") {
            level.entities.push(new Monkey(x, y));
          } else {
            level.entities.push(new Goomba(x, y));
          }
        });

        // 管道功能已禁用
        // (definition.pipes ?? []).forEach(({ x, y, width, height, warpTo }) =>
        //   level.pipes.push(new Pipe(x, y, width, height, { warpTo })),
        // );

        (definition.skateboards ?? []).forEach(({ x, y }) =>
          level.skateboards.push(new Skateboard(x, y)),
        );

        (definition.snowPiles ?? []).forEach(({ x, y }) =>
          level.snowPiles.push(new SnowPile(x, y)),
        );

        (definition.icePillars ?? []).forEach(({ x, y }) =>
          level.icePillars.push(new IcePillar(x, y)),
        );

        (definition.pumpkins ?? []).forEach(({ x, y }) =>
          level.pumpkinObstacles.push(new PumpkinObstacle(x, y)),
        );

        (definition.corals ?? []).forEach(({ x, y }) =>
          level.coralObstacles.push(new CoralObstacle(x, y)),
        );

        (definition.rocks ?? []).forEach(({ x, y, width, height }) =>
          level.rockObstacles.push(new RockObstacle(x, y, width, height)),
        );

        (definition.trash ?? []).forEach(({ x, y }) =>
          level.trashObstacles.push(new TrashObstacle(x, y)),
        );

        (definition.boats ?? []).forEach(({ x, y }) =>
          level.boats.push(new Boat(x, y)),
        );

        (definition.candyObstacles ?? []).forEach(({ x, y }) =>
          level.candyObstacles.push(new CandyObstacle(x, y)),
        );

        if (definition.flag) {
          level.flag = new Flag(definition.flag.x, definition.flag.y);
        }
      }

      class Pipe extends Entity {
        constructor(x, y, width, height, { warpTo = null } = {}) {
          super(x, y, width, height);
          this.warpTo = warpTo;
        }
      }

      const player = new Player(120, world.height - 140);
      let elapsedTime = 0;
      let running = true;
      let currentLevelIndex = 0;
      let pendingLevelTimer = null;
      let currentLevelCoins = 0; // 当前关卡收集的金币数
      let currentLevelImpact = 0; // 当前关卡已贡献的Impact factor
      let levelImpacts = new Array(8).fill(0); // 跟踪每个关卡已贡献的Impact factor（8个关卡）

      function loadLevel(index, { resetStats = false, showIntro = true, respawn = false } = {}) {
        if (pendingLevelTimer) {
          clearTimeout(pendingLevelTimer);
          pendingLevelTimer = null;
        }
        const definition = levelDefinitions[index];
        if (!definition) return;
        currentLevelIndex = index;
        applyTheme(definition.theme);
        world.goalX = definition.goalX;
        world.timeLimit = definition.timeLimit;
        world.camera.x = 0;
        buildLevel(definition);
        
        // 重置当前关卡的金币计数（每次加载新关卡时）
        currentLevelCoins = 0;
        // 从永久记录中恢复当前关卡的Impact factor（如果已经达到上限，则不再增长）
        currentLevelImpact = levelImpacts[index] || 0;

        if (resetStats) {
          player.score = 0;
          player.coins = 0;
          player.impactFactor = 0;
          currentLevelCoins = 0;
          currentLevelImpact = 0;
          // 重置所有关卡的Impact factor记录
          levelImpacts = new Array(8).fill(0);
          hudScore.textContent = "000000";
          hudCoins.textContent = "×00";
          player.setSize("small", { silent: true });
          player.extraLives = 0;
          player.ammo = 0;
          player.collectibles = 0;
          updateAmmoHUD();
        } else {
          hudScore.textContent = player.score.toString().padStart(6, "0");
          hudCoins.textContent = `×${player.coins.toString().padStart(2, "0")}`;
          if (respawn) {
            player.setSize("small", { silent: true });
          } else {
            player.updateDimensions(player.size);
          }
          updateAmmoHUD();
        }

        const start = definition.start ?? { x: 120, y: world.height - 140 };
        player.x = start.x;
        player.y = start.y;
        player.vx = 0;
        player.vy = 0;
        // 水下关卡：玩家从水中开始，不在地面上
        if (definition.theme === "water") {
        player.onGround = false;
          // 初始位置稍微上浮一点，让玩家从水中开始
          if (player.y > world.height - 100) {
            player.y = world.height - 200; // 确保玩家在水中，而不是在水底
          }
        } else {
          player.onGround = false;
        }
        player.invincibleTimer = 0;
        player.onSkateboard = false;
        player.skateboardTimer = 0;
        player.onBoat = false;
        player.currentBoat = null;
        player.lastBoat = null;
        
        // 第9关：玩家出场时就在第一艘船上
        if (definition.theme === "boat" && level.boats.length > 0) {
          const firstBoat = level.boats[0];
          // 将玩家放在第一艘船上
          player.x = firstBoat.x + firstBoat.width / 2 - player.width / 2;
          player.y = firstBoat.y - player.height;
          player.onBoat = true;
          player.currentBoat = firstBoat;
          player.onGround = true;
          player.vx = 0;
          player.vy = 0;
        }
        elapsedTime = 0;
        running = true;
        hudWorld.textContent = definition.name ?? `1-${index + 1}`;
        hudTime.textContent = `${world.timeLimit}`.padStart(3, "0");

        // 更新关卡选择器
        const levelSelect = document.getElementById("level-select");
        if (levelSelect) {
          levelSelect.value = index.toString();
        }

        if (definition.intro && showIntro) {
          showToast(definition.intro, 1800);
        }
      }

      function resetGame({ showMessage = true, startLevel = 0 } = {}) {
        const levelIndex = clamp(startLevel, 0, levelDefinitions.length - 1);
        loadLevel(levelIndex, { resetStats: true, showIntro: !showMessage });
        if (showMessage) {
          if (levelIndex === 0) {
            showToast("Back to 1-1—research adventure rebooted!", 1600);
          } else {
            showToast(`Warped straight to ${levelDefinitions[levelIndex].name}!`, 1500);
          }
        }
      }

      function restartCurrentLevel() {
        if (currentLevelIndex < 0 || currentLevelIndex >= levelDefinitions.length) return;
        const levelName = levelDefinitions[currentLevelIndex].name;
        loadLevel(currentLevelIndex, { resetStats: false, showIntro: false, respawn: false });
        showToast(`${levelName} restarted!`, 1200);
      }

      function tryEnterPipe() {
        // 管道功能已禁用
        return false;
      }

      function enterPipe(pipe) {
        // 管道功能已禁用
        return;
      }

      function applyTheme(themeKey) {
        const themes = {
          surface: {
            sky: ["#9cd3ff", "#d4efff"],
            isUnderground: false,
            hillLight: "rgba(105, 193, 128, 0.78)",
            hillDark: "rgba(86, 175, 104, 0.8)",
            cloud: "#74aaff",
            groundTop: "#6f4c2f",
            groundBody: "#905c36",
            groundStripe: "#5a462f",
            platformTop: "#c45f24",
            platformBody: "#e17844",
          },
          underground: {
            sky: ["#1b1a2f", "#0f0d1c"],
            isUnderground: true,
            hillLight: null,
            hillDark: null,
            cloud: null,
            groundTop: "#3d3a54",
            groundBody: "#25223a",
            groundStripe: "#18152b",
            platformTop: "#5a4d82",
            platformBody: "#403765",
          },
          sky: {
            sky: ["#87b9ff", "#dbe9ff"],
            isUnderground: false,
            hillLight: "rgba(224, 244, 255, 0.8)",
            hillDark: "rgba(176, 216, 255, 0.6)",
            cloud: "#ffffff",
            groundTop: "#d5e6ff",
            groundBody: "#b0c9ff",
            groundStripe: "#94afe7",
            platformTop: "#f3f6ff",
            platformBody: "#d0ddff",
          },
          candy: {
            sky: ["#ffe6f4", "#fff8e8"],
            isUnderground: false,
            hillLight: "rgba(255, 209, 220, 0.75)",
            hillDark: "rgba(255, 182, 193, 0.75)",
            cloud: "#ffffff",
            groundTop: "#f8a5c2",
            groundBody: "#ffb8d2",
            groundStripe: "#f582a7",
            platformTop: "#ffd1dc",
            platformBody: "#ff9ec4",
          },
          ghost: {
            sky: ["#2d1b3d", "#1a0f26"],
            isUnderground: true,
            hillLight: null,
            hillDark: null,
            cloud: null,
            groundTop: "#4a3a5a",
            groundBody: "#3a2d4a",
            groundStripe: "#2a1f3a",
            platformTop: "#6b5b7b",
            platformBody: "#5a4a6a",
          },
          water: {
            sky: ["#1a4a6a", "#0d2d4a"],
            isUnderground: true,
            hillLight: null,
            hillDark: null,
            cloud: null,
            groundTop: "#2d5a7a",
            groundBody: "#1d3a5a",
            groundStripe: "#0d2a4a",
            platformTop: "#4d7a9a",
            platformBody: "#3d6a8a",
          },
          climb: {
            sky: ["#87ceeb", "#e0f6ff"],
            isUnderground: false,
            hillLight: "rgba(120, 120, 130, 0.8)",
            hillDark: "rgba(100, 100, 110, 0.8)",
            cloud: "#ffffff",
            groundTop: "#8b7355",
            groundBody: "#6b5a45",
            groundStripe: "#5a4a35",
            platformTop: "#9b8a6a",
            platformBody: "#7b6a5a",
          },
          snow: {
            sky: ["#b8d4f0", "#e8f4ff"],
            isUnderground: false,
            hillLight: "rgba(240, 240, 250, 0.9)",
            hillDark: "rgba(220, 220, 230, 0.9)",
            cloud: "#ffffff",
            groundTop: "#f0f8ff",
            groundBody: "#e0e8f0",
            groundStripe: "#d0d8e0",
          },
          boat: {
            sky: ["#87ceeb", "#b0d4e8"],
            isUnderground: false,
            hillLight: null,
            hillDark: null,
            cloud: "#ffffff",
            groundTop: "#4a90c2",
            groundBody: "#3a7aa2",
            groundStripe: "#2a6a92",
            platformTop: "#ffffff",
            platformBody: "#f0f0f8",
          },
          research: {
            sky: ["#e8f0f8", "#d0e0f0"],
            isUnderground: false,
            hillLight: "rgba(200, 210, 220, 0.6)",
            hillDark: "rgba(180, 190, 200, 0.6)",
            cloud: "#c0d0e0",
            groundTop: "#a0a8b0",
            groundBody: "#808890",
            groundStripe: "#707880",
            platformTop: "#b0b8c0",
            platformBody: "#9098a0",
          },
        };
        const selected = themes[themeKey] ?? themes.surface;
        activeTheme = { ...selected, key: themeKey };
        
        // 水下关卡调整重力
        if (themeKey === "water") {
          world.gravity = 600; // 水下重力更小
          world.friction = 0.86; // 恢复正常摩擦力
        } else if (themeKey === "snow") {
          world.gravity = 1600; // 正常重力
          world.friction = 0.92; // 滑雪场摩擦力更低（更滑）
        } else {
          world.gravity = 1600; // 恢复正常重力
          world.friction = 0.86; // 恢复正常摩擦力
        }
      }

      function completeLevel() {
        if (!running) return;
        running = false;
        player.addScore(400);
        const nextIndex = currentLevelIndex + 1;
        if (nextIndex < levelDefinitions.length) {
          showToast(`Flag reached! Heading to ${levelDefinitions[nextIndex].name}`, 2200);
          pendingLevelTimer = setTimeout(() => {
            pendingLevelTimer = null;
            loadLevel(nextIndex);
          }, 1200);
        } else {
          levelCelebration.spawn();
          showToast("Candy house fireworks! CNS publication secured!", 2600);
        }
      }

      function handleCollisions() {
        player.onGround = false;
        
        // 检查玩家与船的碰撞（仅在boat主题关卡）
        const isBoat = levelDefinitions[currentLevelIndex] && levelDefinitions[currentLevelIndex].theme === "boat";
        if (isBoat) {
          // 先检查玩家是否在船上（玩家站在船的上方）
          let onBoat = false;
          for (const boat of level.boats) {
            // 检查玩家是否在船的范围内（水平方向，放宽范围以便更容易跳到船上）
            const isHorizontallyOverBoat = player.right > boat.x - 20 && player.left < boat.x + boat.width + 20;
            
            // 检查玩家是否在船的上方（垂直方向，允许更大的范围以便跳跃后落在船上）
            const isVerticallyOverBoat = player.bottom >= boat.y - 25 && player.bottom <= boat.y + 40;
            
            // 检查玩家是否正在下降或静止（或者已经在船上），放宽条件以便更容易跳到船上
            // 只要玩家在船的垂直范围内且水平重叠，就允许跳到船上
            const isDescendingOrOnBoat = player.vy >= -150 || player.onBoat || (player.bottom <= boat.y + 10);
            
            if (isHorizontallyOverBoat && isVerticallyOverBoat && isDescendingOrOnBoat) {
              // 玩家站在船上
              player.onBoat = true;
              player.currentBoat = boat;
              player.lastBoat = null; // 清除lastBoat，因为已经在船上了
              player.onGround = true;
              // 如果玩家从上方落下，调整位置到船顶部
              if (player.bottom > boat.y) {
                player.y = boat.y - player.height;
                player.vy = 0;
              }
              // 如果玩家正在下降，停止下降
              if (player.vy > 0) {
                player.vy = 0;
              }
              // 保持玩家的水平位置（不强制居中），允许玩家在船边缘以便跳到前方船
              // 但确保玩家在船内
              const boatLeft = boat.x + 2;
              const boatRight = boat.x + boat.width - 2;
              player.x = clamp(player.x, boatLeft, boatRight - player.width);
              onBoat = true;
              break;
            }
          }
          
          // 如果玩家不在船上，清除船上状态（但保留lastBoat用于船跟随）
          if (!onBoat) {
            player.onBoat = false;
            player.currentBoat = null;
            // lastBoat保留，用于在障碍物上时让船跟随
          }
        }
        
        // 重置所有Goomba的onGround状态
        level.entities.forEach((entity) => {
          if (entity instanceof Goomba) {
            entity.onGround = false;
          }
        });
        const entities = [player, ...level.entities, ...level.powerups];
        const colliders = [...level.platforms, ...level.bricks, ...level.skateboards, ...level.snowPiles, ...level.icePillars, ...level.pumpkinObstacles, ...level.coralObstacles, ...level.rockObstacles, ...level.trashObstacles];

        entities.forEach((entity) => {
          colliders.forEach((platform) => {
            if (
              entity.right > platform.x &&
              entity.left < platform.x + platform.width &&
              entity.bottom > platform.y &&
              entity.top < platform.y + platform.height
            ) {
              const overlapX =
                entity.vx > 0
                  ? platform.x - entity.right
                  : platform.x + platform.width - entity.left;
              const overlapY =
                entity.vy > 0
                  ? platform.y - entity.bottom
                  : platform.y + platform.height - entity.top;

              const horizontalCollision = Math.abs(overlapX) < Math.abs(overlapY);
              if (horizontalCollision) {
                if (entity === player) {
                  // 垃圾障碍物：玩家碰到会后退
                  if (platform instanceof TrashObstacle) {
                    // 让玩家后退
                    const pushBackSpeed = 300; // 后退速度
                    if (overlapX > 0) {
                      // 玩家从右侧碰到，向左后退
                      player.vx = -pushBackSpeed;
                    } else {
                      // 玩家从左侧碰到，向右后退
                      player.vx = pushBackSpeed;
                    }
                    // 稍微向上弹起
                    if (player.vy > -100) {
                      player.vy = -150;
                    }
                    showToast("Watch out! Trash obstacle!", 1000);
                    return; // 跳过后续碰撞处理
                  }
                  
                  // 岩石攀爬逻辑：如果玩家接触岩石侧面，可以向上攀爬
                  if (platform instanceof RockObstacle) {
                    const isClimbing = (keyState.has("ArrowUp") || keyState.has("KeyW")) && 
                                      player.top < platform.y + platform.height && 
                                      player.bottom > platform.y;
                    if (isClimbing) {
                      // 允许玩家向上攀爬
                      player.vy = -150; // 攀爬速度
                      // 不阻止水平移动，让玩家可以沿着岩石边缘攀爬
                      return; // 跳过后续碰撞处理
                    } else {
                      // 如果不攀爬，正常处理碰撞（阻止水平移动）
                      entity.x += overlapX;
                      if (entity instanceof Shark) {
                        entity.directionX *= -1;
                        entity.vx = entity.directionX * entity.swimSpeedX;
                        if (Math.random() > 0.5) {
                          entity.directionY *= -1;
                        }
                      } else if (entity instanceof Bat) {
                        if (Math.random() > 0.5) {
                          entity.directionX *= -1;
                        }
                        if (Math.random() > 0.5) {
                          entity.directionY *= -1;
                        }
                        entity.vx = entity.directionX * entity.flySpeedX;
                        entity.vy = entity.directionY * entity.flySpeedY;
                      } else if (entity instanceof Plane) {
                        entity.direction *= -1;
                        entity.vx = entity.direction * entity.horizontalSpeed;
                      } else if (entity instanceof Monkey || entity instanceof Goomba || entity instanceof Mushroom) {
                        entity.direction *= -1;
                        entity.vx = entity.direction * entity.walkSpeed;
                      } else {
                        entity.vx = 0;
                      }
                      return;
                    }
                  }
                  
                  const platformTop = platform.y;
                  const playerBottom = player.bottom;
                  const stepHeight = platformTop - playerBottom;
                  const canStep =
                    stepHeight > -26 &&
                    stepHeight <= 0 &&
                    player.vy >= -40 &&
                    playerBottom >= platformTop - 32;
                  if (canStep) {
                    player.y = platformTop - player.height;
                    // 水下关卡：玩家不"站在"平台上，而是悬浮在水中
                    const isWater = levelDefinitions[currentLevelIndex] && levelDefinitions[currentLevelIndex].theme === "water";
                    if (!isWater) {
                    player.onGround = true;
                    player.vy = 0;
                    } else {
                      // 水下时，玩家可以继续上下移动，不锁定在平台上
                      // 但允许玩家"站在"平台上（通过浮力平衡）
                      if (player.vy > 0) {
                        player.vy = 0; // 如果向下移动，停止下沉
                      }
                    }
                    // 检查是否站在障碍物上
                    if ((platform instanceof PumpkinObstacle || platform instanceof CoralObstacle) && player.invincibleTimer === 0) {
                      let message = "Ouch! Hit an obstacle!";
                      if (platform instanceof PumpkinObstacle) {
                        message = "Ouch! Hit a pumpkin obstacle!";
                      } else if (platform instanceof CoralObstacle) {
                        message = "Ouch! Hit a coral obstacle!";
                      }
                      if (player.size === "big") {
                        player.setSize("small");
                        player.invincibleTimer = 2.2;
                        updateAmmoHUD();
                        showToast(message, 1200);
                      } else if (player.extraLives > 0) {
                        player.extraLives -= 1;
                        updateAmmoHUD();
                        showToast("Obstacle hit! Backup life activated...", 1600);
                        loadLevel(currentLevelIndex, { respawn: true, showIntro: false });
                        return;
                      } else {
                        running = false;
                        showToast("Hit an obstacle—restarting level...", 1600);
                        setTimeout(() => loadLevel(currentLevelIndex, { respawn: true, showIntro: false }), 180);
                        return;
                      }
                    }
                    return;
                  }
                }
                entity.x += overlapX;
                if (entity instanceof Shark) {
                  // 鲨鱼在水中遇到障碍时改变方向，但可以上下游动绕过
                  entity.directionX *= -1;
                  entity.vx = entity.directionX * entity.swimSpeedX;
                  // 有时也改变垂直方向，尝试绕过障碍
                  if (Math.random() > 0.5) {
                    entity.directionY *= -1;
                  }
                } else if (entity instanceof Bat) {
                  // 蝙蝠遇到障碍时改变方向
                  if (Math.random() > 0.5) {
                    entity.directionX *= -1;
                  }
                  if (Math.random() > 0.5) {
                    entity.directionY *= -1;
                  }
                  entity.vx = entity.directionX * entity.flySpeedX;
                  entity.vy = entity.directionY * entity.flySpeedY;
                } else if (entity instanceof Plane) {
                  // 飞机遇到障碍时改变水平方向
                  entity.direction *= -1;
                  entity.vx = entity.direction * entity.horizontalSpeed;
                } else if (entity instanceof Monkey || entity instanceof Goomba || entity instanceof Mushroom) {
                  entity.direction *= -1;
                  entity.vx = entity.direction * entity.walkSpeed;
                } else {
                  entity.vx = 0;
                }
              } else {
                entity.y += overlapY;
                if (entity instanceof Shark) {
                  // 鲨鱼在水中遇到上下障碍时改变垂直方向
                  entity.directionY *= -1;
                  entity.vy = entity.directionY * entity.swimSpeedY;
                } else if (entity instanceof Bat) {
                  // 蝙蝠遇到上下障碍时改变垂直方向
                  entity.directionY *= -1;
                  entity.vy = entity.directionY * entity.flySpeedY;
                } else if (entity instanceof Plane) {
                  // 飞机遇到上下障碍时，如果在地面则起飞，如果在空中则降落
                  if (entity.state === "taxiing" || entity.state === "landing") {
                    entity.state = "takingOff";
                    entity.taxiingTimer = 0;
                  } else if (entity.state === "flying" || entity.state === "takingOff") {
                    entity.state = "landing";
                    entity.flyingTimer = 0;
                  }
                } else if (entity instanceof Monkey) {
                  // 猴子落地时设置onGround状态
                entity.vy = 0;
                  entity.onGround = true;
                } else if (entity instanceof Goomba) {
                  // Goomba落地时设置onGround状态（用于边缘检测）
                  if (overlapY < 0) {
                    entity.vy = 0;
                    entity.onGround = true;
                  }
                } else {
                  entity.vy = 0;
                }
                if (entity === player) {
                  if (overlapY < 0) {
                    // 岩石顶部：玩家可以站在上面，也可以从另一侧跳下来
                    if (platform instanceof RockObstacle) {
                      player.y = platform.y - player.height;
                    player.onGround = true;
                      player.vy = 0;
                      // 允许玩家从岩石顶部跳下来（不阻止水平移动）
                      return;
                    }
                    // 水下关卡：玩家不"站在"平台上，而是悬浮在水中
                    const isWater = levelDefinitions[currentLevelIndex] && levelDefinitions[currentLevelIndex].theme === "water";
                    const isBoatLevel = levelDefinitions[currentLevelIndex] && levelDefinitions[currentLevelIndex].theme === "boat";
                    if (isBoatLevel) {
                      // 第9关：玩家可以站在平台上（从船上跳起后可以落在平台上）
                      // 但玩家在平台上时不能水平移动，只能等待回到船上或继续跳跃
                      player.onGround = true;
                      player.vy = 0;
                    } else if (!isWater) {
                      player.onGround = true;
                      player.vy = 0;
                    } else {
                      // 水下时，玩家可以继续上下移动，不锁定在平台上
                      if (player.vy > 0) {
                        player.vy = 0; // 如果向下移动，停止下沉
                      }
                    }
                    // 检查是否站在障碍物上
                    if ((platform instanceof PumpkinObstacle || platform instanceof CoralObstacle) && player.invincibleTimer === 0) {
                      let message = "Ouch! Hit an obstacle!";
                      if (platform instanceof PumpkinObstacle) {
                        message = "Ouch! Hit a pumpkin obstacle!";
                      } else if (platform instanceof CoralObstacle) {
                        message = "Ouch! Hit a coral obstacle!";
                      }
                      if (player.size === "big") {
                        player.setSize("small");
                        player.invincibleTimer = 2.2;
                        updateAmmoHUD();
                        showToast(message, 1200);
                      } else if (player.extraLives > 0) {
                        player.extraLives -= 1;
                        updateAmmoHUD();
                        showToast("Obstacle hit! Backup life activated...", 1600);
                        loadLevel(currentLevelIndex, { respawn: true, showIntro: false });
                        return;
                      } else {
                        running = false;
                        showToast("Hit an obstacle—restarting level...", 1600);
                        setTimeout(() => loadLevel(currentLevelIndex, { respawn: true, showIntro: false }), 180);
                        return;
                      }
                    }
                  } else if (overlapY > 0) {
                    const brick = level.bricks.find((b) => b === platform);
                    if (brick) brick.trigger(player);
                  } else {
                    // 水平碰撞，检查是否碰到障碍物
                    if ((platform instanceof PumpkinObstacle || platform instanceof CoralObstacle) && player.invincibleTimer === 0) {
                      let message = "Ouch! Hit an obstacle!";
                      if (platform instanceof PumpkinObstacle) {
                        message = "Ouch! Hit a pumpkin obstacle!";
                      } else if (platform instanceof CoralObstacle) {
                        message = "Ouch! Hit a coral obstacle!";
                      }
                      if (player.size === "big") {
                        player.setSize("small");
                        player.invincibleTimer = 2.2;
                        updateAmmoHUD();
                        showToast(message, 1200);
                      } else if (player.extraLives > 0) {
                        player.extraLives -= 1;
                        updateAmmoHUD();
                        showToast("Obstacle hit! Backup life activated...", 1600);
                        loadLevel(currentLevelIndex, { respawn: true, showIntro: false });
                        return;
                      } else {
                        running = false;
                        showToast("Hit an obstacle—restarting level...", 1600);
                        setTimeout(() => loadLevel(currentLevelIndex, { respawn: true, showIntro: false }), 180);
                        return;
                      }
                    }
                  }
                }
              }
            }
          });
        });
      }

      function handleEntityInteractions(dt) {
        level.entities.forEach((entity) => {
          if ((entity instanceof Goomba || entity instanceof Shark || entity instanceof Monkey || entity instanceof Bat || entity instanceof Plane) && !entity.removed) {
            if (
              player.right > entity.left &&
              player.left < entity.right &&
              player.bottom > entity.top &&
              player.top < entity.bottom
            ) {
              if (player.vy > 120 && player.bottom - entity.top < 20) {
                entity.squash();
                player.bounce();
                player.addScore(100);
                let message = "Goomba squashed! +100 points!";
                if (entity instanceof Shark) {
                  message = "Shark defeated! +100 points!";
                } else if (entity instanceof Monkey) {
                  message = "Monkey defeated! +100 points!";
                } else if (entity instanceof Bat) {
                  message = "Bat defeated! +100 points!";
                } else if (entity instanceof Plane) {
                  message = "Plane defeated! +100 points!";
                }
                showToast(message, 1000);
              } else if (player.invincibleTimer === 0) {
                if (player.size === "big") {
                  player.setSize("small");
                  player.invincibleTimer = 2.2;
                  updateAmmoHUD();
                } else if (player.extraLives > 0) {
                  player.extraLives -= 1;
                  updateAmmoHUD();
                  showToast("Backup life activated—back to the lab!", 1600);
                  loadLevel(currentLevelIndex, { respawn: true, showIntro: false });
                  return;
                } else {
                  running = false;
                  showToast("Out of lives—restarting current level...", 1600);
                  setTimeout(() => loadLevel(currentLevelIndex, { respawn: true, showIntro: false }), 180);
                  return;
                }
              }
            }
          }
        });

        level.projectiles = level.projectiles.filter((fireball) => {
          if (fireball.life <= 0) return false;
          let hit = false;
          level.entities.forEach((entity) => {
            if ((entity instanceof Goomba || entity instanceof Shark || entity instanceof Monkey || entity instanceof Bat || entity instanceof Plane) && !entity.removed) {
              const marginX = 18;
              const marginY = 18;
              const xOverlap =
                fireball.right > entity.left - marginX &&
                fireball.left < entity.right + marginX;
              const yOverlap =
                fireball.bottom > entity.top - marginY &&
                fireball.top < entity.bottom + marginY;
              if (xOverlap && yOverlap) {
                entity.squash();
                entity.removed = true;
                fireball.life = 0;
                player.addScore(150);
                hit = true;
              }
            }
          });
          return fireball.life > 0 && !hit;
        });

        level.powerups.forEach((powerup) => {
          if (
            player.right > powerup.left &&
            player.left < powerup.right &&
            player.bottom > powerup.top &&
            player.top < powerup.bottom
          ) {
            powerup.removed = true;
            player.grow();
            player.addScore(1000);
            updateAmmoHUD();
          }
        });

        level.powerups = level.powerups.filter((powerup) => !powerup.removed);

        level.coins.forEach((coin) => {
          if (
            player.right > coin.left &&
            player.left < coin.right &&
            player.bottom > coin.top &&
            player.top < coin.bottom
          ) {
            coin.removed = true;
            player.addCoin();
            updateAmmoHUD();
          }
        });

        level.coins = level.coins.filter((coin) => !coin.removed);

        // 滑板收集
        level.skateboards.forEach((skateboard) => {
          if (
            player.right > skateboard.left &&
            player.left < skateboard.right &&
            player.bottom > skateboard.top &&
            player.top < skateboard.bottom
          ) {
            skateboard.removed = true;
            player.onSkateboard = true;
            player.skateboardTimer = 0;
            player.addScore(500);
            showToast("Skateboard collected! Dash through enemies!", 1600);
          }
        });

        level.skateboards = level.skateboards.filter((skateboard) => !skateboard.removed);

        // 滑板冲走敌人
        if (player.onSkateboard && Math.abs(player.vx) > 200) {
          level.entities.forEach((entity) => {
            if ((entity instanceof Goomba || entity instanceof Shark || entity instanceof Monkey || entity instanceof Bat || entity instanceof Plane) && !entity.removed) {
              const marginX = 30;
              const marginY = 20;
              const xOverlap =
                player.right > entity.left - marginX &&
                player.left < entity.right + marginX;
              const yOverlap =
                player.bottom > entity.top - marginY &&
                player.top < entity.bottom + marginY;
              if (xOverlap && yOverlap) {
                // 冲走敌人
                entity.removed = true;
                entity.squash();
                player.addScore(200);
                showToast("Skateboard dash! Enemy knocked out!", 1000);
              }
            }
          });
        }
      }

      function update(dt) {
        if (!running) return;

        elapsedTime += dt;
        const timeRemaining = Math.max(0, Math.floor(world.timeLimit - elapsedTime));
        hudTime.textContent = timeRemaining.toString().padStart(3, "0");
        if (timeRemaining === 0) {
          if (player.extraLives > 0) {
            player.extraLives -= 1;
            updateAmmoHUD();
            showToast("Backup life triggered—timer reset!", 1600);
            loadLevel(currentLevelIndex, { respawn: true, showIntro: false });
            return;
          }
          running = false;
          showToast("Time's up—restarting current level...", 1600);
          setTimeout(() => loadLevel(currentLevelIndex, { respawn: true, showIntro: false }), 180);
          return;
        }

        player.update(dt);
        level.entities.forEach((entity) => entity.update(dt));
        level.bricks.forEach((brick) => brick.update(dt));
        level.coins.forEach((coin) => coin.update(dt));
        level.powerups.forEach((powerup) => powerup.update(dt));
        level.projectiles.forEach((projectile) => projectile.update(dt));
        level.skateboards.forEach((skateboard) => skateboard.update(dt));
        if (level.pumpkinObstacles) {
          level.pumpkinObstacles.forEach((pumpkin) => pumpkin.update(dt));
        }
        if (level.coralObstacles) {
          level.coralObstacles.forEach((coral) => coral.update(dt));
        }
        if (level.rockObstacles) {
          level.rockObstacles.forEach((rock) => rock.update(dt));
        }
        if (level.trashObstacles) {
          level.trashObstacles.forEach((trash) => trash.update(dt));
        }
        
        // 糖果雨系统（只在第四关）
        if (currentLevelIndex === 3 && level.fallingCandies && level.candyRainTimer !== undefined) {
          level.candyRainTimer += dt;
          if (level.candyRainTimer >= level.candyRainInterval) {
            // 从天空随机位置生成糖果
            const spawnX = world.camera.x + Math.random() * canvas.width;
            const spawnY = -50;
            level.fallingCandies.push(new FallingCandy(spawnX, spawnY));
            level.candyRainTimer = 0;
            level.candyRainInterval = 0.8 + Math.random() * 0.4; // 重置间隔
          }
          
          // 更新掉落糖果
          if (level.fallingCandies) {
            level.fallingCandies.forEach((candy) => candy.update(dt));
            level.fallingCandies = level.fallingCandies.filter((candy) => !candy.removed);
            
            // 检测玩家与掉落糖果的碰撞
            for (let i = 0; i < level.fallingCandies.length; i++) {
              const candy = level.fallingCandies[i];
              if (
                player.right > candy.left &&
                player.left < candy.right &&
                player.bottom > candy.top &&
                player.top < candy.bottom
              ) {
                // 被糖果砸到就死了
                if (player.extraLives > 0) {
                  player.extraLives -= 1;
                  updateAmmoHUD();
                  showToast("Hit by falling candy! Backup life activated...", 1600);
                  loadLevel(currentLevelIndex, { respawn: true, showIntro: false });
                  return;
                } else {
                  running = false;
                  showToast("Hit by falling candy—restarting level...", 1600);
                  setTimeout(() => loadLevel(currentLevelIndex, { respawn: true, showIntro: false }), 180);
                  return;
                }
              }
            }
          }
        }
        
        if (level.flag) {
          level.flag.update(dt);
        }

        handleCollisions();
        handleEntityInteractions(dt);
        level.entities = level.entities.filter((entity) => !entity.removed);
        level.projectiles = level.projectiles.filter(
          (projectile) =>
            projectile.life > 0 &&
            projectile.x > -100 &&
            projectile.x < world.goalX + 200,
        );

        world.camera.x = clamp(
          player.x - canvas.width / 2,
          0,
          world.goalX - canvas.width + 200,
        );

        if (player.x >= world.goalX - 40) {
          completeLevel();
        }

        // Check if player fell into a pit (only for level 1-1)
        if (currentLevelIndex === 0 && level.pits && level.pits.length > 0) {
          const playerInPit = level.pits.some(pit => {
            return player.x < pit.x + pit.width && player.x + player.width > pit.x;
          });
          
          // Player is in a pit and has fallen below ground level
          if (playerInPit && player.y > world.height - 64 && !player.onGround) {
            if (player.extraLives > 0) {
              player.extraLives -= 1;
              updateAmmoHUD();
              showToast("Fell into a pit! Backup life activated...", 1600);
              loadLevel(currentLevelIndex, { respawn: true, showIntro: false });
              return;
            }
            running = false;
            showToast("Fell into a pit—restarting level...", 1600);
            setTimeout(() => loadLevel(currentLevelIndex, { respawn: true, showIntro: false }), 180);
            return;
          }
        }

        // 第9关：如果玩家不在船上且掉到水里，死亡
        // 注意：这个检测在 handleCollisions() 之后，所以 player.onGround 已经被正确设置
        const isBoatLevel = levelDefinitions[currentLevelIndex] && levelDefinitions[currentLevelIndex].theme === "boat";
        if (isBoatLevel && !player.onBoat) {
          // 水面高度约为 world.height - 104
          const waterLevel = world.height - 104;
          
          // 只有当玩家不在平台上（!player.onGround），不在船上，且玩家的中心点在水面以下，且正在下落时才触发死亡
          // 如果玩家在平台上（player.onGround = true），就不会触发死亡
          // 使用玩家的中心点而不是底部，避免在跳跃过程中误判
          const playerCenterY = player.y + player.height / 2;
          if (!player.onGround && player.vy > 50 && playerCenterY > waterLevel) {
            // 玩家掉到水里（只有在明显下落速度时才触发，避免在平台上误判）
            if (player.size === "big") {
              player.setSize("small");
              player.invincibleTimer = 2.2;
              updateAmmoHUD();
              showToast("Fell into water—shrunk down!", 1200);
            } else if (player.extraLives > 0) {
              player.extraLives -= 1;
              updateAmmoHUD();
              showToast("Fell into water! Backup life activated...", 1600);
              loadLevel(currentLevelIndex, { respawn: true, showIntro: false });
              return;
            } else {
              running = false;
              showToast("Fell into water—restarting level...", 1600);
              setTimeout(() => loadLevel(currentLevelIndex, { respawn: true, showIntro: false }), 180);
              return;
            }
          }
        }
        
        if (player.y > world.height + 160) {
          if (player.extraLives > 0) {
            player.extraLives -= 1;
            updateAmmoHUD();
          showToast("Backup life to the rescue—watch your footing!", 1600);
            loadLevel(currentLevelIndex, { respawn: true, showIntro: false });
            return;
          }
          running = false;
          showToast("Fell into the abyss—restarting current level...", 1600);
          setTimeout(() => loadLevel(currentLevelIndex, { respawn: true, showIntro: false }), 180);
          return;
        }
      }

      function drawBackground() {
        const cameraX = world.camera.x;
        
        // 第二关（地下关卡）：根据玩家位置绘制明亮背景
        if (activeTheme.isUnderground && currentLevelIndex === 1) {
          // 先绘制暗色背景
          const darkGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
          darkGradient.addColorStop(0, activeTheme.sky[0]);
          darkGradient.addColorStop(1, activeTheme.sky[1]);
          ctx.fillStyle = darkGradient;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // 在玩家前方绘制明亮的圆形光照区域
          const playerScreenX = player.x - world.camera.x;
          const playerScreenY = player.y + player.height / 2;
          const lightDistance = 350; // 光照距离
          const lightRadius = 200; // 圆形光照半径
          
          // 计算光照中心位置（玩家前方）
          const lightCenterX = playerScreenX + (player.facing > 0 ? player.width / 2 + lightDistance / 2 : -player.width / 2 - lightDistance / 2);
          const lightCenterY = playerScreenY;
          
          // 创建明亮的背景区域（圆形，均匀一致的亮色）
          // 先绘制均匀的亮色圆形区域
          ctx.fillStyle = "#f5f5e8"; // 均匀一致的亮米色
          ctx.beginPath();
          ctx.arc(lightCenterX, lightCenterY, lightRadius, 0, Math.PI * 2);
          ctx.fill();
          
          // 在边缘添加一个小的过渡区域，使边缘更自然
          const edgeGradient = ctx.createRadialGradient(
            lightCenterX,
            lightCenterY,
            lightRadius * 0.85,
            lightCenterX,
            lightCenterY,
            lightRadius
          );
          edgeGradient.addColorStop(0, "rgba(245, 245, 232, 0)");
          edgeGradient.addColorStop(1, activeTheme.sky[1]);
          ctx.fillStyle = edgeGradient;
          ctx.beginPath();
          ctx.arc(lightCenterX, lightCenterY, lightRadius, 0, Math.PI * 2);
          ctx.fill();
        } else if (activeTheme.key === "research" && currentLevelIndex === 0) {
          // 第一关：科研风格背景
          // 绘制浅灰色实验室背景
          const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
          gradient.addColorStop(0, activeTheme.sky[0]);
          gradient.addColorStop(1, activeTheme.sky[1]);
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // 绘制网格线（科研实验室风格）
          ctx.strokeStyle = "rgba(160, 170, 180, 0.3)";
          ctx.lineWidth = 1;
          const gridSize = 50;
          const startX = Math.floor((cameraX % gridSize) / gridSize) * gridSize - (cameraX % gridSize);
          const startY = 0;
          
          // 垂直线
          for (let x = startX; x < canvas.width + gridSize; x += gridSize) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
            ctx.stroke();
          }
          
          // 水平线
          for (let y = startY; y < canvas.height; y += gridSize) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
          }
          
          // 绘制一些数据图表元素（科研风格装饰）
          const chartX = 500 - cameraX;
          const chartY = 100;
          if (chartX > -100 && chartX < canvas.width + 100) {
            // 绘制简单的柱状图（提高可见性）
            ctx.fillStyle = "rgba(100, 150, 200, 0.7)";
            const barWidth = 20;
            const bars = [40, 60, 35, 80, 50];
            bars.forEach((height, i) => {
              ctx.fillRect(chartX + i * 30, chartY + 100 - height, barWidth, height);
            });
            // 图表边框（更明显）
            ctx.strokeStyle = "rgba(80, 120, 160, 0.8)";
            ctx.lineWidth = 3;
            ctx.strokeRect(chartX - 10, chartY, bars.length * 30 + 20, 100);
          }
          
          // 绘制另一个图表
          const chartX2 = 1500 - cameraX;
          if (chartX2 > -100 && chartX2 < canvas.width + 100) {
            // 绘制折线图（提高可见性）
            ctx.strokeStyle = "rgba(60, 110, 160, 0.9)";
            ctx.lineWidth = 3;
            ctx.beginPath();
            const points = [30, 50, 40, 70, 60, 45, 80];
            points.forEach((y, i) => {
              const x = chartX2 + i * 25;
              const py = chartY + 100 - y;
              if (i === 0) {
                ctx.moveTo(x, py);
              } else {
                ctx.lineTo(x, py);
              }
            });
            ctx.stroke();
            // 数据点（更大更明显）
            ctx.fillStyle = "rgba(80, 130, 180, 1.0)";
            points.forEach((y, i) => {
              ctx.beginPath();
              ctx.arc(chartX2 + i * 25, chartY + 100 - y, 4, 0, Math.PI * 2);
              ctx.fill();
              // 数据点边框
              ctx.strokeStyle = "rgba(40, 80, 120, 0.8)";
              ctx.lineWidth = 1;
              ctx.stroke();
            });
          }
        } else {
          // 其他关卡正常绘制背景
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, activeTheme.sky[0]);
        gradient.addColorStop(1, activeTheme.sky[1]);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        if (!activeTheme.isUnderground) {
          const drawHill = (x, y, radius, color) => {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x - cameraX, y, radius, Math.PI, Math.PI * 2);
            ctx.fill();
          };

          drawHill(280, world.height - 64, 180, activeTheme.hillDark);
          drawHill(900, world.height - 64, 220, activeTheme.hillLight);
          drawHill(1300, world.height - 64, 160, "rgba(72, 160, 90, 0.78)");
          drawHill(2200, world.height - 64, 240, activeTheme.hillDark);
          drawHill(2800, world.height - 64, 180, activeTheme.hillLight);

          if (activeTheme.key === "candy") {
            const candyPositions = [
              { x: 400, y: world.height - 120, radius: 60, color: "#ff9ec4" },
              { x: 980, y: world.height - 140, radius: 48, color: "#ffd166" },
              { x: 1680, y: world.height - 150, radius: 54, color: "#a29bfe" },
              { x: 2280, y: world.height - 130, radius: 66, color: "#ff92a5" },
            ];
            candyPositions.forEach((candy, index) => {
              const cx = candy.x - cameraX;
              const cy = candy.y;
              ctx.save();
              ctx.translate(cx, cy);
              ctx.fillStyle = "#f7d6ff";
              ctx.fillRect(-8, -candy.radius * 1.6, 16, candy.radius * 1.6);
              ctx.lineWidth = 4;
              ctx.strokeStyle = index % 2 === 0 ? "#ff6f91" : "#ffa26b";
              ctx.beginPath();
              ctx.moveTo(-8, -candy.radius * 1.6);
              ctx.lineTo(8, -candy.radius * 1.2);
              ctx.moveTo(-8, -candy.radius * 1.2);
              ctx.lineTo(8, -candy.radius * 0.8);
              ctx.moveTo(-8, -candy.radius * 0.8);
              ctx.lineTo(8, -candy.radius * 0.4);
              ctx.stroke();
              ctx.fillStyle = candy.color;
              ctx.beginPath();
              ctx.arc(0, -candy.radius * 1.7, candy.radius, 0, Math.PI * 2);
              ctx.fill();
              ctx.strokeStyle = "rgba(255,255,255,0.8)";
              ctx.lineWidth = 3;
              for (let i = 0; i < 6; i++) {
                const angle = (Math.PI * 2 * i) / 6;
                ctx.beginPath();
                ctx.moveTo(
                  Math.cos(angle) * candy.radius * 0.3,
                  -candy.radius * 1.7 + Math.sin(angle) * candy.radius * 0.3,
                );
                ctx.lineTo(
                  Math.cos(angle) * candy.radius * 0.8,
                  -candy.radius * 1.7 + Math.sin(angle) * candy.radius * 0.8,
                );
                ctx.stroke();
              }
              ctx.restore();
            });
          }

          if (activeTheme.key === "climb") {
            // 攀岩主题：绘制高耸的山峰
            const mountainPeaks = [
              { x: 200, height: 180, width: 300 },
              { x: 800, height: 220, width: 350 },
              { x: 1500, height: 200, width: 320 },
              { x: 2400, height: 240, width: 380 },
              { x: 3200, height: 190, width: 310 },
            ];
            mountainPeaks.forEach((peak) => {
              const mx = peak.x - cameraX;
              if (mx + peak.width > -100 && mx < canvas.width + 100) {
                ctx.save();
                // 山峰主体
                ctx.fillStyle = "rgba(100, 100, 110, 0.7)";
                ctx.beginPath();
                ctx.moveTo(mx, world.height - 64);
                ctx.lineTo(mx + peak.width / 2, world.height - 64 - peak.height);
                ctx.lineTo(mx + peak.width, world.height - 64);
                ctx.closePath();
                ctx.fill();
                // 山峰阴影
                ctx.fillStyle = "rgba(80, 80, 90, 0.5)";
                ctx.beginPath();
                ctx.moveTo(mx + peak.width / 2, world.height - 64 - peak.height);
                ctx.lineTo(mx + peak.width, world.height - 64);
                ctx.lineTo(mx + peak.width * 0.7, world.height - 64 - peak.height * 0.3);
                ctx.closePath();
                ctx.fill();
                // 雪顶
                ctx.fillStyle = "rgba(240, 240, 250, 0.9)";
                ctx.beginPath();
                ctx.moveTo(mx + peak.width / 2 - 20, world.height - 64 - peak.height);
                ctx.lineTo(mx + peak.width / 2, world.height - 64 - peak.height - 15);
                ctx.lineTo(mx + peak.width / 2 + 20, world.height - 64 - peak.height);
                ctx.closePath();
                ctx.fill();
                // 岩石纹理
                ctx.strokeStyle = "rgba(70, 70, 80, 0.4)";
                ctx.lineWidth = 2;
                for (let i = 0; i < 3; i++) {
                  const rockY = world.height - 64 - (peak.height / 4) * (i + 1);
                  ctx.beginPath();
                  ctx.moveTo(mx + peak.width * 0.2 + i * 20, rockY);
                  ctx.lineTo(mx + peak.width * 0.8 - i * 20, rockY);
                  ctx.stroke();
                }
                ctx.restore();
              }
            });
            
            // 攀岩点/抓手点
            const climbingHolds = [
              { x: 450, y: H - 240 },
              { x: 750, y: H - 300 },
              { x: 1050, y: H - 280 },
              { x: 1450, y: H - 320 },
              { x: 1850, y: H - 300 },
              { x: 2250, y: H - 340 },
              { x: 2650, y: H - 320 },
              { x: 3050, y: H - 360 },
              { x: 3450, y: H - 340 },
              { x: 3850, y: H - 360 },
            ];
            climbingHolds.forEach((hold) => {
              const hx = hold.x - cameraX;
              if (hx > -30 && hx < canvas.width + 30) {
                ctx.save();
                ctx.fillStyle = "rgba(150, 150, 160, 0.8)";
                ctx.strokeStyle = "rgba(120, 120, 130, 0.9)";
                ctx.lineWidth = 2;
                // 攀岩点主体
                ctx.beginPath();
                ctx.arc(hx, hold.y, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                // 高光
                ctx.fillStyle = "rgba(200, 200, 210, 0.6)";
                ctx.beginPath();
                ctx.arc(hx - 3, hold.y - 3, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
              }
            });
            
            // 云朵（在较低位置）- 第一关不绘制云
          if (activeTheme.cloud && !(currentLevelIndex === 0 && activeTheme.key === "research")) {
              ctx.fillStyle = activeTheme.cloud;
              for (let i = 0; i < 12; i++) {
                const x = (cameraX / 3 + i * 220) % (canvas.width + 220) - 220;
                const y = 200 + Math.sin((Date.now() / 2500 + i) % Math.PI) * 15;
                ctx.beginPath();
                ctx.ellipse(x + 120, y, 100, 35, 0, 0, Math.PI * 2);
                ctx.fill();
              }
            }
          } else if (activeTheme.key === "snow") {
            // 滑雪场主题：绘制雪景
            // 雪山背景
            const snowMountains = [
              { x: 100, height: 150, width: 280 },
              { x: 600, height: 180, width: 320 },
              { x: 1200, height: 160, width: 300 },
              { x: 2000, height: 190, width: 340 },
              { x: 2800, height: 170, width: 310 },
              { x: 3600, height: 200, width: 330 },
            ];
            snowMountains.forEach((mountain) => {
              const mx = mountain.x - cameraX;
              if (mx + mountain.width > -100 && mx < canvas.width + 100) {
                ctx.save();
                // 雪山主体
                ctx.fillStyle = "rgba(240, 240, 250, 0.8)";
                ctx.beginPath();
                ctx.moveTo(mx, world.height - 64);
                ctx.lineTo(mx + mountain.width / 2, world.height - 64 - mountain.height);
                ctx.lineTo(mx + mountain.width, world.height - 64);
                ctx.closePath();
                ctx.fill();
                // 雪顶高光
                ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
                ctx.beginPath();
                ctx.moveTo(mx + mountain.width / 2 - 15, world.height - 64 - mountain.height);
                ctx.lineTo(mx + mountain.width / 2, world.height - 64 - mountain.height - 10);
                ctx.lineTo(mx + mountain.width / 2 + 15, world.height - 64 - mountain.height);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
              }
            });
            
            // 雪人
            const snowmanPositions = [
              { x: 500, y: world.height - 120 },
              { x: 1500, y: world.height - 115 },
              { x: 3000, y: world.height - 125 },
            ];
            snowmanPositions.forEach((snowman) => {
              const sx = snowman.x - cameraX;
              if (sx > -80 && sx < canvas.width + 80) {
                ctx.save();
                ctx.translate(sx, snowman.y);
                // 雪人身体（下）
                ctx.fillStyle = "#ffffff";
                ctx.beginPath();
                ctx.arc(0, 0, 25, 0, Math.PI * 2);
                ctx.fill();
                // 雪人身体（中）
                ctx.beginPath();
                ctx.arc(0, -30, 20, 0, Math.PI * 2);
                ctx.fill();
                // 雪人头部
                ctx.beginPath();
                ctx.arc(0, -55, 15, 0, Math.PI * 2);
                ctx.fill();
                // 雪人眼睛
                ctx.fillStyle = "#1a0f26";
                ctx.beginPath();
                ctx.arc(-5, -58, 2, 0, Math.PI * 2);
                ctx.arc(5, -58, 2, 0, Math.PI * 2);
                ctx.fill();
                // 雪人鼻子（胡萝卜）
                ctx.fillStyle = "#ff8c00";
                ctx.beginPath();
                ctx.moveTo(0, -55);
                ctx.lineTo(8, -52);
                ctx.lineTo(0, -50);
                ctx.closePath();
                ctx.fill();
                // 雪人帽子
                ctx.fillStyle = "#8b4513";
                ctx.fillRect(-12, -70, 24, 8);
                ctx.fillRect(-8, -75, 16, 5);
                ctx.restore();
              }
            });
            
            // 雪花飘落效果
            const snowflakeCount = 30;
            for (let i = 0; i < snowflakeCount; i++) {
              const snowX = (cameraX * 0.1 + i * 150) % (canvas.width + 150) - 150;
              const snowY = (Date.now() / 20 + i * 50) % (canvas.height + 100) - 100;
              const snowSize = 2 + Math.sin((Date.now() / 1000 + i) % (Math.PI * 2)) * 1;
              
              ctx.save();
              ctx.globalAlpha = 0.8;
              ctx.fillStyle = "#ffffff";
              ctx.beginPath();
              ctx.arc(snowX, snowY, snowSize, 0, Math.PI * 2);
              ctx.fill();
              ctx.restore();
            }
            
            // 云朵 - 第一关不绘制云
            if (activeTheme.cloud && !(currentLevelIndex === 0 && activeTheme.key === "research")) {
              ctx.fillStyle = activeTheme.cloud;
              for (let i = 0; i < 14; i++) {
                const x = (cameraX / 4 + i * 200) % (canvas.width + 200) - 200;
                const y = 100 + Math.sin((Date.now() / 3000 + i) % Math.PI) * 10;
                ctx.beginPath();
                ctx.ellipse(x + 100, y, 110, 38, 0, 0, Math.PI * 2);
                ctx.fill();
              }
            }
          } else if (activeTheme.cloud && !(currentLevelIndex === 0 && activeTheme.key === "research")) {
            ctx.fillStyle = activeTheme.cloud;
            for (let i = 0; i < 16; i++) {
              const x = (cameraX / 4 + i * 180) % (canvas.width + 180) - 180;
              ctx.beginPath();
              ctx.ellipse(
                x + 100,
                120 + Math.sin((Date.now() / 2000 + i) % Math.PI) * 12,
                120,
                40,
                0,
                0,
                Math.PI * 2,
              );
              ctx.fill();
            }
          }
        } else {
          if (activeTheme.key === "ghost") {
            ctx.fillStyle = "rgba(60, 40, 80, 0.7)";
            for (let i = 0; i < 8; i++) {
              const x = (cameraX / 5 + i * 200) % (canvas.width + 200) - 200;
              ctx.fillRect(x + 30, canvas.height - 240, 180, 220);
            }
            ctx.strokeStyle = "rgba(150, 100, 180, 0.12)";
            for (let y = 60; y < canvas.height; y += 50) {
              ctx.beginPath();
              ctx.moveTo(0, y);
              ctx.lineTo(canvas.width, y);
              ctx.stroke();
            }
            ctx.strokeStyle = "rgba(150, 100, 180, 0.08)";
            for (let x = 0; x < canvas.width; x += 70) {
              ctx.beginPath();
              ctx.moveTo(x, 0);
              ctx.lineTo(x, canvas.height);
              ctx.stroke();
            }
            
            // 万圣节月亮
            const moonX = canvas.width - 120 - cameraX * 0.1;
            const moonY = 80;
            ctx.fillStyle = "rgba(255, 240, 200, 0.4)";
            ctx.beginPath();
            ctx.arc(moonX, moonY, 45, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "rgba(255, 220, 150, 0.3)";
            ctx.beginPath();
            ctx.arc(moonX - 15, moonY - 10, 35, 0, Math.PI * 2);
            ctx.fill();
            
            // 蝙蝠
            for (let i = 0; i < 6; i++) {
              const batX = (cameraX * 0.3 + i * 350) % (canvas.width + 350) - 350;
              const batY = 100 + Math.sin((Date.now() / 800 + i) % (Math.PI * 2)) * 25;
              ctx.save();
              ctx.translate(batX, batY);
              ctx.fillStyle = "rgba(20, 20, 30, 0.8)";
              // 蝙蝠身体
              ctx.beginPath();
              ctx.ellipse(0, 0, 8, 12, 0, 0, Math.PI * 2);
              ctx.fill();
              // 蝙蝠翅膀
              ctx.beginPath();
              ctx.ellipse(-12, -4, 10, 6, -0.3, 0, Math.PI * 2);
              ctx.ellipse(12, -4, 10, 6, 0.3, 0, Math.PI * 2);
              ctx.fill();
              ctx.restore();
            }
            
            // 墓碑
            const tombstonePositions = [
              { x: 500, y: world.height - 120 },
              { x: 1200, y: world.height - 110 },
              { x: 2100, y: world.height - 125 },
              { x: 3000, y: world.height - 115 },
            ];
            tombstonePositions.forEach((tomb) => {
              const tx = tomb.x - cameraX;
              if (tx > -100 && tx < canvas.width + 100) {
                ctx.fillStyle = "rgba(120, 120, 130, 0.7)";
                // 墓碑顶部（弧形）
                ctx.beginPath();
                ctx.arc(tx, tomb.y - 25, 20, Math.PI, 0, false);
                ctx.fill();
                // 墓碑主体
                ctx.fillRect(tx - 20, tomb.y - 25, 40, 50);
                // 十字架
                ctx.fillStyle = "rgba(80, 80, 90, 0.8)";
                ctx.fillRect(tx - 2, tomb.y - 35, 4, 15);
                ctx.fillRect(tx - 6, tomb.y - 30, 12, 4);
                // RIP文字
                ctx.fillStyle = "rgba(40, 40, 50, 0.9)";
                ctx.font = "bold 10px Nunito";
                ctx.textAlign = "center";
                ctx.fillText("RIP", tx, tomb.y - 5);
              }
            });
            
            // 南瓜灯现在作为实体障碍物绘制，不再在这里绘制
            
            // 蜘蛛网
            const webPositions = [
              { x: 600, y: 150 },
              { x: 1800, y: 140 },
              { x: 2700, y: 160 },
            ];
            webPositions.forEach((web) => {
              const wx = web.x - cameraX;
              if (wx > -100 && wx < canvas.width + 100) {
                ctx.save();
                ctx.translate(wx, web.y);
                ctx.strokeStyle = "rgba(200, 200, 220, 0.4)";
                ctx.lineWidth = 1.5;
                // 蜘蛛网辐射线
                for (let i = 0; i < 8; i++) {
                  const angle = (Math.PI * 2 * i) / 8;
                  ctx.beginPath();
                  ctx.moveTo(0, 0);
                  ctx.lineTo(Math.cos(angle) * 40, Math.sin(angle) * 40);
                  ctx.stroke();
                }
                // 蜘蛛网螺旋
                for (let r = 8; r <= 40; r += 8) {
                  ctx.beginPath();
                  ctx.arc(0, 0, r, 0, Math.PI * 2);
                  ctx.stroke();
                }
                ctx.restore();
              }
            });
            
            // 飘浮的幽灵（背景）
            ctx.fillStyle = "rgba(200, 150, 220, 0.15)";
            for (let i = 0; i < 4; i++) {
              const ghostX = (cameraX / 3 + i * 400) % (canvas.width + 400) - 400;
              const ghostY = 120 + Math.sin((Date.now() / 1500 + i * 0.8) % (Math.PI * 2)) * 30;
              ctx.beginPath();
              ctx.arc(ghostX + 200, ghostY, 18, Math.PI, 0, false);
              ctx.lineTo(ghostX + 200 - 18, ghostY + 20);
              ctx.quadraticCurveTo(ghostX + 200 - 12, ghostY + 15, ghostX + 200 - 6, ghostY + 18);
              ctx.quadraticCurveTo(ghostX + 200, ghostY + 15, ghostX + 200 + 6, ghostY + 18);
              ctx.quadraticCurveTo(ghostX + 200 + 12, ghostY + 15, ghostX + 200 + 18, ghostY + 20);
              ctx.closePath();
              ctx.fill();
              // 眼睛
              ctx.fillStyle = "rgba(40, 20, 60, 0.6)";
              ctx.beginPath();
              ctx.arc(ghostX + 200 - 6, ghostY - 2, 3, 0, Math.PI * 2);
              ctx.arc(ghostX + 200 + 6, ghostY - 2, 3, 0, Math.PI * 2);
              ctx.fill();
              ctx.fillStyle = "rgba(200, 150, 220, 0.15)";
            }
          } else if (activeTheme.key === "water") {
            // 水下场景背景
            ctx.fillStyle = "rgba(30, 60, 90, 0.5)";
            for (let i = 0; i < 10; i++) {
              const x = (cameraX / 4 + i * 150) % (canvas.width + 150) - 150;
              ctx.fillRect(x + 20, canvas.height - 250, 130, 250);
            }
            
            // 水波纹效果
            ctx.strokeStyle = "rgba(100, 180, 255, 0.2)";
            ctx.lineWidth = 2;
            for (let y = 50; y < canvas.height; y += 80) {
              const waveOffset = Math.sin((Date.now() / 1000 + y * 0.01) % (Math.PI * 2)) * 15;
              ctx.beginPath();
              for (let x = 0; x < canvas.width; x += 5) {
                const waveY = y + Math.sin((x + cameraX) * 0.02 + Date.now() / 800) * 8 + waveOffset;
                if (x === 0) {
                  ctx.moveTo(x, waveY);
                } else {
                  ctx.lineTo(x, waveY);
                }
              }
              ctx.stroke();
            }
            
            // 气泡效果
            const bubbleCount = 15;
            for (let i = 0; i < bubbleCount; i++) {
              const bubbleX = (cameraX * 0.2 + i * 200) % (canvas.width + 200) - 200;
              const bubbleY = canvas.height - 100 - (Date.now() / 50 + i * 100) % (canvas.height - 200);
              const bubbleSize = 4 + Math.sin((Date.now() / 500 + i) % (Math.PI * 2)) * 2;
              
              ctx.save();
              ctx.globalAlpha = 0.4;
              ctx.fillStyle = "rgba(200, 240, 255, 0.6)";
              ctx.strokeStyle = "rgba(150, 220, 255, 0.8)";
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
              ctx.fill();
              ctx.stroke();
              // 气泡高光
              ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
              ctx.beginPath();
              ctx.arc(bubbleX - bubbleSize * 0.3, bubbleY - bubbleSize * 0.3, bubbleSize * 0.3, 0, Math.PI * 2);
              ctx.fill();
              ctx.restore();
            }
            
            // 水草/海草
            const seaweedPositions = [
              { x: 300, height: 80 },
              { x: 900, height: 100 },
              { x: 1500, height: 70 },
              { x: 2100, height: 90 },
              { x: 2700, height: 85 },
              { x: 3300, height: 95 },
            ];
            seaweedPositions.forEach((seaweed) => {
              const sx = seaweed.x - cameraX;
              if (sx > -50 && sx < canvas.width + 50) {
                ctx.save();
                ctx.strokeStyle = "rgba(50, 150, 80, 0.6)";
                ctx.lineWidth = 4;
                ctx.lineCap = "round";
                const sway = Math.sin((Date.now() / 1200 + seaweed.x * 0.01) % (Math.PI * 2)) * 12;
                ctx.beginPath();
                ctx.moveTo(sx, world.height - 64);
                for (let i = 0; i < 8; i++) {
                  const segmentY = world.height - 64 - (seaweed.height / 8) * i;
                  const segmentX = sx + sway * (i / 8);
                  ctx.lineTo(segmentX, segmentY);
                }
                ctx.stroke();
                // 海草叶子
                ctx.fillStyle = "rgba(40, 130, 70, 0.7)";
                for (let i = 2; i < 7; i++) {
                  const leafY = world.height - 64 - (seaweed.height / 8) * i;
                  const leafX = sx + sway * (i / 8);
                  ctx.beginPath();
                  ctx.ellipse(leafX + (i % 2 === 0 ? 8 : -8), leafY, 6, 12, (i % 2 === 0 ? 0.3 : -0.3), 0, Math.PI * 2);
                  ctx.fill();
                }
                ctx.restore();
              }
            });
            
            // 鱼类
            for (let i = 0; i < 5; i++) {
              const fishX = (cameraX * 0.5 + i * 500) % (canvas.width + 500) - 500;
              const fishY = 150 + Math.sin((Date.now() / 2000 + i) % (Math.PI * 2)) * 50;
              const fishDirection = i % 2 === 0 ? 1 : -1;
              
              ctx.save();
              ctx.translate(fishX, fishY);
              ctx.scale(fishDirection, 1);
              // 鱼身体
              ctx.fillStyle = "rgba(255, 150, 50, 0.7)";
              ctx.beginPath();
              ctx.ellipse(0, 0, 20, 12, 0, 0, Math.PI * 2);
              ctx.fill();
              // 鱼尾
              ctx.beginPath();
              ctx.moveTo(-20, 0);
              ctx.lineTo(-30, -8);
              ctx.lineTo(-25, 0);
              ctx.lineTo(-30, 8);
              ctx.closePath();
              ctx.fill();
              // 鱼眼睛
              ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
              ctx.beginPath();
              ctx.arc(8, -4, 4, 0, Math.PI * 2);
              ctx.fill();
              ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
              ctx.beginPath();
              ctx.arc(9, -4, 2, 0, Math.PI * 2);
              ctx.fill();
              ctx.restore();
            }
            
            // 水下光线效果
            ctx.fillStyle = "rgba(100, 200, 255, 0.1)";
            for (let i = 0; i < 3; i++) {
              const lightX = (cameraX * 0.1 + i * 400) % (canvas.width + 400) - 400;
              ctx.beginPath();
              ctx.moveTo(lightX + 200, 0);
              ctx.lineTo(lightX + 180, canvas.height);
              ctx.lineTo(lightX + 220, canvas.height);
              ctx.closePath();
              ctx.fill();
          }
        } else {
          ctx.fillStyle = "rgba(40, 36, 66, 0.6)";
          for (let i = 0; i < 6; i++) {
            const x = (cameraX / 6 + i * 240) % (canvas.width + 240) - 240;
            ctx.fillRect(x + 40, canvas.height - 220, 200, 200);
          }
          ctx.strokeStyle = "rgba(120, 120, 200, 0.08)";
          for (let y = 80; y < canvas.height; y += 60) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
          }
          ctx.strokeStyle = "rgba(120, 120, 200, 0.05)";
          for (let x = 0; x < canvas.width; x += 80) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, canvas.height);
            ctx.stroke();
            }
          }
        }
      }

      function drawGround() {
        const tileSize = 64;
        const start = Math.floor(world.camera.x / tileSize);
        const end = start + Math.ceil(canvas.width / tileSize) + 2;
        for (let i = start; i < end; i++) {
          const worldX = i * tileSize;
          const x = worldX - world.camera.x;
          const isInPit = (level.pits || []).some(pit => worldX >= pit.x && worldX < pit.x + pit.width);
          if (!isInPit) {
          ctx.fillStyle = activeTheme.groundBody;
          ctx.fillRect(x, world.height - tileSize, tileSize, tileSize);
          ctx.fillStyle = activeTheme.groundTop;
          ctx.fillRect(x, world.height - tileSize, tileSize, tileSize / 3);
          ctx.fillStyle = activeTheme.groundStripe;
          for (let j = 0; j < 3; j++) {
            ctx.fillRect(
              x,
              world.height - tileSize + tileSize / 3 + (tileSize / 3) * j,
              tileSize,
              4,
            );
            }
          }
        }
      }

      function drawPlatforms() {
        const bodyColor = activeTheme.platformBody;
        const topColor = activeTheme.platformTop;
        level.platforms.forEach((platform) => {
          const x = platform.x - world.camera.x;
          if (x + platform.width < -64 || x > canvas.width + 64) return;
          ctx.fillStyle = bodyColor;
          ctx.fillRect(x, platform.y, platform.width, platform.height);
          ctx.fillStyle = topColor;
          ctx.fillRect(x, platform.y, platform.width, 8);
        });
      }

      function drawPipes() {
        level.pipes.forEach((pipe) => {
          const x = pipe.x - world.camera.x;
          if (x + pipe.width < -64 || x > canvas.width + 64) return;
          const isCandy = activeTheme.key === "candy";
          const isGhost = activeTheme.key === "ghost";
          const isWater = activeTheme.key === "water";
          const isClimb = activeTheme.key === "climb";
          const isSnow = activeTheme.key === "snow";
          const bodyColor = isWater
            ? "#3d6a8a"
            : isGhost
            ? "#6b5b7b"
            : isClimb
            ? "#7b6a5a"
            : isSnow
            ? "#d0d8e0"
            : activeTheme.isUnderground
            ? "#4f6ed8"
            : isCandy
            ? "#ff80ab"
            : "#2dac4a";
          const topColor = isWater
            ? "#5d8aaa"
            : isGhost
            ? "#8b7b9b"
            : isClimb
            ? "#9b8a6a"
            : isSnow
            ? "#f0f0f8"
            : activeTheme.isUnderground
            ? "#6f8df0"
            : isCandy
            ? "#ffc2d7"
            : "#4ed76d";
          ctx.fillStyle = bodyColor;
          ctx.fillRect(x, pipe.y + 18, pipe.width, pipe.height - 18);
          ctx.fillStyle = topColor;
          ctx.fillRect(x - 6, pipe.y, pipe.width + 12, 18);
          ctx.fillStyle = "rgba(255,255,255,0.2)";
          ctx.fillRect(x + pipe.width * 0.2, pipe.y + 24, 6, pipe.height - 40);
        });
      }

      function drawBricks() {
        level.bricks.forEach((brick) => {
          const x = brick.x - world.camera.x;
          if (x + brick.width < -64 || x > canvas.width + 64) return;
          const bumpOffset = brick.bump > 0 ? Math.sin(brick.bump * Math.PI) * 8 : 0;
          const y = brick.y - bumpOffset;
          
          // 第一关：绘制书架
          if (currentLevelIndex === 0 && activeTheme.key === "research") {
            // 书架主体（棕色木制）
            ctx.fillStyle = "#8b6f47";
            ctx.fillRect(x, y, brick.width, brick.height);
            
            // 书架边框
            ctx.strokeStyle = "#6b4f27";
            ctx.lineWidth = 3;
            ctx.strokeRect(x, y, brick.width, brick.height);
            
            // 书架内部隔板（水平线）
            ctx.strokeStyle = "#6b4f27";
            ctx.lineWidth = 2;
            for (let i = 1; i < 3; i++) {
              ctx.beginPath();
              ctx.moveTo(x + 4, y + (brick.height / 3) * i);
              ctx.lineTo(x + brick.width - 4, y + (brick.height / 3) * i);
              ctx.stroke();
            }
            
            // 绘制书籍（垂直的书脊）
            const bookCount = 4;
            const bookWidth = (brick.width - 12) / bookCount;
            for (let i = 0; i < bookCount; i++) {
              const bookX = x + 6 + i * bookWidth;
              const bookColors = ["#4a5c7a", "#7a4a5c", "#5c7a4a", "#6a4a7a"];
              ctx.fillStyle = bookColors[i % bookColors.length];
              ctx.fillRect(bookX, y + 4, bookWidth - 2, brick.height - 8);
              
              // 书脊装饰线
              ctx.strokeStyle = "rgba(0, 0, 0, 0.3)";
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(bookX + (bookWidth - 2) / 2, y + 4);
              ctx.lineTo(bookX + (bookWidth - 2) / 2, y + brick.height - 4);
              ctx.stroke();
            }
            
            // 如果是问号砖块，在顶部添加一个小标签
            if (brick.kind === "question") {
              ctx.fillStyle = "#ffd700";
              ctx.fillRect(x + brick.width - 20, y - 8, 16, 12);
              ctx.strokeStyle = "#d4af37";
              ctx.lineWidth = 1;
              ctx.strokeRect(x + brick.width - 20, y - 8, 16, 12);
              ctx.fillStyle = "#000";
              ctx.font = "bold 10px Nunito";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              ctx.fillText("?", x + brick.width - 12, y - 2);
            }
            return;
          }
          
          // 其他关卡：正常绘制砖块
          if (brick.kind === "empty") {
            ctx.fillStyle = "#b0b0b0";
            ctx.fillRect(x, y, brick.width, brick.height);
            ctx.strokeStyle = "#8f8f8f";
            ctx.strokeRect(x, y, brick.width, brick.height);
            return;
          }
          ctx.fillStyle = brick.kind === "question" ? "#ffac33" : "#c86428";
          ctx.fillRect(x, y, brick.width, brick.height);
          ctx.strokeStyle = brick.kind === "question" ? "#d78217" : "#9c4214";
          ctx.lineWidth = 4;
          ctx.strokeRect(x + 2, y + 2, brick.width - 4, brick.height - 4);
          if (brick.kind === "question") {
            ctx.fillStyle = "#fff5d6";
            ctx.font = "bold 32px Nunito";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("?", x + brick.width / 2, y + brick.height / 2);
          } else if (brick.kind === "solid") {
            ctx.strokeStyle = "#e28a4b";
            for (let i = 1; i < 3; i++) {
              ctx.beginPath();
              ctx.moveTo(x + (brick.width / 3) * i, y + 6);
              ctx.lineTo(x + (brick.width / 3) * i, y + brick.height - 6);
              ctx.stroke();
            }
            ctx.beginPath();
            ctx.moveTo(x + 6, y + brick.height / 2);
            ctx.lineTo(x + brick.width - 6, y + brick.height / 2);
            ctx.stroke();
          }
        });
      }

      function drawCoins() {
        level.coins.forEach((coin) => {
          const x = coin.x - world.camera.x + coin.width / 2;
          const y = coin.y + coin.height / 2;
          const texture = coin.texture;
          const pulse = 1 + Math.sin(coin.timer * 2) * 0.06;
          const size = 42 * pulse;
          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(Math.sin(coin.spin) * 0.2);
          if (texture && texture.complete) {
            ctx.drawImage(texture, -size / 2, -size / 2, size, size);
          } else {
            ctx.beginPath();
            ctx.ellipse(0, 0, size / 2.2, size / 1.8, 0, 0, Math.PI * 2);
            ctx.fillStyle = "#ffd447";
            ctx.fill();
            ctx.strokeStyle = "#e3b12d";
            ctx.lineWidth = 4;
            ctx.stroke();
          }
          ctx.restore();
        });
      }

      function drawMushrooms() {
        level.powerups.forEach((mushroom) => {
          const x = mushroom.x - world.camera.x + mushroom.width / 2;
          const y = mushroom.y + mushroom.height / 2;
          ctx.save();
          ctx.translate(x, y);
          ctx.beginPath();
          ctx.fillStyle = "#ff6b6b";
          ctx.arc(0, -6, 18, Math.PI, 0);
          ctx.fill();
          ctx.fillStyle = "#ffe0b2";
          ctx.fillRect(-18, -6, 36, 22);
          ctx.fillStyle = "#ffffff";
          ctx.beginPath();
          ctx.arc(-10, -2, 6, 0, Math.PI * 2);
          ctx.arc(10, -2, 6, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#8d5524";
          ctx.fillRect(-12, 4, 24, 12);
          ctx.restore();
        });
      }

      function drawSkateboards() {
        level.skateboards.forEach((skateboard) => {
          const x = skateboard.x - world.camera.x;
          if (x + skateboard.width < -64 || x > canvas.width + 64) return;
          ctx.save();
          ctx.translate(x + skateboard.width / 2, skateboard.y + skateboard.height / 2);
          ctx.rotate(skateboard.rotation);
          // 滑板板面
          ctx.fillStyle = "#8b4513";
          ctx.fillRect(-25, -6, 50, 12);
          // 滑板轮子
          ctx.fillStyle = "#2c2c2c";
          ctx.beginPath();
          ctx.arc(-18, 0, 5, 0, Math.PI * 2);
          ctx.arc(-6, 0, 5, 0, Math.PI * 2);
          ctx.arc(6, 0, 5, 0, Math.PI * 2);
          ctx.arc(18, 0, 5, 0, Math.PI * 2);
          ctx.fill();
          // 轮子高光
          ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
          ctx.beginPath();
          ctx.arc(-18, -2, 2, 0, Math.PI * 2);
          ctx.arc(-6, -2, 2, 0, Math.PI * 2);
          ctx.arc(6, -2, 2, 0, Math.PI * 2);
          ctx.arc(18, -2, 2, 0, Math.PI * 2);
          ctx.fill();
          // 滑板装饰
          ctx.strokeStyle = "#654321";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(-20, 0);
          ctx.lineTo(20, 0);
          ctx.stroke();
          ctx.restore();
        });
      }

      function drawSnowPiles() {
        level.snowPiles.forEach((pile) => {
          const x = pile.x - world.camera.x;
          if (x + pile.width < -64 || x > canvas.width + 64) return;
          ctx.save();
          // 雪堆主体（椭圆形）
          ctx.fillStyle = "#ffffff";
          ctx.beginPath();
          ctx.ellipse(x + pile.width / 2, pile.y + pile.height / 2, pile.width / 2, pile.height / 2, 0, 0, Math.PI * 2);
          ctx.fill();
          // 雪堆高光
          ctx.fillStyle = "rgba(240, 248, 255, 0.8)";
          ctx.beginPath();
          ctx.ellipse(x + pile.width / 2 - 8, pile.y + pile.height / 2 - 8, pile.width / 3, pile.height / 3, 0, 0, Math.PI * 2);
          ctx.fill();
          // 雪堆阴影
          ctx.fillStyle = "rgba(200, 220, 240, 0.4)";
          ctx.beginPath();
          ctx.ellipse(x + pile.width / 2 + 5, pile.y + pile.height / 2 + 5, pile.width / 2.5, pile.height / 2.5, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        });
      }

      function drawIcePillars() {
        level.icePillars.forEach((pillar) => {
          const x = pillar.x - world.camera.x;
          if (x + pillar.width < -64 || x > canvas.width + 64) return;
          ctx.save();
          // 冰柱主体
          ctx.fillStyle = "rgba(200, 240, 255, 0.7)";
          ctx.fillRect(x, pillar.y, pillar.width, pillar.height);
          // 冰柱高光
          ctx.fillStyle = "rgba(240, 250, 255, 0.9)";
          ctx.fillRect(x + 4, pillar.y + 4, pillar.width - 8, 12);
          // 冰柱纹理
          ctx.strokeStyle = "rgba(150, 220, 255, 0.5)";
          ctx.lineWidth = 2;
          for (let i = 0; i < 4; i++) {
            const y = pillar.y + 20 + i * 15;
            ctx.beginPath();
            ctx.moveTo(x + 6, y);
            ctx.lineTo(x + pillar.width - 6, y);
            ctx.stroke();
          }
          // 冰柱顶部
          ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
          ctx.beginPath();
          ctx.moveTo(x, pillar.y);
          ctx.lineTo(x + pillar.width / 2, pillar.y - 8);
          ctx.lineTo(x + pillar.width, pillar.y);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        });
      }

      function drawFireballs() {
        level.projectiles.forEach((projectile) => {
          const x = projectile.x - world.camera.x + projectile.width / 2;
          const y = projectile.y + projectile.height / 2;
          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(projectile.rotation);
          const radius = projectile.width / 2;
          const gradient = ctx.createRadialGradient(0, 0, radius * 0.2, 0, 0, radius);
          gradient.addColorStop(0, "#fff5d6");
          gradient.addColorStop(0.5, "#ff9f43");
          gradient.addColorStop(1, "#ff5733");
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(0, 0, radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = "rgba(255, 255, 255, 0.6)";
          ctx.lineWidth = 2;
          ctx.stroke();
          ctx.restore();
        });
      }

      function drawFallingCandies() {
        if (!level.fallingCandies) return;
        level.fallingCandies.forEach((candy) => {
          const x = candy.x - world.camera.x;
          if (x + candy.width < -64 || x > canvas.width + 64) return;
          ctx.save();
          ctx.translate(x + candy.width / 2, candy.y + candy.height / 2);
          ctx.rotate(candy.rotation);
          
          // 掉落糖果主体（圆形，彩色渐变）
          const gradient = ctx.createRadialGradient(-8, -8, 0, 0, 0, 18);
          gradient.addColorStop(0, "#ffffff");
          gradient.addColorStop(0.3, "#ff6b9d");
          gradient.addColorStop(0.6, "#ffd93d");
          gradient.addColorStop(1, "#6bcf7f");
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(0, 0, 16, 0, Math.PI * 2);
          ctx.fill();
          
          // 糖果条纹
          ctx.strokeStyle = "#ffffff";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(-16, 0);
          ctx.lineTo(16, 0);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(0, -16);
          ctx.lineTo(0, 16);
          ctx.stroke();
          
          // 高光
          ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
          ctx.beginPath();
          ctx.arc(-6, -6, 5, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.restore();
        });
      }

      function drawPumpkinObstacles() {
        if (!level.pumpkinObstacles) return;
        level.pumpkinObstacles.forEach((pumpkin) => {
          const x = pumpkin.x - world.camera.x;
          if (x + pumpkin.width < -64 || x > canvas.width + 64) return;
          ctx.save();
          ctx.translate(x + pumpkin.width / 2, pumpkin.y + pumpkin.height / 2);
          ctx.rotate(pumpkin.rotation);
          
          // 南瓜主体
          ctx.fillStyle = "#ff8c00";
          ctx.beginPath();
          ctx.ellipse(0, 0, 30, 35, 0, 0, Math.PI * 2);
          ctx.fill();
          
          // 南瓜条纹
          ctx.strokeStyle = "#ff6b00";
          ctx.lineWidth = 3;
          for (let i = -1; i <= 1; i++) {
            ctx.beginPath();
            ctx.moveTo(i * 10, -35);
            ctx.lineTo(i * 10, 35);
            ctx.stroke();
          }
          
          // 南瓜眼睛
          ctx.fillStyle = "#1a0f26";
          ctx.beginPath();
          ctx.arc(-10, -8, 6, 0, Math.PI * 2);
          ctx.arc(10, -8, 6, 0, Math.PI * 2);
          ctx.fill();
          
          // 南瓜嘴巴
          ctx.beginPath();
          ctx.arc(0, 8, 12, 0, Math.PI, false);
          ctx.fill();
          
          // 南瓜牙齿
          ctx.fillStyle = "#ff8c00";
          ctx.fillRect(-3, 8, 6, 4);
          
          // 南瓜茎
          ctx.fillStyle = "#2d5016";
          ctx.fillRect(-4, -38, 8, 8);
          
          ctx.restore();
        });
      }

      function drawCoralObstacles() {
        if (!level.coralObstacles) return;
        level.coralObstacles.forEach((coral) => {
          const x = coral.x - world.camera.x;
          if (x + coral.width < -64 || x > canvas.width + 64) return;
          ctx.save();
          ctx.translate(x + coral.width / 2, coral.y + coral.height);
          
          // 珊瑚主体（分支状）
          ctx.fillStyle = "#ff6b9d";
          // 主分支（更长）
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(-20, -30);
          ctx.lineTo(-15, -50);
          ctx.lineTo(0, -65);
          ctx.lineTo(15, -50);
          ctx.lineTo(20, -30);
          ctx.closePath();
          ctx.fill();
          
          // 左侧分支（更长）
          ctx.beginPath();
          ctx.moveTo(-15, -35);
          ctx.lineTo(-28, -45);
          ctx.lineTo(-25, -60);
          ctx.lineTo(-15, -65);
          ctx.closePath();
          ctx.fill();
          
          // 右侧分支（更长）
          ctx.beginPath();
          ctx.moveTo(15, -35);
          ctx.lineTo(28, -45);
          ctx.lineTo(25, -60);
          ctx.lineTo(15, -65);
          ctx.closePath();
          ctx.fill();
          
          // 小分支（更长）
          ctx.fillStyle = "#ff8fab";
          ctx.beginPath();
          ctx.moveTo(-10, -20);
          ctx.lineTo(-16, -25);
          ctx.lineTo(-14, -38);
          ctx.closePath();
          ctx.fill();
          
          ctx.beginPath();
          ctx.moveTo(10, -20);
          ctx.lineTo(16, -25);
          ctx.lineTo(14, -38);
          ctx.closePath();
          ctx.fill();
          
          // 额外的刺（更长）
          ctx.fillStyle = "#ff6b9d";
          // 左侧刺
          ctx.beginPath();
          ctx.moveTo(-18, -15);
          ctx.lineTo(-24, -20);
          ctx.lineTo(-22, -32);
          ctx.closePath();
          ctx.fill();
          
          // 右侧刺
          ctx.beginPath();
          ctx.moveTo(18, -15);
          ctx.lineTo(24, -20);
          ctx.lineTo(22, -32);
          ctx.closePath();
          ctx.fill();
          
          // 高光
          ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
          ctx.beginPath();
          ctx.arc(-5, -40, 5, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.restore();
        });
      }

      function drawRockObstacles() {
        if (!level.rockObstacles) return;
        level.rockObstacles.forEach((rock) => {
          const x = rock.x - world.camera.x;
          if (x + rock.width < -64 || x > canvas.width + 64) return;
          ctx.save();
          
          // 岩石主体（灰色，不规则形状）
          ctx.fillStyle = "#5a5a5a";
          ctx.beginPath();
          // 左侧边缘（不规则）
          ctx.moveTo(x, rock.y + rock.height);
          ctx.lineTo(x + 5, rock.y + rock.height - 10);
          ctx.lineTo(x + 3, rock.y + rock.height - 25);
          ctx.lineTo(x + 8, rock.y + rock.height - 40);
          ctx.lineTo(x + 2, rock.y + rock.height - 55);
          ctx.lineTo(x + 6, rock.y + rock.height - 70);
          ctx.lineTo(x + 1, rock.y + rock.height - 85);
          ctx.lineTo(x + 4, rock.y + rock.height - 100);
          ctx.lineTo(x, rock.y + rock.height - 115);
          ctx.lineTo(x, rock.y);
          // 顶部（不规则）
          ctx.lineTo(x + 15, rock.y - 2);
          ctx.lineTo(x + 30, rock.y);
          ctx.lineTo(x + 45, rock.y - 3);
          ctx.lineTo(x + 60, rock.y);
          ctx.lineTo(x + 75, rock.y - 1);
          ctx.lineTo(x + rock.width, rock.y);
          // 右侧边缘（不规则）
          ctx.lineTo(x + rock.width - 5, rock.y + rock.height - 10);
          ctx.lineTo(x + rock.width - 3, rock.y + rock.height - 25);
          ctx.lineTo(x + rock.width - 8, rock.y + rock.height - 40);
          ctx.lineTo(x + rock.width - 2, rock.y + rock.height - 55);
          ctx.lineTo(x + rock.width - 6, rock.y + rock.height - 70);
          ctx.lineTo(x + rock.width - 1, rock.y + rock.height - 85);
          ctx.lineTo(x + rock.width - 4, rock.y + rock.height - 100);
          ctx.lineTo(x + rock.width, rock.y + rock.height - 115);
          ctx.lineTo(x + rock.width, rock.y + rock.height);
          ctx.closePath();
          ctx.fill();
          
          // 岩石纹理（深色线条）
          ctx.strokeStyle = "#3a3a3a";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x + 20, rock.y + rock.height);
          ctx.lineTo(x + 25, rock.y + rock.height - 30);
          ctx.lineTo(x + 20, rock.y + rock.height - 60);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(x + 40, rock.y + rock.height);
          ctx.lineTo(x + 45, rock.y + rock.height - 35);
          ctx.lineTo(x + 40, rock.y + rock.height - 70);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(x + 60, rock.y + rock.height);
          ctx.lineTo(x + 55, rock.y + rock.height - 25);
          ctx.lineTo(x + 60, rock.y + rock.height - 50);
          ctx.stroke();
          
          // 岩石高光
          ctx.fillStyle = "rgba(255, 255, 255, 0.2)";
          ctx.beginPath();
          ctx.moveTo(x + 10, rock.y);
          ctx.lineTo(x + 30, rock.y - 2);
          ctx.lineTo(x + 25, rock.y + 20);
          ctx.lineTo(x + 15, rock.y + 15);
          ctx.closePath();
          ctx.fill();
          
          ctx.restore();
        });
      }

      function drawTrashObstacles() {
        if (!level.trashObstacles) return;
        level.trashObstacles.forEach((trash) => {
          const x = trash.x - world.camera.x;
          if (x + trash.width < -64 || x > canvas.width + 64) return;
          ctx.save();
          ctx.translate(x + trash.width / 2, trash.y + trash.height);
          
          // 垃圾袋主体（深色）
          ctx.fillStyle = "#2c2c2c";
          ctx.beginPath();
          ctx.ellipse(0, -15, 20, 18, 0, 0, Math.PI * 2);
          ctx.fill();
          
          // 垃圾袋顶部（打结）
          ctx.fillStyle = "#1a1a1a";
          ctx.beginPath();
          ctx.arc(-8, -28, 4, 0, Math.PI * 2);
          ctx.arc(8, -28, 4, 0, Math.PI * 2);
          ctx.fill();
          
          // 垃圾袋纹理（皱褶）
          ctx.strokeStyle = "#3a3a3a";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(-15, -20);
          ctx.lineTo(-10, -10);
          ctx.lineTo(-5, -15);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(5, -15);
          ctx.lineTo(10, -10);
          ctx.lineTo(15, -20);
          ctx.stroke();
          
          // 垃圾袋上的标签/贴纸
          ctx.fillStyle = "#ff6b35";
          ctx.fillRect(-8, -18, 16, 6);
          ctx.fillStyle = "#ffffff";
          ctx.font = "bold 8px Nunito";
          ctx.textAlign = "center";
          ctx.fillText("!", 0, -13);
          
          // 垃圾袋底部阴影
          ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
          ctx.beginPath();
          ctx.ellipse(0, 0, 22, 4, 0, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.restore();
        });
      }

      function drawWaterWaves() {
        // 绘制水面波浪效果（仅在boat主题关卡）
        const isBoat = levelDefinitions[currentLevelIndex] && levelDefinitions[currentLevelIndex].theme === "boat";
        if (!isBoat) return;
        
        const waterY = world.height - 104; // 水面高度
        const waveSpeed = 2;
        const waveAmplitude = 3;
        const waveFrequency = 0.01;
        
        ctx.save();
        ctx.strokeStyle = "#3a7aa2";
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        const startX = Math.max(0, world.camera.x - 100);
        const endX = Math.min(world.width, world.camera.x + canvas.width + 100);
        
        for (let x = startX; x < endX; x += 2) {
          const waveOffset = Math.sin((x * waveFrequency) + (elapsedTime * waveSpeed)) * waveAmplitude;
          const y = waterY + waveOffset;
          const screenX = x - world.camera.x;
          
          if (x === startX) {
            ctx.moveTo(screenX, y);
          } else {
            ctx.lineTo(screenX, y);
          }
        }
        
        ctx.stroke();
        ctx.restore();
      }

      function drawBoats() {
        // 绘制所有船只
        level.boats.forEach((boat) => {
          const x = boat.x - world.camera.x;
          const y = boat.y;
          
          ctx.save();
          
          // 船体（棕色木船）
          ctx.fillStyle = "#8b6f47";
          ctx.beginPath();
          ctx.ellipse(x + boat.width / 2, y + boat.height / 2, boat.width / 2, boat.height / 2, 0, 0, Math.PI * 2);
          ctx.fill();
          
          // 船体边缘（深棕色）
          ctx.strokeStyle = "#6b5f37";
          ctx.lineWidth = 2;
          ctx.stroke();
          
          // 船内部（浅棕色）
          ctx.fillStyle = "#9b7f57";
          ctx.beginPath();
          ctx.ellipse(x + boat.width / 2, y + boat.height / 2, boat.width / 2 - 4, boat.height / 2 - 4, 0, 0, Math.PI * 2);
          ctx.fill();
          
          // 船桨（如果船在移动）
          if (Math.abs(boat.vx) > 5) {
            const paddleX = boat.vx > 0 ? x + boat.width - 15 : x + 15;
            const paddleY = y + boat.height / 2;
            const paddleOffset = Math.sin(elapsedTime * 10) * 8;
            
            ctx.fillStyle = "#654321";
            ctx.fillRect(paddleX - 2, paddleY - 10 + paddleOffset, 4, 20);
            
            // 桨叶
            ctx.fillStyle = "#4a3a21";
            ctx.fillRect(paddleX - 4, paddleY - 10 + paddleOffset, 8, 6);
          }
          
          ctx.restore();
        });
      }

      function drawFlag() {
        if (!level.flag) return;
        const flag = level.flag;
        const x = flag.x - world.camera.x;
        ctx.fillStyle = "#d7d7d7";
        ctx.fillRect(x, flag.y, 6, flag.height);

        ctx.fillStyle = "#ff5252";
        ctx.beginPath();
        ctx.moveTo(x + 6, flag.flagY + flag.flagOffset);
        ctx.lineTo(x + 130, flag.flagY + 20 + flag.flagOffset);
        ctx.lineTo(x + 6, flag.flagY + 40 + flag.flagOffset);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = "#ffffff";
        ctx.font = "bold 22px Nunito";
        ctx.fillText("FY", x + 50, flag.flagY + 27 + flag.flagOffset);
      }

      function drawPlayer() {
        const x = player.x - world.camera.x;
        const y = player.y;
        ctx.save();
        const baseWidth = 38;
        const baseHeight = 48;
        const scaleX = player.width / baseWidth;
        const scaleY = player.height / baseHeight;
        ctx.translate(x + player.width / 2, y + player.height / 2);
        ctx.scale((player.facing === -1 ? -1 : 1) * scaleX, scaleY);
        if (player.invincibleTimer > 0 && Math.floor(player.invincibleTimer * 20) % 2 === 0) {
          ctx.globalAlpha = 0.5;
        }
        ctx.translate(-baseWidth / 2, -baseHeight / 2);

        ctx.fillStyle = "#2b2b3a";
        ctx.beginPath();
        ctx.moveTo(6, 4);
        ctx.lineTo(24, -6);
        ctx.lineTo(42, 4);
        ctx.lineTo(24, 14);
        ctx.closePath();
        ctx.fill();
        ctx.fillRect(20, 10, 8, 10);
        ctx.strokeStyle = "#f5c542";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(24, 14);
        ctx.lineTo(24, 26);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(24, 28, 3, 0, Math.PI * 2);
        ctx.fillStyle = "#f5c542";
        ctx.fill();

        ctx.fillStyle = "#ffe0b2";
        ctx.beginPath();
        ctx.arc(24, 18, 12, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillRect(18, 18, 12, 10);

        ctx.fillStyle = "#f7f7fb";
        ctx.fillRect(10, 20, 28, 28);
        ctx.strokeStyle = "#d1d1df";
        ctx.lineWidth = 2;
        ctx.strokeRect(10, 20, 28, 28);
        ctx.fillRect(12, 36, 8, 14);
        ctx.fillRect(26, 36, 8, 14);
        ctx.fillStyle = "#c2c2d6";
        ctx.fillRect(18, 22, 12, 4);
        ctx.fillRect(20, 30, 8, 10);

        ctx.fillStyle = "#263238";
        ctx.beginPath();
        ctx.arc(20, 16, 2, 0, Math.PI * 2);
        ctx.arc(28, 16, 2, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = "#d84315";
        ctx.beginPath();
        ctx.moveTo(18, 22);
        ctx.quadraticCurveTo(24, 28, 30, 22);
        ctx.stroke();

        // 如果是第二关（地下关卡），绘制头灯
        const currentDefinition = levelDefinitions[currentLevelIndex];
        if (currentDefinition && currentDefinition.theme === "underground") {
          // 头灯带子
          ctx.fillStyle = "#1a1a1a";
          ctx.fillRect(18, 8, 12, 4);
          // 头灯主体
          ctx.fillStyle = "#f5c542";
          ctx.beginPath();
          ctx.arc(24, 10, 6, 0, Math.PI * 2);
          ctx.fill();
          // 头灯光源（白色高光）
          ctx.fillStyle = "#ffffff";
          ctx.beginPath();
          ctx.arc(24, 10, 3, 0, Math.PI * 2);
          ctx.fill();
          // 头灯边框
          ctx.strokeStyle = "#1a1a1a";
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.arc(24, 10, 6, 0, Math.PI * 2);
          ctx.stroke();
        }

        // 如果是水下关卡，绘制潜水装备
        if (currentDefinition && currentDefinition.theme === "water") {
          // 绘制潜水镜（在头部）
          ctx.fillStyle = "#1a1a2e";
          ctx.beginPath();
          ctx.arc(20, 16, 6, 0, Math.PI * 2);
          ctx.arc(28, 16, 6, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#4a90e2";
          ctx.beginPath();
          ctx.arc(20, 16, 4, 0, Math.PI * 2);
          ctx.arc(28, 16, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = "#ffffff";
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.arc(20, 16, 6, 0, Math.PI * 2);
          ctx.arc(28, 16, 6, 0, Math.PI * 2);
          ctx.stroke();
          // 连接两个镜片的带子
          ctx.strokeStyle = "#1a1a2e";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(26, 16);
          ctx.lineTo(22, 16);
          ctx.stroke();
          
          // 绘制氧气瓶（在背部）
          ctx.fillStyle = "#2c3e50";
          ctx.fillRect(32, 24, 8, 20);
          ctx.fillStyle = "#34495e";
          ctx.fillRect(33, 25, 6, 18);
          // 氧气瓶顶部
          ctx.fillStyle = "#1a1a2e";
          ctx.fillRect(33, 24, 6, 3);
          // 氧气瓶阀门
          ctx.fillStyle = "#e74c3c";
          ctx.beginPath();
          ctx.arc(36, 24, 2, 0, Math.PI * 2);
          ctx.fill();
          // 氧气管（连接到嘴巴）
          ctx.strokeStyle = "#34495e";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(36, 28);
          ctx.quadraticCurveTo(32, 30, 28, 26);
          ctx.stroke();
          ctx.fillStyle = "#34495e";
          ctx.beginPath();
          ctx.arc(28, 26, 2, 0, Math.PI * 2);
          ctx.fill();
          
          // 绘制脚蹼（替换原来的脚，带摆动动画）
          // 计算摆动角度（使用动画计时器创建游泳动作）
          const swimSpeed = 10; // 摆动速度
          const swimAmplitude = 20; // 摆动幅度（度）
          const leftFlapAngle = Math.sin(player.animationTimer * swimSpeed) * swimAmplitude * (Math.PI / 180);
          const rightFlapAngle = Math.sin(player.animationTimer * swimSpeed + Math.PI) * swimAmplitude * (Math.PI / 180); // 与左脚相反相位
          
          ctx.fillStyle = "#ff6b35";
          
          // 左脚蹼（从脚的位置 y:38 开始延伸，带摆动）
          ctx.save();
          ctx.translate(9, 48); // 以脚蹼中心为旋转点（y:38 + 10 = 48，脚蹼中心）
          ctx.rotate(leftFlapAngle);
          // 脚蹼形状（从中心向两侧延伸）
          ctx.beginPath();
          ctx.moveTo(-4, -10); // 顶部左侧
          ctx.lineTo(4, -10); // 顶部右侧
          ctx.lineTo(6, -6); // 右侧上
          ctx.lineTo(8, 0); // 右侧中
          ctx.lineTo(6, 6); // 右侧下
          ctx.lineTo(2, 10); // 底部右侧
          ctx.lineTo(-6, 10); // 底部左侧
          ctx.lineTo(-10, 6); // 左侧下
          ctx.lineTo(-12, 0); // 左侧中
          ctx.lineTo(-10, -6); // 左侧上
          ctx.closePath();
          ctx.fill();
          // 左脚蹼纹理（分叉线）
          ctx.strokeStyle = "#ff8c5a";
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.moveTo(-4, -10);
          ctx.lineTo(-2, 0);
          ctx.lineTo(-4, 6);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(4, -10);
          ctx.lineTo(2, 0);
          ctx.lineTo(4, 6);
          ctx.stroke();
          ctx.restore();
          
          // 右脚蹼（与左脚相反相位摆动）
          ctx.save();
          ctx.translate(29, 48); // 以脚蹼中心为旋转点
          ctx.rotate(rightFlapAngle);
          // 脚蹼形状（从中心向两侧延伸）
          ctx.beginPath();
          ctx.moveTo(-4, -10); // 顶部左侧
          ctx.lineTo(4, -10); // 顶部右侧
          ctx.lineTo(6, -6); // 右侧上
          ctx.lineTo(8, 0); // 右侧中
          ctx.lineTo(6, 6); // 右侧下
          ctx.lineTo(2, 10); // 底部右侧
          ctx.lineTo(-6, 10); // 底部左侧
          ctx.lineTo(-10, 6); // 左侧下
          ctx.lineTo(-12, 0); // 左侧中
          ctx.lineTo(-10, -6); // 左侧上
          ctx.closePath();
          ctx.fill();
          // 右脚蹼纹理（分叉线）
          ctx.strokeStyle = "#ff8c5a";
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.moveTo(-4, -10);
          ctx.lineTo(-2, 0);
          ctx.lineTo(-4, 6);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(4, -10);
          ctx.lineTo(2, 0);
          ctx.lineTo(4, 6);
          ctx.stroke();
          ctx.restore();
        } else {
          // 非水下关卡，绘制原来的脚
          ctx.fillStyle = "#6d4c41";
          ctx.fillRect(6, 38, 12, 10);
          ctx.fillRect(32, 38, 12, 10);
        }

        // 如果玩家在滑板上，绘制滑板
        if (player.onSkateboard) {
          ctx.save();
          ctx.translate(0, baseHeight - 6);
          // 滑板板面
          ctx.fillStyle = "#8b4513";
          ctx.fillRect(-25, -6, 50, 12);
          // 滑板轮子
          ctx.fillStyle = "#2c2c2c";
          ctx.beginPath();
          ctx.arc(-18, 0, 5, 0, Math.PI * 2);
          ctx.arc(-6, 0, 5, 0, Math.PI * 2);
          ctx.arc(6, 0, 5, 0, Math.PI * 2);
          ctx.arc(18, 0, 5, 0, Math.PI * 2);
          ctx.fill();
          // 轮子高光
          ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
          ctx.beginPath();
          ctx.arc(-18, -2, 2, 0, Math.PI * 2);
          ctx.arc(-6, -2, 2, 0, Math.PI * 2);
          ctx.arc(6, -2, 2, 0, Math.PI * 2);
          ctx.arc(18, -2, 2, 0, Math.PI * 2);
          ctx.fill();
          // 滑板装饰
          ctx.strokeStyle = "#654321";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(-20, 0);
          ctx.lineTo(20, 0);
          ctx.stroke();
          ctx.restore();
        }

        ctx.restore();
      }

      function drawGoombas() {
        level.entities.forEach((entity) => {
          if (!(entity instanceof Goomba || entity instanceof Shark || entity instanceof Monkey || entity instanceof Bat || entity instanceof Plane)) return;
          const x = entity.x - world.camera.x;
          if (x + entity.width < -64 || x > canvas.width + 64) return;
          ctx.save();
          ctx.translate(x + entity.width / 2, entity.y + entity.height);
          
          if (entity instanceof Shark) {
            // 绘制鲨鱼
            // 先应用方向翻转（鲨鱼默认面向右侧，directionX为-1时向左移动，需要翻转）
            const direction = entity.directionX > 0 ? 1 : -1;
            ctx.scale(direction, 1);
            // 然后应用压扁效果
            ctx.scale(1, entity.state === "squashed" ? 0.3 : 1);
            
            // 绘制鲨鱼身体（椭圆形，身体中心偏右）
            ctx.fillStyle = entity.state === "squashed" ? "#4a5568" : "#5a6c7d";
            ctx.beginPath();
            ctx.ellipse(2, -18, 22, 16, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // 鲨鱼头部（尖锐的嘴巴在右侧）
            ctx.beginPath();
            ctx.moveTo(18, -18);
            ctx.lineTo(26, -12);
            ctx.lineTo(24, -6);
            ctx.lineTo(16, -8);
            ctx.closePath();
            ctx.fill();
            
            // 鲨鱼嘴巴（张开的嘴巴）
            ctx.fillStyle = "#1a1a2e";
            ctx.beginPath();
            ctx.arc(22, -10, 7, 0, Math.PI * 2);
            ctx.fill();
            
            // 牙齿（锋利的牙齿）
            ctx.fillStyle = "#ffffff";
            ctx.beginPath();
            ctx.moveTo(18, -12);
            ctx.lineTo(20, -8);
            ctx.lineTo(22, -10);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(22, -10);
            ctx.lineTo(24, -8);
            ctx.lineTo(26, -12);
            ctx.closePath();
            ctx.fill();
            
            // 眼睛（在身体左侧）
            ctx.fillStyle = "#ffffff";
            ctx.beginPath();
            ctx.arc(-6, -20, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#000000";
            ctx.beginPath();
            ctx.arc(-6, -20, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#ffffff";
            ctx.beginPath();
            ctx.arc(-5, -21, 1.5, 0, Math.PI * 2);
            ctx.fill();
            
            // 背鳍（在身体上方）
            ctx.fillStyle = entity.state === "squashed" ? "#3d4a5c" : "#4a5c6d";
            ctx.beginPath();
            ctx.moveTo(0, -30);
            ctx.lineTo(0, -24);
            ctx.lineTo(-6, -26);
            ctx.closePath();
            ctx.fill();
            
            // 侧鳍（在身体下方左侧）
            ctx.beginPath();
            ctx.moveTo(-10, -14);
            ctx.lineTo(-14, -10);
            ctx.lineTo(-12, -6);
            ctx.closePath();
            ctx.fill();
            
            // 尾巴（会摆动）
            if (entity.state !== "squashed") {
              const tailOffset = Math.sin(entity.animationTimer * 8) * 2;
              ctx.beginPath();
              ctx.moveTo(-18, -18);
              ctx.lineTo(-24 + tailOffset, -22);
              ctx.lineTo(-22 + tailOffset, -14);
              ctx.closePath();
              ctx.fill();
            }
          } else if (entity instanceof Monkey) {
            // 绘制猴子
            ctx.scale(entity.state === "squashed" ? 1 : 1, entity.state === "squashed" ? 0.3 : 1);
            
            // 猴子身体（棕色）
            ctx.fillStyle = entity.state === "squashed" ? "#8b6f47" : "#a67c52";
            ctx.beginPath();
            ctx.ellipse(0, -18, 18, 20, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // 猴子头部（圆形，稍微向上）
            ctx.fillStyle = entity.state === "squashed" ? "#8b6f47" : "#a67c52";
            ctx.beginPath();
            ctx.arc(0, -32, 14, 0, Math.PI * 2);
            ctx.fill();
            
            // 猴子脸部（浅棕色）
            ctx.fillStyle = "#d4a574";
            ctx.beginPath();
            ctx.ellipse(0, -30, 10, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // 猴子眼睛
            ctx.fillStyle = "#000000";
            ctx.beginPath();
            ctx.arc(-5, -32, 2.5, 0, Math.PI * 2);
            ctx.arc(5, -32, 2.5, 0, Math.PI * 2);
            ctx.fill();
            
            // 眼睛高光
            ctx.fillStyle = "#ffffff";
            ctx.beginPath();
            ctx.arc(-4, -33, 1, 0, Math.PI * 2);
            ctx.arc(6, -33, 1, 0, Math.PI * 2);
            ctx.fill();
            
            // 猴子鼻子（小三角形）
            ctx.fillStyle = "#8b6f47";
            ctx.beginPath();
            ctx.moveTo(0, -28);
            ctx.lineTo(-3, -26);
            ctx.lineTo(3, -26);
            ctx.closePath();
            ctx.fill();
            
            // 猴子嘴巴
            ctx.strokeStyle = "#8b6f47";
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.arc(0, -24, 4, 0, Math.PI);
            ctx.stroke();
            
            // 猴子手臂（根据跳跃状态调整位置）
            const armOffset = entity.onGround ? 0 : Math.sin(entity.animationTimer * 8) * 5;
            ctx.fillStyle = entity.state === "squashed" ? "#8b6f47" : "#a67c52";
            // 左手臂
            ctx.beginPath();
            ctx.ellipse(-14 + armOffset, -16, 6, 12, -0.3, 0, Math.PI * 2);
            ctx.fill();
            // 右手臂
            ctx.beginPath();
            ctx.ellipse(14 - armOffset, -16, 6, 12, 0.3, 0, Math.PI * 2);
            ctx.fill();
            
            // 猴子腿
            ctx.fillStyle = entity.state === "squashed" ? "#8b6f47" : "#a67c52";
            ctx.fillRect(-10, -4, 8, 14);
            ctx.fillRect(2, -4, 8, 14);
            
            // 猴子尾巴（会摆动）
            if (entity.state !== "squashed") {
              const tailOffset = Math.sin(entity.animationTimer * 6) * 8;
              ctx.strokeStyle = entity.state === "squashed" ? "#8b6f47" : "#a67c52";
              ctx.lineWidth = 4;
              ctx.beginPath();
              ctx.moveTo(-12, -8);
              ctx.quadraticCurveTo(-18 + tailOffset, -12, -20 + tailOffset, -4);
              ctx.stroke();
            }
          } else if (entity instanceof Bat) {
            // 绘制蝙蝠
            const direction = entity.directionX > 0 ? 1 : -1;
            ctx.scale(direction, 1);
            ctx.scale(1, entity.state === "squashed" ? 0.3 : 1);
            
            // 蝙蝠身体（深灰色/黑色）
            ctx.fillStyle = entity.state === "squashed" ? "#2a2a2a" : "#1a1a1a";
            ctx.beginPath();
            ctx.ellipse(0, -14, 12, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // 蝙蝠头部（圆形）
            ctx.fillStyle = entity.state === "squashed" ? "#2a2a2a" : "#1a1a1a";
            ctx.beginPath();
            ctx.arc(0, -22, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // 蝙蝠眼睛（红色发光）
            ctx.fillStyle = "#ff0000";
            ctx.beginPath();
            ctx.arc(-4, -22, 2.5, 0, Math.PI * 2);
            ctx.arc(4, -22, 2.5, 0, Math.PI * 2);
            ctx.fill();
            
            // 眼睛高光
            ctx.fillStyle = "#ffffff";
            ctx.beginPath();
            ctx.arc(-3.5, -22.5, 1, 0, Math.PI * 2);
            ctx.arc(4.5, -22.5, 1, 0, Math.PI * 2);
            ctx.fill();
            
            // 蝙蝠翅膀（会扇动）
            if (entity.state !== "squashed") {
              const wingFlap = Math.sin(entity.wingFlapTimer) * 0.3 + 0.7; // 0.4 到 1.0
              const wingAngle = (1 - wingFlap) * Math.PI * 0.4; // 翅膀扇动角度
              
              ctx.fillStyle = "#2a2a2a";
              // 左翅膀
              ctx.save();
              ctx.translate(-8, -14);
              ctx.rotate(-wingAngle);
              ctx.beginPath();
              ctx.ellipse(0, 0, 18, 8, 0, 0, Math.PI * 2);
              ctx.fill();
              ctx.restore();
              
              // 右翅膀
              ctx.save();
              ctx.translate(8, -14);
              ctx.rotate(wingAngle);
              ctx.beginPath();
              ctx.ellipse(0, 0, 18, 8, 0, 0, Math.PI * 2);
              ctx.fill();
              ctx.restore();
              
              // 翅膀骨架（细线）
              ctx.strokeStyle = "#1a1a1a";
              ctx.lineWidth = 1.5;
              // 左翅膀骨架
              ctx.save();
              ctx.translate(-8, -14);
              ctx.rotate(-wingAngle);
              ctx.beginPath();
              ctx.moveTo(0, 0);
              ctx.lineTo(-12, -4);
              ctx.moveTo(0, 0);
              ctx.lineTo(-10, 4);
              ctx.stroke();
              ctx.restore();
              
              // 右翅膀骨架
              ctx.save();
              ctx.translate(8, -14);
              ctx.rotate(wingAngle);
              ctx.beginPath();
              ctx.moveTo(0, 0);
              ctx.lineTo(12, -4);
              ctx.moveTo(0, 0);
              ctx.lineTo(10, 4);
              ctx.stroke();
              ctx.restore();
            }
            
            // 蝙蝠耳朵
            ctx.fillStyle = entity.state === "squashed" ? "#2a2a2a" : "#1a1a1a";
            ctx.beginPath();
            ctx.moveTo(-6, -28);
            ctx.lineTo(-4, -32);
            ctx.lineTo(-2, -30);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(6, -28);
            ctx.lineTo(4, -32);
            ctx.lineTo(2, -30);
            ctx.closePath();
            ctx.fill();
          } else if (entity instanceof Plane) {
            // 绘制小飞机
            const direction = entity.direction > 0 ? 1 : -1;
            ctx.scale(direction, 1);
            ctx.scale(1, entity.state === "squashed" ? 0.3 : 1);
            
            // 根据状态调整角度（起飞时向上倾斜，降落时向下倾斜）
            let angle = 0;
            if (entity.state === "takingOff") {
              angle = -0.3; // 向上倾斜
            } else if (entity.state === "landing") {
              angle = 0.2; // 向下倾斜
            } else if (entity.state === "flying") {
              angle = Math.sin(entity.animationTimer * 3) * 0.1; // 轻微摆动
            }
            ctx.rotate(angle);
            
            // 飞机主体（白色/银色）
            ctx.fillStyle = entity.state === "squashed" ? "#888888" : "#e0e0e0";
            ctx.beginPath();
            ctx.ellipse(0, -12, 20, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // 飞机机头（更尖锐）
            ctx.fillStyle = entity.state === "squashed" ? "#888888" : "#c0c0c0";
            ctx.beginPath();
            ctx.moveTo(20, -12);
            ctx.lineTo(28, -8);
            ctx.lineTo(26, -4);
            ctx.lineTo(18, -8);
            ctx.closePath();
            ctx.fill();
            
            // 机头窗户
            ctx.fillStyle = "#4a90e2";
            ctx.beginPath();
            ctx.arc(22, -10, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // 机翼（主翼）
            ctx.fillStyle = entity.state === "squashed" ? "#888888" : "#d0d0d0";
            // 左翼
            ctx.beginPath();
            ctx.moveTo(-8, -12);
            ctx.lineTo(-18, -8);
            ctx.lineTo(-16, -4);
            ctx.lineTo(-6, -8);
            ctx.closePath();
            ctx.fill();
            // 右翼
            ctx.beginPath();
            ctx.moveTo(8, -12);
            ctx.lineTo(18, -8);
            ctx.lineTo(16, -4);
            ctx.lineTo(6, -8);
            ctx.closePath();
            ctx.fill();
            
            // 尾翼
            ctx.fillStyle = entity.state === "squashed" ? "#888888" : "#d0d0d0";
            // 垂直尾翼
            ctx.beginPath();
            ctx.moveTo(-18, -12);
            ctx.lineTo(-22, -16);
            ctx.lineTo(-20, -20);
            ctx.lineTo(-16, -16);
            ctx.closePath();
            ctx.fill();
            
            // 水平尾翼
            ctx.beginPath();
            ctx.moveTo(-18, -8);
            ctx.lineTo(-24, -6);
            ctx.lineTo(-22, -4);
            ctx.lineTo(-16, -6);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(-18, -16);
            ctx.lineTo(-24, -18);
            ctx.lineTo(-22, -20);
            ctx.lineTo(-16, -18);
            ctx.closePath();
            ctx.fill();
            
            // 引擎（机翼上的圆形）
            if (entity.state !== "squashed") {
              ctx.fillStyle = "#ff6b35";
              // 左引擎
              ctx.beginPath();
              ctx.arc(-12, -8, 3, 0, Math.PI * 2);
              ctx.fill();
              // 右引擎
              ctx.beginPath();
              ctx.arc(12, -8, 3, 0, Math.PI * 2);
              ctx.fill();
              
              // 引擎火焰（起飞和飞行时）
              if (entity.state === "takingOff" || entity.state === "flying") {
                ctx.fillStyle = "#ffaa00";
                // 左引擎火焰
                ctx.beginPath();
                ctx.ellipse(-12, -2, 4, 6, 0, 0, Math.PI * 2);
                ctx.fill();
                // 右引擎火焰
                ctx.beginPath();
                ctx.ellipse(12, -2, 4, 6, 0, 0, Math.PI * 2);
                ctx.fill();
              }
            }
          } else {
            // 绘制Goomba
            const isGhost = activeTheme && activeTheme.key === "ghost";
            
            if (isGhost) {
              // 绘制幽灵形象
              ctx.scale(entity.state === "squashed" ? 1 : 1, entity.state === "squashed" ? 0.3 : 1);
              
              // 幽灵主体 - 半透明白色/淡紫色
              ctx.globalAlpha = 0.85;
              ctx.fillStyle = entity.state === "squashed" ? "rgba(220, 200, 255, 0.6)" : "rgba(240, 230, 255, 0.9)";
              
              // 绘制幽灵身体（上半部分圆形，下半部分波浪形）
              ctx.beginPath();
              // 从左边开始画半圆（上半部分）
              ctx.arc(0, -25, 18, Math.PI, 0, false);
              
              // 波浪形底部（从右到左）
              const waveOffset = entity.state === "squashed" ? 0 : Math.sin((Date.now() / 300 + entity.x * 0.01) % (Math.PI * 2)) * 3;
              const baseY = -10;
              ctx.lineTo(18, baseY + waveOffset);
              ctx.quadraticCurveTo(12, baseY - 3 + waveOffset, 6, baseY + waveOffset);
              ctx.quadraticCurveTo(0, baseY - 3 + waveOffset, -6, baseY + waveOffset);
              ctx.quadraticCurveTo(-12, baseY - 3 + waveOffset, -18, baseY + waveOffset);
              ctx.closePath();
              ctx.fill();
              
              // 幽灵眼睛
              ctx.globalAlpha = 1;
              ctx.fillStyle = "#1a0f26";
              ctx.beginPath();
              ctx.arc(-8, -22, 4, 0, Math.PI * 2);
              ctx.arc(8, -22, 4, 0, Math.PI * 2);
              ctx.fill();
              
              // 眼睛高光
              ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
              ctx.beginPath();
              ctx.arc(-7, -23, 1.5, 0, Math.PI * 2);
              ctx.arc(9, -23, 1.5, 0, Math.PI * 2);
              ctx.fill();
              
              // 幽灵外发光效果
              if (entity.state !== "squashed") {
                ctx.shadowBlur = 15;
                ctx.shadowColor = "rgba(200, 150, 255, 0.6)";
                ctx.strokeStyle = "rgba(200, 150, 255, 0.4)";
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.shadowBlur = 0;
              }
            } else {
              // 原来的Goomba形象
          ctx.scale(entity.state === "squashed" ? 1 : 1, entity.state === "squashed" ? 0.3 : 1);

          ctx.fillStyle = "#a45c2a";
          ctx.beginPath();
          ctx.ellipse(0, -20, 20, 24, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillRect(-22, -26, 44, 20);

          ctx.fillStyle = "#fdf4ed";
          ctx.fillRect(-14, -32, 12, 16);
          ctx.fillRect(2, -32, 12, 16);
          ctx.fillStyle = "#2c2c2c";
          ctx.beginPath();
          ctx.arc(-8, -24, 4, 0, Math.PI * 2);
          ctx.arc(8, -24, 4, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = "#5d3d20";
          ctx.fillRect(-18, -6, 12, 16);
          ctx.fillRect(6, -6, 12, 16);
            }
          }

          ctx.restore();
        });
      }

      function drawFlag() {
        if (!level.flag) return;
        const flag = level.flag;
        const x = flag.x - world.camera.x;
        ctx.fillStyle = "#d7d7d7";
        ctx.fillRect(x, flag.y, 6, flag.height);

        ctx.fillStyle = "#ff5252";
        ctx.beginPath();
        ctx.moveTo(x + 6, flag.flagY + flag.flagOffset);
        ctx.lineTo(x + 130, flag.flagY + 20 + flag.flagOffset);
        ctx.lineTo(x + 6, flag.flagY + 40 + flag.flagOffset);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = "#ffffff";
        ctx.font = "bold 22px Nunito";
        ctx.fillText("FY", x + 50, flag.flagY + 27 + flag.flagOffset);
      }

      function draw() {
        drawBackground();
        drawGround();
        drawWaterWaves(); // 水面波浪（在船之前绘制）
        drawPlatforms();
        drawBricks();
        drawCoins();
        drawMushrooms();
        drawSkateboards();
        drawSnowPiles();
        drawIcePillars();
        drawPumpkinObstacles();
        drawCoralObstacles();
        drawRockObstacles();
        drawTrashObstacles();
        drawBoats(); // 绘制船只
        levelCelebration.draw();
        drawFireballs();
        drawFallingCandies();
        drawFlag();
        drawGoombas();
        drawPlayer();
        drawImpactFactor();
      }

      function drawHeadlightEffect() {
        // 在玩家前方绘制光照效果，让垃圾和蝙蝠更清晰可见
        ctx.save();
        
        const playerScreenX = player.x - world.camera.x;
        const playerScreenY = player.y + player.height / 2;
        const lightDistance = 350; // 增大光照范围（约3.5米）
        const lightWidth = 400; // 光照宽度
        
        // 计算光照区域（玩家前方，根据玩家朝向）
        let lightStartX, lightEndX;
        if (player.facing > 0) {
          // 向右，光照从玩家右侧开始
          lightStartX = playerScreenX + player.width / 2;
          lightEndX = lightStartX + lightDistance;
        } else {
          // 向左，光照从玩家左侧开始
          lightEndX = playerScreenX - player.width / 2;
          lightStartX = lightEndX - lightDistance;
        }
        
        const lightTop = playerScreenY - lightWidth / 2;
        const lightBottom = playerScreenY + lightWidth / 2;
        
        // 创建均匀的亮色区域（矩形，不渐变）
        ctx.globalCompositeOperation = "screen";
        ctx.fillStyle = "rgba(255, 255, 220, 0.6)"; // 均匀一致的亮黄色
        ctx.fillRect(lightStartX, lightTop, lightEndX - lightStartX, lightBottom - lightTop);
        
        ctx.restore();
      }

      function drawImpactFactor() {
        // 在canvas右上角绘制Impact factor
        ctx.save();
        
        // 背景框
        const padding = 12;
        const boxWidth = 180;
        const boxHeight = 50;
        const x = canvas.width - boxWidth - padding;
        const y = padding;
        
        // 半透明背景
        ctx.fillStyle = "rgba(0, 0, 0, 0.6)";
        ctx.fillRect(x, y, boxWidth, boxHeight);
        
        // 边框
        ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, boxWidth, boxHeight);
        
        // 标题
        ctx.fillStyle = "#ffffff";
        ctx.font = "bold 14px Nunito";
        ctx.textAlign = "left";
        ctx.fillText("Impact Factor", x + 10, y + 20);
        
        // Impact factor值
        const impactValue = player.impactFactor.toFixed(1);
        ctx.fillStyle = "#f5c542";
        ctx.font = "bold 20px Nunito";
        ctx.textAlign = "right";
        ctx.fillText(impactValue, x + boxWidth - 10, y + 42);
        
        // 进度条背景
        const progressBarX = x + 10;
        const progressBarY = y + 28;
        const progressBarWidth = boxWidth - 20;
        const progressBarHeight = 8;
        ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
        ctx.fillRect(progressBarX, progressBarY, progressBarWidth, progressBarHeight);
        
        // 进度条填充（最多80分，8关×10分）
        const maxImpact = 80; // 8关×10分
        const progress = Math.min(maxImpact, player.impactFactor) / maxImpact;
        const progressWidth = progressBarWidth * progress;
        
        // 根据进度值使用不同颜色
        if (progress >= 0.8) {
          ctx.fillStyle = "#21a179"; // 绿色（高）
        } else if (progress >= 0.5) {
          ctx.fillStyle = "#f5c542"; // 黄色（中）
        } else {
          ctx.fillStyle = "#e04040"; // 红色（低）
        }
        ctx.fillRect(progressBarX, progressBarY, progressWidth, progressBarHeight);
        
        ctx.restore();
      }

      function loop(timestamp) {
        if (!loop.lastTime) loop.lastTime = timestamp;
        const delta = Math.min(0.05, (timestamp - loop.lastTime) / 1000);
        loop.lastTime = timestamp;

        if (running) {
          update(delta);
        }
        levelCelebration.update(delta);
        draw();
        requestAnimationFrame(loop);
      }

      document.addEventListener("keydown", (event) => {
        const code = event.code;
        if (
          ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Space"].includes(code)
        ) {
          event.preventDefault();
        }
        if (code === "KeyT") {
          event.preventDefault();
          resetGame();
          return;
        }
        if (code === "KeyF") {
          const fireball = player.fire();
          if (fireball) {
            level.projectiles.push(fireball);
            showToast("Research fireball launched!", 900);
          }
          return;
        }
        // 管道功能已禁用
        // if (code === "ArrowDown" || code === "KeyS") {
        //   if (tryEnterPipe()) {
        //     event.preventDefault();
        //     return;
        //   }
        // }
        keyState.add(code);
      });

      document.addEventListener("keyup", (event) => {
        keyState.delete(event.code);
      });

      window.addEventListener("blur", () => {
        keyState.clear();
      });

      const restartButton = document.getElementById("restart-current-level");
      if (restartButton) {
        restartButton.addEventListener("click", () => {
          restartCurrentLevel();
        });
      }

      const levelSelect = document.getElementById("level-select");
      if (levelSelect) {
        levelSelect.addEventListener("change", (event) => {
          const selectedLevel = parseInt(event.target.value, 10);
          if (!isNaN(selectedLevel) && selectedLevel >= 0 && selectedLevel < levelDefinitions.length) {
            resetGame({ showMessage: true, startLevel: selectedLevel });
            levelSelect.value = selectedLevel.toString();
          }
        });
      }


      resetGame({ showMessage: false, startLevel: 2 });
      requestAnimationFrame(loop);
    </script>
  </body>
</html>
