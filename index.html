<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¿è¿çœ‹æ¶ˆé™¤æ¸¸æˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        header {
            text-align: center;
            color: white;
            margin-bottom: 20px;
        }

        h1 {
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            margin-bottom: 10px;
        }

        .game-controls {
            background: white;
            padding: 15px 30px;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            margin-bottom: 20px;
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .difficulty-selector {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .difficulty-selector label {
            font-weight: bold;
            color: #333;
        }

        .difficulty-btn {
            padding: 8px 16px;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        .difficulty-btn:hover {
            background: #667eea;
            color: white;
            transform: translateY(-2px);
        }

        .difficulty-btn.active {
            background: #667eea;
            color: white;
        }

        .game-info {
            display: flex;
            gap: 20px;
            align-items: center;
            font-weight: bold;
            color: #333;
        }

        .timer {
            font-size: 1.2em;
            color: #e74c3c;
        }

        .score {
            font-size: 1.2em;
            color: #27ae60;
        }

        .moves {
            font-size: 1.2em;
            color: #3498db;
        }

        .game-container {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
            margin-bottom: 20px;
        }

        .game-board {
            display: grid;
            gap: 6px;
            max-width: 800px;
            margin: 0 auto;
        }

        .tile {
            width: 80px;
            height: 80px;
            border: 2px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #f8f9fa;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
        }

        @media (max-width: 768px) {
            .tile {
                width: 60px;
                height: 60px;
            }
        }

        .tile:hover:not(.empty) {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            border-color: #667eea;
        }

        .tile.selected {
            border-color: #e74c3c;
            border-width: 3px;
            transform: translateY(-8px);
            box-shadow: 0 8px 20px rgba(231, 76, 60, 0.4);
        }

        .tile.matched {
            animation: matchAnimation 0.5s ease;
            opacity: 0;
            pointer-events: none;
        }

        .tile.empty {
            opacity: 0;
            pointer-events: none;
        }

        @keyframes matchAnimation {
            0% {
                transform: scale(1) rotate(0deg);
            }
            50% {
                transform: scale(1.2) rotate(180deg);
            }
            100% {
                transform: scale(0) rotate(360deg);
                opacity: 0;
            }
        }

        .tile img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 6px;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            color: white;
            font-size: 16px;
        }

        .btn-start {
            background: #27ae60;
        }

        .btn-start:hover {
            background: #2ecc71;
            transform: translateY(-2px);
        }

        .btn-hint {
            background: #f39c12;
        }

        .btn-hint:hover {
            background: #e67e22;
            transform: translateY(-2px);
        }

        .btn-restart {
            background: #e74c3c;
        }

        .btn-restart:hover {
            background: #c0392b;
            transform: translateY(-2px);
        }

        .game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            text-align: center;
            z-index: 1000;
            display: none;
        }

        .game-over h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 2em;
        }

        .game-over p {
            color: #666;
            margin-bottom: 20px;
            font-size: 1.2em;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 999;
            display: none;
        }

        .connection-line {
            position: absolute;
            background: #e74c3c;
            z-index: 100;
            pointer-events: none;
            border-radius: 2px;
        }

        @media (max-width: 768px) {
            .tile {
                width: 60px;
                height: 60px;
            }

            .game-controls {
                flex-direction: column;
                align-items: stretch;
            }

            .difficulty-selector {
                justify-content: center;
            }

            .game-info {
                justify-content: space-around;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>ğŸ® è¿è¿çœ‹æ¶ˆé™¤æ¸¸æˆ</h1>
        <p>æ‰¾å‡ºç›¸åŒçš„å›¾ç‰‡ï¼Œç”¨æœ€å¤š3æ¡ç›´çº¿è¿æ¥å®ƒä»¬ï¼</p>
    </header>

    <section class="game-controls">
        <div class="difficulty-selector">
            <label>éš¾åº¦çº§åˆ«ï¼š</label>
            <button class="difficulty-btn active" data-level="easy">ç®€å•</button>
            <button class="difficulty-btn" data-level="medium">ä¸­ç­‰</button>
            <button class="difficulty-btn" data-level="hard">å›°éš¾</button>
                    </div>

        <div class="game-info">
            <div class="timer">æ—¶é—´: <span id="time">00:00</span></div>
            <div class="score">å¾—åˆ†: <span id="score">0</span></div>
            <div class="moves">æ­¥æ•°: <span id="moves">0</span></div>
        </div>
    </section>

    <section class="game-container">
        <div class="game-board" id="gameBoard"></div>
    </section>

    <section class="action-buttons">
        <button class="btn btn-start" id="startBtn">å¼€å§‹æ¸¸æˆ</button>
        <button class="btn btn-hint" id="hintBtn">æç¤º (3)</button>
        <button class="btn btn-restart" id="restartBtn">é‡æ–°å¼€å§‹</button>
    </section>

    <div class="overlay" id="overlay"></div>
    <div class="game-over" id="gameOver">
        <h2 id="gameOverTitle">æ¸¸æˆç»“æŸï¼</h2>
        <p id="gameOverMessage"></p>
        <button class="btn btn-start" onclick="restartGame()">å†ç©ä¸€æ¬¡</button>
    </div>

    <script>
        class LianLianKan {
            constructor() {
                this.board = [];
                this.rows = 0;
                this.cols = 0;
                this.selectedTiles = [];
                this.score = 0;
                this.moves = 0;
                this.hints = 3;
                this.timeElapsed = 0;
                this.timer = null;
                this.gameStarted = false;
                this.difficulty = 'easy';
                this.imagePaths = [];
                this.availableImages = [];

                this.difficultySettings = {
                    easy: { rows: 4, cols: 6, pairs: 12 },      // 4Ã—6=24æ ¼ï¼Œ12å¯¹
                    medium: { rows: 6, cols: 8, pairs: 24 },    // 6Ã—8=48æ ¼ï¼Œ24å¯¹
                    hard: { rows: 8, cols: 8, pairs: 32 }       // 8Ã—8=64æ ¼ï¼Œ32å¯¹ï¼ˆå‡å°‘å¤æ‚åº¦ï¼‰
                };

                this.initializeEventListeners();
                this.loadImagePaths();
            }

            loadImagePaths() {
                // å®é™…çš„å›¾ç‰‡æ–‡ä»¶åˆ—è¡¨
                this.imagePaths = [
                    'gallery_compress/FigureYa10chromosomeV2_update.webp',
                    'gallery_compress/FigureYa11bubble.webp',
                    'gallery_compress/FigureYa12box.webp',
                    'gallery_compress/FigureYa13GSEA_Java_update.webp',
                    'gallery_compress/FigureYa101PCA.webp',
                    'gallery_compress/FigureYa102multipanelROC.webp',
                    'gallery_compress/FigureYa103coAbundant.webp',
                    'gallery_compress/FigureYa104GEOmining.webp',
                    'gallery_compress/FigureYa105GDSC.webp',
                    'gallery_compress/FigureYa106immunotherapy.webp',
                    'gallery_compress/FigureYa107ChIPheatmap.webp',
                    'gallery_compress/FigureYa108RNAseqChIP.webp',
                    'gallery_compress/FigureYa109SubtypeGSEA_update.webp',
                    'gallery_compress/FigureYa110mutationSignature.webp',
                    'gallery_compress/FigureYa111markerGene.webp',
                    'gallery_compress/FigureYa112venn.webp',
                    'gallery_compress/FigureYa113MutSigCV.webp',
                    'gallery_compress/FigureYa114ternaryCluster.webp',
                    'gallery_compress/FigureYa115cofactor.webp',
                    'gallery_compress/FigureYa116supervisedCluster.webp',
                    'gallery_compress/FigureYa117multilinearDE.webp',
                    'gallery_compress/FigureYa118MulticlassDESeq2.webp',
                    'gallery_compress/FigureYa119Multiclasslimma.webp',
                    'gallery_compress/FigureYa120MulticlassedgeR.webp',
                    'gallery_compress/FigureYa121MethCGIcluster.webp',
                    'gallery_compress/FigureYa122mut2expr.webp',
                    'gallery_compress/FigureYa123mutVSexpr.webp',
                    'gallery_compress/FigureYa124AssociationHeatmap.webp',
                    'gallery_compress/FigureYa125FishertestV2.webp',
                    'gallery_compress/FigureYa126CorrelationHeatmap.webp',
                    'gallery_compress/FigureYa127HeatmapPie.webp',
                    'gallery_compress/FigureYa128Prognostic.webp',
                    'gallery_compress/FigureYa129TCGAbox.webp',
                    'gallery_compress/FigureYa130coxSVM.webp',
                    'gallery_compress/FigureYa131CMap_update.webp',
                    'gallery_compress/FigureYa132alteration.webp',
                    'gallery_compress/FigureYa133m6Apeak_update.webp',
                    'gallery_compress/FigureYa135multiVolcano.webp',
                    'gallery_compress/FigureYa136fgsea.webp',
                    'gallery_compress/FigureYa138NiceCalibration.webp',
                    'gallery_compress/FigureYa139TMB_titv.webp',
                    'gallery_compress/FigureYa140mosaicpie.webp',
                    'gallery_compress/FigureYa141risk.webp',
                    'gallery_compress/FigureYa142circosBar.webp',
                    'gallery_compress/FigureYa143survCor.webp',
                    'gallery_compress/FigureYa144DiagHeatmap.webp',
                    'gallery_compress/FigureYa145target.webp',
                    'gallery_compress/FigureYa146TMEbox.webp',
                    'gallery_compress/FigureYa147Plus_STRING.webp'
                ];
            }

            getRandomImages(count) {
                // éšæœºé€‰æ‹©countå¼ å›¾ç‰‡
                const selectedImages = [];
                const usedIndices = new Set();

                for (let i = 0; i < count; i++) {
                    let randomIndex;
                    do {
                        randomIndex = Math.floor(Math.random() * this.imagePaths.length);
                    } while (usedIndices.has(randomIndex));

                    usedIndices.add(randomIndex);
                    selectedImages.push(this.imagePaths[randomIndex]);
                }

                return selectedImages;
            }

            initializeEventListeners() {
                document.getElementById('startBtn').addEventListener('click', () => this.startGame());
                document.getElementById('restartBtn').addEventListener('click', () => this.restartGame());
                document.getElementById('hintBtn').addEventListener('click', () => this.showHint());

                document.querySelectorAll('.difficulty-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => this.changeDifficulty(e));
                });
            }

            changeDifficulty(e) {
                document.querySelectorAll('.difficulty-btn').forEach(btn => btn.classList.remove('active'));
                e.target.classList.add('active');
                this.difficulty = e.target.dataset.level;

                // å¦‚æœæ¸¸æˆå·²ç»å¼€å§‹ï¼Œé‡æ–°å¼€å§‹æ¸¸æˆä»¥åº”ç”¨æ–°éš¾åº¦
                if (this.gameStarted) {
                    this.restartGame();
                }
            }

            startGame() {
                const settings = this.difficultySettings[this.difficulty];
                this.rows = settings.rows;
                this.cols = settings.cols;
                this.pairs = settings.pairs;

                this.initializeGame();
            }

            initializeGame() {
                this.board = this.createBoard();
                this.renderBoard();
                this.gameStarted = true;
                this.score = 0;
                this.moves = 0;
                this.hints = 3;
                this.timeElapsed = 0;

                this.updateDisplay();
                this.startTimer();

                document.getElementById('hintBtn').textContent = `æç¤º (${this.hints})`;
            }

            createBoard() {
                const totalTiles = this.rows * this.cols;
                const pairsNeeded = Math.min(this.pairs, Math.floor(totalTiles / 2));

                // åˆ›å»ºæˆå¯¹çš„å›¾ç‰‡
                const images = [];
                const selectedImages = this.getRandomImages(pairsNeeded);

                for (let i = 0; i < pairsNeeded; i++) {
                    images.push(selectedImages[i], selectedImages[i]); // æ¯å¼ å›¾ç‰‡æ·»åŠ ä¸¤æ¬¡ï¼Œå½¢æˆä¸€å¯¹
                }

                // å¦‚æœè¿˜æœ‰ç©ºä½™ä½ç½®ï¼Œæ·»åŠ æ›´å¤šçš„å¯¹
                while (images.length < totalTiles && images.length < this.imagePaths.length * 2) {
                    const randomImage = this.imagePaths[Math.floor(Math.random() * this.imagePaths.length)];
                    images.push(randomImage, randomImage);
                }

                // ç¡®ä¿æ•°ç»„é•¿åº¦æ­£å¥½ç­‰äºtotalTiles
                while (images.length > totalTiles) {
                    images.pop();
                }

                // æ‰“ä¹±æ•°ç»„
                for (let i = images.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [images[i], images[j]] = [images[j], images[i]];
                }

                // åˆ›å»ºäºŒç»´æ•°ç»„
                const board = [];
                let imageIndex = 0;

                for (let i = 0; i < this.rows; i++) {
                    board[i] = [];
                    for (let j = 0; j < this.cols; j++) {
                        board[i][j] = imageIndex < images.length ? images[imageIndex++] : null;
                    }
                }

                return board;
            }

            renderBoard() {
                const boardElement = document.getElementById('gameBoard');
                boardElement.innerHTML = '';
                boardElement.style.gridTemplateColumns = `repeat(${this.cols}, 1fr)`;

                for (let i = 0; i < this.rows; i++) {
                    for (let j = 0; j < this.cols; j++) {
                        const tile = document.createElement('div');
                        tile.className = 'tile';
                        tile.dataset.row = i;
                        tile.dataset.col = j;

                        if (this.board[i][j]) {
                            const img = document.createElement('img');
                            img.src = this.board[i][j];
                            img.alt = 'Game Tile';

                            // å¦‚æœå›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨emojiä½œä¸ºæ›¿ä»£
                            img.onerror = () => {
                                img.style.display = 'none';
                                const emoji = document.createElement('div');
                                emoji.style.fontSize = '30px';
                                emoji.style.display = 'flex';
                                emoji.style.alignItems = 'center';
                                emoji.style.justifyContent = 'center';
                                emoji.style.width = '100%';
                                emoji.style.height = '100%';
                                const emojis = ['ğŸ', 'ğŸŠ', 'ğŸ‹', 'ğŸŒ', 'ğŸ‰', 'ğŸ‡', 'ğŸ“', 'ğŸ’', 'ğŸŒŸ', 'ğŸˆ', 'ğŸ¨', 'ğŸ¯'];
                                emoji.textContent = emojis[Math.floor(Math.random() * emojis.length)];
                                tile.appendChild(emoji);
                            };

                            img.onload = () => {
                                // å›¾ç‰‡åŠ è½½æˆåŠŸï¼Œç¡®ä¿æ ·å¼æ­£ç¡®
                                img.style.width = '100%';
                                img.style.height = '100%';
                                img.style.objectFit = 'cover';
                                img.style.borderRadius = '6px';
                            };

                            tile.appendChild(img);
                        } else {
                            tile.classList.add('empty');
                        }

                        tile.addEventListener('click', () => this.handleTileClick(i, j));
                        boardElement.appendChild(tile);
                    }
                }
            }

            handleTileClick(row, col) {
                if (!this.gameStarted || !this.board[row][col]) return;

                const tile = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);

                if (this.selectedTiles.length === 0) {
                    this.selectedTiles.push({ row, col, element: tile });
                    tile.classList.add('selected');
                } else if (this.selectedTiles.length === 1) {
                    const first = this.selectedTiles[0];

                    if (first.row === row && first.col === col) {
                        tile.classList.remove('selected');
                        this.selectedTiles = [];
                        return;
                    }

                    this.selectedTiles.push({ row, col, element: tile });
                    tile.classList.add('selected');

                    this.moves++;
                    this.updateDisplay();

                    if (this.canConnect(first.row, first.col, row, col)) {
                        this.handleMatch();
                    } else {
                        setTimeout(() => {
                            this.clearSelection();
                        }, 500);
                    }
                }
            }

            canConnect(row1, col1, row2, col2) {
                // æ£€æŸ¥æ˜¯å¦æ˜¯ç›¸åŒçš„å›¾ç‰‡
                if (this.board[row1][col1] !== this.board[row2][col2]) {
                    return false;
                }

                // å®ç°çœŸæ­£çš„è¿è¿çœ‹è§„åˆ™ï¼šæœ€å¤šç”¨3æ¡ç›´çº¿ï¼ˆ2ä¸ªè½¬æŠ˜ç‚¹ï¼‰è¿æ¥
                const result = this.findPath(row1, col1, row2, col2);

                // å¦‚æœæ˜¯è¾¹ç•Œä½ç½®çš„å›¾ç‰‡ï¼Œè®°å½•è¿æ¥ç»“æœç”¨äºè°ƒè¯•
                const isEdge1 = row1 === 0 || row1 === this.rows-1 || col1 === 0 || col1 === this.cols-1;
                const isEdge2 = row2 === 0 || row2 === this.rows-1 || col2 === 0 || col2 === this.cols-1;
                if (isEdge1 || isEdge2) {
                    console.log(`è¾¹ç•Œè¿æ¥æµ‹è¯•: (${row1},${col1}) -> (${row2},${col2}) = ${result}`);
                }

                return result;
            }

            findPath(row1, col1, row2, col2) {
                // 0ä¸ªè½¬æŠ˜ç‚¹ï¼šç›´æ¥è¿æ¥
                if (this.canDirectConnect(row1, col1, row2, col2)) {
                    return true;
                }

                // 1ä¸ªè½¬æŠ˜ç‚¹ï¼šä¸€ä¸ªè½¬å¼¯
                if (this.canConnectWithOneCorner(row1, col1, row2, col2)) {
                    return true;
                }

                // 2ä¸ªè½¬æŠ˜ç‚¹ï¼šä¸¤ä¸ªè½¬å¼¯
                if (this.canConnectWithTwoCorners(row1, col1, row2, col2)) {
                    return true;
                }

                return false;
            }

            // æ£€æŸ¥æ˜¯å¦å¯ä»¥ç›´æ¥è¿æ¥ï¼ˆ0ä¸ªè½¬æŠ˜ç‚¹ï¼‰
            canDirectConnect(row1, col1, row2, col2) {
                // åŒä¸€è¡Œï¼šæ°´å¹³è¿æ¥
                if (row1 === row2) {
                    const start = Math.min(col1, col2);
                    const end = Math.max(col1, col2);

                    // æ£€æŸ¥è·¯å¾„ä¸Šçš„æ¯ä¸ªç‚¹
                    for (let col = start + 1; col < end; col++) {
                        // åªæ£€æŸ¥åœ¨è¾¹ç•Œå†…çš„ç‚¹ï¼Œè¾¹ç•Œå¤–çš„ç‚¹è§†ä¸ºå¯é€šè¿‡
                        if (col >= 0 && col < this.cols && this.board[row1][col] !== null) {
                            return false; // è·¯å¾„ä¸Šæœ‰é˜»æŒ¡
                        }
                    }
                    return true;
                }

                // åŒä¸€åˆ—ï¼šå‚ç›´è¿æ¥
                if (col1 === col2) {
                    const start = Math.min(row1, row2);
                    const end = Math.max(row1, row2);

                    // æ£€æŸ¥è·¯å¾„ä¸Šçš„æ¯ä¸ªç‚¹
                    for (let row = start + 1; row < end; row++) {
                        // åªæ£€æŸ¥åœ¨è¾¹ç•Œå†…çš„ç‚¹ï¼Œè¾¹ç•Œå¤–çš„ç‚¹è§†ä¸ºå¯é€šè¿‡
                        if (row >= 0 && row < this.rows && this.board[row][col1] !== null) {
                            return false; // è·¯å¾„ä¸Šæœ‰é˜»æŒ¡
                        }
                    }
                    return true;
                }

                return false;
            }

            // æ£€æŸ¥æ˜¯å¦å¯ä»¥ç”¨ä¸€ä¸ªè½¬æŠ˜ç‚¹è¿æ¥
            canConnectWithOneCorner(row1, col1, row2, col2) {
                // å°è¯•ä¸¤ä¸ªè½¬æŠ˜ç‚¹ä½ç½®
                // è½¬æŠ˜ç‚¹1: (row1, col2)
                if (this.isValidCorner(row1, col2) &&
                    this.canDirectConnect(row1, col1, row1, col2) &&
                    this.canDirectConnect(row1, col2, row2, col2)) {
                    return true;
                }

                // è½¬æŠ˜ç‚¹2: (row2, col1)
                if (this.isValidCorner(row2, col1) &&
                    this.canDirectConnect(row1, col1, row2, col1) &&
                    this.canDirectConnect(row2, col1, row2, col2)) {
                    return true;
                }

                return false;
            }

            // æ£€æŸ¥æ˜¯å¦å¯ä»¥ç”¨ä¸¤ä¸ªè½¬æŠ˜ç‚¹è¿æ¥
            canConnectWithTwoCorners(row1, col1, row2, col2) {
                // æ–¹æ³•1ï¼šç®€åŒ–çš„è¾¹ç•ŒUå½¢æ£€æµ‹ - ç›´æ¥æ£€æŸ¥å››ä¸ªæ–¹å‘

                // Uå½¢1: ä¸¤ä¸ªç‚¹éƒ½å¯ä»¥å‘ä¸Šåˆ°è¾¾è¾¹ç•Œ (-1è¡Œ)
                if (this.canReachRowBoundary(row1, col1, -1) && this.canReachRowBoundary(row2, col2, -1)) {
                    return true; // åœ¨ä¸Šè¾¹ç•Œå¤–å¯ä»¥è¿æ¥
                }

                // Uå½¢2: ä¸¤ä¸ªç‚¹éƒ½å¯ä»¥å‘ä¸‹åˆ°è¾¾è¾¹ç•Œ (rowsè¡Œ)
                if (this.canReachRowBoundary(row1, col1, this.rows) && this.canReachRowBoundary(row2, col2, this.rows)) {
                    return true; // åœ¨ä¸‹è¾¹ç•Œå¤–å¯ä»¥è¿æ¥
                }

                // Uå½¢3: ä¸¤ä¸ªç‚¹éƒ½å¯ä»¥å‘å·¦åˆ°è¾¾è¾¹ç•Œ (-1åˆ—)
                if (this.canReachColBoundary(row1, col1, -1) && this.canReachColBoundary(row2, col2, -1)) {
                    return true; // åœ¨å·¦è¾¹ç•Œå¤–å¯ä»¥è¿æ¥
                }

                // Uå½¢4: ä¸¤ä¸ªç‚¹éƒ½å¯ä»¥å‘å³åˆ°è¾¾è¾¹ç•Œ (colsåˆ—)
                if (this.canReachColBoundary(row1, col1, this.cols) && this.canReachColBoundary(row2, col2, this.cols)) {
                    return true; // åœ¨å³è¾¹ç•Œå¤–å¯ä»¥è¿æ¥
                }

                // æ–¹æ³•2ï¼šæ ‡å‡†çš„ä¸€ä¸ªè½¬æŠ˜ç‚¹æ‰©å±•ç®—æ³•
                // ä»èµ·ç‚¹å¼€å§‹çš„æ‰€æœ‰å¯èƒ½çš„ç¬¬ä¸€ä¸ªè½¬æŠ˜ç‚¹
                for (let corner1Row = -1; corner1Row <= this.rows; corner1Row++) {
                    for (let corner1Col = -1; corner1Col <= this.cols; corner1Col++) {
                        // è·³è¿‡èµ·ç‚¹æœ¬èº«å’Œå·²ç»åœ¨åŒä¸€ç›´çº¿ä¸Šçš„ç‚¹
                        if ((corner1Row === row1 && corner1Col === col1) ||
                            (corner1Row === row2 && corner1Col === col2)) continue;

                        // æ£€æŸ¥èµ·ç‚¹åˆ°ç¬¬ä¸€ä¸ªè½¬æŠ˜ç‚¹æ˜¯å¦å¯è¾¾
                        if (!this.canDirectConnect(row1, col1, corner1Row, corner1Col)) continue;

                        // ä»ç¬¬ä¸€ä¸ªè½¬æŠ˜ç‚¹å¼€å§‹çš„æ‰€æœ‰å¯èƒ½çš„ç¬¬äºŒä¸ªè½¬æŠ˜ç‚¹
                        for (let corner2Row = -1; corner2Row <= this.rows; corner2Row++) {
                            for (let corner2Col = -1; corner2Col <= this.cols; corner2Col++) {
                                // è·³è¿‡é‡å¤ç‚¹
                                if ((corner2Row === corner1Row && corner2Col === corner1Col) ||
                                    (corner2Row === row1 && corner2Col === col1)) continue;

                                // æ£€æŸ¥ä¸‰ä¸ªæ¡ä»¶ï¼š
                                // 1. ç¬¬ä¸€ä¸ªè½¬æŠ˜ç‚¹åˆ°ç¬¬äºŒä¸ªè½¬æŠ˜ç‚¹å¯è¾¾
                                // 2. ç¬¬äºŒä¸ªè½¬æŠ˜ç‚¹åˆ°ç»ˆç‚¹å¯è¾¾
                                // 3. ç¬¬äºŒä¸ªè½¬æŠ˜ç‚¹æ˜¯æœ‰æ•ˆçš„ï¼ˆè¾¹ç•Œå¤–æˆ–ç©ºä½ï¼‰
                                if (this.canDirectConnect(corner1Row, corner1Col, corner2Row, corner2Col) &&
                                    this.canDirectConnect(corner2Row, corner2Col, row2, col2) &&
                                    this.isValidCorner(corner2Row, corner2Col)) {
                                    return true;
                                }
                            }
                        }
                    }
                }

                // æ–¹æ³•3ï¼šç®€åŒ–çš„ä¸¤æ­¥æœç´¢ï¼ˆä¼˜åŒ–æ€§èƒ½ï¼‰
                // åªæœç´¢æœ‰æ•ˆçš„ä¸­é—´è½¬æŠ˜ç‚¹ç»„åˆ

                // å…ˆæ‰¾æ‰€æœ‰å¯èƒ½çš„ç¬¬ä¸€ä¸ªè½¬æŠ˜ç‚¹
                const firstCorners = [];
                for (let row = -1; row <= this.rows; row++) {
                    for (let col = -1; col <= this.cols; col++) {
                        if ((row === row1 && col === col1) || (row === row2 && col === col2)) continue;
                        if (this.canDirectConnect(row1, col1, row, col)) {
                            firstCorners.push({row, col});
                        }
                    }
                }

                // ä»æ¯ä¸ªç¬¬ä¸€ä¸ªè½¬æŠ˜ç‚¹æ‰¾ç¬¬äºŒä¸ªè½¬æŠ˜ç‚¹
                for (let corner1 of firstCorners) {
                    for (let row = -1; row <= this.rows; row++) {
                        for (let col = -1; col <= this.cols; col++) {
                            if ((row === corner1.row && col === corner1.col) ||
                                (row === row1 && col === col1)) continue;
                            if (this.canDirectConnect(corner1.row, corner1.col, row, col) &&
                                this.canDirectConnect(row, col, row2, col2) &&
                                this.isValidCorner(row, col)) {
                                return true;
                            }
                        }
                    }
                }

                return false;
            }

            // æ£€æŸ¥æŸä¸ªç‚¹æ˜¯å¦å¯ä»¥ä½œä¸ºè½¬æŠ˜ç‚¹
            isValidCorner(row, col) {
                // åœ¨è¾¹ç•Œå¤–çš„ç‚¹ä¹Ÿå¯ä»¥ä½œä¸ºè½¬æŠ˜ç‚¹
                if (row < 0 || row >= this.rows || col < 0 || col >= this.cols) {
                    return true;
                }
                // åœ¨è¾¹ç•Œå†…çš„ç‚¹å¿…é¡»æ˜¯ç©ºçš„
                return this.board[row][col] === null;
            }

            // æ£€æŸ¥æ˜¯å¦å¯ä»¥é€šè¿‡æŸä¸ªç‚¹è¿æ¥
            canConnectViaPoint(row, col, row1, col1, row2, col2) {
                // æ£€æŸ¥ä»è¿™ä¸ªç‚¹åˆ°ç›®æ ‡ç‚¹çš„è¿æ¥
                return this.isValidCorner(row, col) &&
                       this.canDirectConnect(row1, col1, row, col) &&
                       this.canDirectConnect(row, col, row2, col2);
            }

            // æ£€æŸ¥æ˜¯å¦å¯ä»¥åˆ°è¾¾æŒ‡å®šçš„è¡Œè¾¹ç•Œ
            canReachRowBoundary(row, col, targetRow) {
                if (targetRow === -1) {
                    // å‘ä¸Šåˆ°è¾¾-1è¡Œï¼ˆä¸Šè¾¹ç•Œå¤–ï¼‰
                    for (let r = row - 1; r >= -1; r--) {
                        if (r >= 0 && r < this.rows && this.board[r] && this.board[r][col] !== null) {
                            return false; // è·¯å¾„è¢«é˜»æŒ¡
                        }
                    }
                    return true;
                } else if (targetRow === this.rows) {
                    // å‘ä¸‹åˆ°è¾¾rowsè¡Œï¼ˆä¸‹è¾¹ç•Œå¤–ï¼‰
                    for (let r = row + 1; r <= this.rows; r++) {
                        if (r >= 0 && r < this.rows && this.board[r] && this.board[r][col] !== null) {
                            return false; // è·¯å¾„è¢«é˜»æŒ¡
                        }
                    }
                    return true;
                }
                return false;
            }

            // æ£€æŸ¥æ˜¯å¦å¯ä»¥åˆ°è¾¾æŒ‡å®šçš„åˆ—è¾¹ç•Œ
            canReachColBoundary(row, col, targetCol) {
                if (targetCol === -1) {
                    // å‘å·¦åˆ°è¾¾-1åˆ—ï¼ˆå·¦è¾¹ç•Œå¤–ï¼‰
                    for (let c = col - 1; c >= -1; c--) {
                        if (c >= 0 && c < this.cols && this.board[row] && this.board[row][c] !== null) {
                            return false; // è·¯å¾„è¢«é˜»æŒ¡
                        }
                    }
                    return true;
                } else if (targetCol === this.cols) {
                    // å‘å³åˆ°è¾¾colsåˆ—ï¼ˆå³è¾¹ç•Œå¤–ï¼‰
                    for (let c = col + 1; c <= this.cols; c++) {
                        if (c >= 0 && c < this.cols && this.board[row] && this.board[row][c] !== null) {
                            return false; // è·¯å¾„è¢«é˜»æŒ¡
                        }
                    }
                    return true;
                }
                return false;
            }

    
            handleMatch() {
                const [first, second] = this.selectedTiles;

                // æ·»åŠ åŒ¹é…åŠ¨ç”»
                first.element.classList.add('matched');
                second.element.classList.add('matched');

                // æ¸…é™¤æ£‹ç›˜ä¸Šçš„å›¾ç‰‡
                setTimeout(() => {
                    this.board[first.row][first.col] = null;
                    this.board[second.row][second.col] = null;
                    first.element.classList.add('empty');
                    second.element.classList.add('empty');
                    first.element.classList.remove('selected', 'matched');
                    second.element.classList.remove('selected', 'matched');
                }, 500);

                // å¢åŠ åˆ†æ•°
                this.score += 100;
                this.updateDisplay();

                // æ¸…é™¤é€‰æ‹©
                this.selectedTiles = [];

                // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
                setTimeout(() => {
                    if (this.checkGameEnd()) {
                        this.endGame(true);
                    }
                }, 600);
            }

            clearSelection() {
                this.selectedTiles.forEach(tile => {
                    tile.element.classList.remove('selected');
                });
                this.selectedTiles = [];
            }

            showHint() {
                if (this.hints <= 0 || !this.gameStarted) return;

                // å¯»æ‰¾å¯ä»¥åŒ¹é…çš„ä¸€å¯¹
                for (let r1 = 0; r1 < this.rows; r1++) {
                    for (let c1 = 0; c1 < this.cols; c1++) {
                        if (!this.board[r1][c1]) continue;

                        for (let r2 = 0; r2 < this.rows; r2++) {
                            for (let c2 = 0; c2 < this.cols; c2++) {
                                if (r1 === r2 && c1 === c2) continue;
                                if (!this.board[r2][c2]) continue;

                                if (this.canConnect(r1, c1, r2, c2)) {
                                    // é«˜äº®æç¤º
                                    const tile1 = document.querySelector(`[data-row="${r1}"][data-col="${c1}"]`);
                                    const tile2 = document.querySelector(`[data-row="${r2}"][data-col="${c2}"]`);

                                    tile1.style.background = '#f39c12';
                                    tile2.style.background = '#f39c12';

                                    setTimeout(() => {
                                        tile1.style.background = '';
                                        tile2.style.background = '';
                                    }, 1000);

                                    this.hints--;
                                    this.score = Math.max(0, this.score - 50);
                                    this.updateDisplay();
                                    document.getElementById('hintBtn').textContent = `æç¤º (${this.hints})`;
                                    return;
                                }
                            }
                        }
                    }
                }
            }

            checkGameEnd() {
                for (let i = 0; i < this.rows; i++) {
                    for (let j = 0; j < this.cols; j++) {
                        if (this.board[i][j]) return false;
                    }
                }
                return true;
            }

            startTimer() {
                this.timer = setInterval(() => {
                    this.timeElapsed++;
                    this.updateTimer();
                }, 1000);
            }

            stopTimer() {
                if (this.timer) {
                    clearInterval(this.timer);
                    this.timer = null;
                }
            }

            updateTimer() {
                const minutes = Math.floor(this.timeElapsed / 60);
                const seconds = this.timeElapsed % 60;
                document.getElementById('time').textContent =
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }

            updateDisplay() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('moves').textContent = this.moves;
                this.updateTimer();
            }

            restartGame() {
                this.stopTimer();
                this.gameStarted = false;
                this.selectedTiles = [];
                document.getElementById('gameBoard').innerHTML = '';
                this.startGame();
            }

            endGame(won) {
                this.stopTimer();
                this.gameStarted = false;

                const overlay = document.getElementById('overlay');
                const gameOver = document.getElementById('gameOver');
                const title = document.getElementById('gameOverTitle');
                const message = document.getElementById('gameOverMessage');

                if (won) {
                    title.textContent = 'ğŸ‰ æ­å–œé€šå…³ï¼';
                    message.innerHTML = `
                        å®Œæˆæ—¶é—´ï¼š${document.getElementById('time').textContent}<br>
                        æœ€ç»ˆå¾—åˆ†ï¼š${this.score}<br>
                        ä½¿ç”¨æ­¥æ•°ï¼š${this.moves}<br>
                        éš¾åº¦çº§åˆ«ï¼š${this.getDifficultyText()}
                    `;
                } else {
                    title.textContent = 'æ¸¸æˆç»“æŸ';
                    message.textContent = `æœ€ç»ˆå¾—åˆ†ï¼š${this.score}`;
                }

                overlay.style.display = 'block';
                gameOver.style.display = 'block';
            }

            getDifficultyText() {
                const texts = {
                    easy: 'ç®€å•',
                    medium: 'ä¸­ç­‰',
                    hard: 'å›°éš¾'
                };
                return texts[this.difficulty];
            }
        }

        // åˆå§‹åŒ–æ¸¸æˆ
        const game = new LianLianKan();

        // å…¨å±€å‡½æ•°
        function restartGame() {
            document.getElementById('overlay').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            game.restartGame();
        }
    </script>
</body>
</html>