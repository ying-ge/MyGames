<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¿è¿çœ‹æ¶ˆé™¤æ¸¸æˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        header {
            text-align: center;
            color: white;
            margin-bottom: 20px;
        }

        h1 {
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            margin-bottom: 10px;
        }

        .game-controls {
            background: white;
            padding: 15px 30px;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            margin-bottom: 20px;
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .difficulty-selector {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .difficulty-selector label {
            font-weight: bold;
            color: #333;
        }

        .difficulty-btn {
            padding: 8px 16px;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        .difficulty-btn:hover {
            background: #667eea;
            color: white;
            transform: translateY(-2px);
        }

        .difficulty-btn.active {
            background: #667eea;
            color: white;
        }

        .game-info {
            display: flex;
            gap: 20px;
            align-items: center;
            font-weight: bold;
            color: #333;
        }

        .timer {
            font-size: 1.2em;
            color: #e74c3c;
        }

        .score {
            font-size: 1.2em;
            color: #27ae60;
        }

        .moves {
            font-size: 1.2em;
            color: #3498db;
        }

        .game-container {
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
            margin-bottom: 20px;
        }

        .game-board {
            display: grid;
            gap: 6px;
            max-width: 800px;
            margin: 0 auto;
        }

        .tile {
            width: 80px;
            height: 80px;
            border: 2px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #f8f9fa;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
        }

        @media (max-width: 768px) {
            .tile {
                width: 60px;
                height: 60px;
            }
        }

        .tile:hover:not(.empty) {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            border-color: #667eea;
        }

        .tile.selected {
            border-color: #e74c3c;
            border-width: 3px;
            transform: translateY(-8px);
            box-shadow: 0 8px 20px rgba(231, 76, 60, 0.4);
        }

        .tile.matched {
            animation: matchAnimation 0.5s ease;
            opacity: 0;
            pointer-events: none;
        }

        .tile.empty {
            opacity: 0;
            pointer-events: none;
        }

        @keyframes matchAnimation {
            0% {
                transform: scale(1) rotate(0deg);
            }
            50% {
                transform: scale(1.2) rotate(180deg);
            }
            100% {
                transform: scale(0) rotate(360deg);
                opacity: 0;
            }
        }

        .tile img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 6px;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            color: white;
            font-size: 16px;
        }

        .btn-start {
            background: #27ae60;
        }

        .btn-start:hover {
            background: #2ecc71;
            transform: translateY(-2px);
        }

        .btn-hint {
            background: #f39c12;
        }

        .btn-hint:hover {
            background: #e67e22;
            transform: translateY(-2px);
        }

        .btn-restart {
            background: #e74c3c;
        }

        .btn-restart:hover {
            background: #c0392b;
            transform: translateY(-2px);
        }

        .game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            text-align: center;
            z-index: 1000;
            display: none;
        }

        .game-over h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 2em;
        }

        .game-over p {
            color: #666;
            margin-bottom: 20px;
            font-size: 1.2em;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 999;
            display: none;
        }

        .connection-line {
            position: absolute;
            background: #e74c3c;
            z-index: 100;
            pointer-events: none;
            border-radius: 2px;
        }

        @media (max-width: 768px) {
            .tile {
                width: 60px;
                height: 60px;
            }

            .game-controls {
                flex-direction: column;
                align-items: stretch;
            }

            .difficulty-selector {
                justify-content: center;
            }

            .game-info {
                justify-content: space-around;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>ğŸ® è¿è¿çœ‹æ¶ˆé™¤æ¸¸æˆ</h1>
        <p>æ‰¾å‡ºç›¸åŒçš„å›¾ç‰‡ï¼Œç”¨æœ€å¤š3æ¡ç›´çº¿è¿æ¥å®ƒä»¬ï¼</p>
    </header>

    <section class="game-controls">
        <div class="difficulty-selector">
            <label>éš¾åº¦çº§åˆ«ï¼š</label>
            <button class="difficulty-btn active" data-level="easy">ç®€å•</button>
            <button class="difficulty-btn" data-level="medium">ä¸­ç­‰</button>
            <button class="difficulty-btn" data-level="hard">å›°éš¾</button>
                    </div>

        <div class="game-info">
            <div class="timer">æ—¶é—´: <span id="time">00:00</span></div>
            <div class="score">å¾—åˆ†: <span id="score">0</span></div>
            <div class="moves">æ­¥æ•°: <span id="moves">0</span></div>
        </div>
    </section>

    <section class="game-container">
        <div class="game-board" id="gameBoard"></div>
    </section>

    <section class="action-buttons">
        <button class="btn btn-start" id="startBtn">å¼€å§‹æ¸¸æˆ</button>
        <button class="btn btn-hint" id="hintBtn">æç¤º (3)</button>
        <button class="btn btn-restart" id="restartBtn">é‡æ–°å¼€å§‹</button>
    </section>

    <div class="overlay" id="overlay"></div>
    <div class="game-over" id="gameOver">
        <h2 id="gameOverTitle">æ¸¸æˆç»“æŸï¼</h2>
        <p id="gameOverMessage"></p>
        <button class="btn btn-start" onclick="restartGame()">å†ç©ä¸€æ¬¡</button>
    </div>

    <script>
        class LianLianKan {
            constructor() {
                this.board = [];
                this.rows = 0;
                this.cols = 0;
                this.selectedTiles = [];
                this.score = 0;
                this.moves = 0;
                this.hints = 3;
                this.timeElapsed = 0;
                this.timer = null;
                this.gameStarted = false;
                this.difficulty = 'easy';
                this.imagePaths = [];
                this.availableImages = [];

                this.difficultySettings = {
                    easy: { rows: 4, cols: 6, pairs: 12 },      // 4Ã—6=24æ ¼ï¼Œ12å¯¹
                    medium: { rows: 6, cols: 8, pairs: 24 },    // 6Ã—8=48æ ¼ï¼Œ24å¯¹
                    hard: { rows: 8, cols: 8, pairs: 32 }       // 8Ã—8=64æ ¼ï¼Œ32å¯¹ï¼ˆå‡å°‘å¤æ‚åº¦ï¼‰
                };

                this.initializeEventListeners();
                this.loadImagePaths();
            }

            loadImagePaths() {
                // å®é™…çš„å›¾ç‰‡æ–‡ä»¶åˆ—è¡¨ï¼ˆå·²æ¸…ç†ä¸å­˜åœ¨çš„æ–‡ä»¶ï¼‰
                this.imagePaths = [
                    'gallery_compress/FigureYa10chromosomeV2_update.webp',
                    'gallery_compress/FigureYa11bubble.webp',
                    'gallery_compress/FigureYa12box.webp',
                    'gallery_compress/FigureYa13GSEA_Java_update.webp',
                    'gallery_compress/FigureYa101PCA.webp',
                    'gallery_compress/FigureYa102multipanelROC.webp',
                    'gallery_compress/FigureYa103coAbundant.webp',
                    'gallery_compress/FigureYa105GDSC.webp',
                    'gallery_compress/FigureYa106immunotherapy.webp',
                    'gallery_compress/FigureYa107ChIPheatmap.webp',
                    'gallery_compress/FigureYa108RNAseqChIP.webp',
                    'gallery_compress/FigureYa109SubtypeGSEA_update.webp',
                    'gallery_compress/FigureYa110mutationSignature.webp',
                    'gallery_compress/FigureYa111markerGene.webp',
                    'gallery_compress/FigureYa112venn.webp',
                    'gallery_compress/FigureYa113MutSigCV.webp',
                    'gallery_compress/FigureYa114ternaryCluster.webp',
                    'gallery_compress/FigureYa115cofactor.webp',
                    'gallery_compress/FigureYa116supervisedCluster.webp',
                    'gallery_compress/FigureYa117multilinearDE.webp',
                    'gallery_compress/FigureYa118MulticlassDESeq2.webp',
                    'gallery_compress/FigureYa119Multiclasslimma.webp',
                    'gallery_compress/FigureYa120MulticlassedgeR.webp',
                    'gallery_compress/FigureYa121MethCGIcluster.webp',
                    'gallery_compress/FigureYa122mut2expr.webp',
                    'gallery_compress/FigureYa123mutVSexpr.webp',
                    'gallery_compress/FigureYa124AssociationHeatmap.webp',
                    'gallery_compress/FigureYa125FishertestV2.webp',
                    'gallery_compress/FigureYa126CorrelationHeatmap.webp',
                    'gallery_compress/FigureYa127HeatmapPie.webp',
                    'gallery_compress/FigureYa128Prognostic.webp',
                    'gallery_compress/FigureYa129TCGAbox.webp',
                    'gallery_compress/FigureYa130coxSVM.webp',
                    'gallery_compress/FigureYa131CMap_update.webp',
                    'gallery_compress/FigureYa132alteration.webp',
                    'gallery_compress/FigureYa135multiVolcano.webp',
                    'gallery_compress/FigureYa136fgsea.webp',
                    'gallery_compress/FigureYa138NiceCalibration.webp',
                    'gallery_compress/FigureYa139TMB_titv.webp',
                    'gallery_compress/FigureYa140mosaicpie.webp',
                    'gallery_compress/FigureYa141risk.webp',
                    'gallery_compress/FigureYa142circosBar.webp',
                    'gallery_compress/FigureYa143survCor.webp',
                    'gallery_compress/FigureYa144DiagHeatmap.webp',
                    'gallery_compress/FigureYa145target.webp',
                    'gallery_compress/FigureYa146TMEbox.webp',
                    'gallery_compress/FigureYa147Plus_STRING.webp'
                ];
            }

            getRandomImages(count) {
                // éšæœºé€‰æ‹©countå¼ å›¾ç‰‡
                const selectedImages = [];
                const usedIndices = new Set();

                for (let i = 0; i < count; i++) {
                    let randomIndex;
                    do {
                        randomIndex = Math.floor(Math.random() * this.imagePaths.length);
                    } while (usedIndices.has(randomIndex));

                    usedIndices.add(randomIndex);
                    selectedImages.push(this.imagePaths[randomIndex]);
                }

                return selectedImages;
            }

            initializeEventListeners() {
                document.getElementById('startBtn').addEventListener('click', () => this.startGame());
                document.getElementById('restartBtn').addEventListener('click', () => this.restartGame());
                document.getElementById('hintBtn').addEventListener('click', () => this.showHint());

                document.querySelectorAll('.difficulty-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => this.changeDifficulty(e));
                });
            }

            changeDifficulty(e) {
                document.querySelectorAll('.difficulty-btn').forEach(btn => btn.classList.remove('active'));
                e.target.classList.add('active');
                this.difficulty = e.target.dataset.level;

                // å¦‚æœæ¸¸æˆå·²ç»å¼€å§‹ï¼Œé‡æ–°å¼€å§‹æ¸¸æˆä»¥åº”ç”¨æ–°éš¾åº¦
                if (this.gameStarted) {
                    this.restartGame();
                }
            }

            startGame() {
                const settings = this.difficultySettings[this.difficulty];
                this.rows = settings.rows;
                this.cols = settings.cols;
                this.pairs = settings.pairs;

                this.initializeGame();
            }

            initializeGame() {
                // ç”Ÿæˆæ£‹ç›˜ï¼Œç¡®ä¿æœ‰è¶³å¤Ÿçš„å¯è¿æ¥é…å¯¹ä¸”å¯è§£
                let attempts = 0;
                let maxAttempts = 150;
                let bestBoard = null;
                let bestScore = 0;
                
                // å°è¯•ç”Ÿæˆå¯è§£çš„æ£‹ç›˜
                while (attempts < maxAttempts) {
                    const testBoard = this.createBoard();
                    const tempBoard = this.board;
                    this.board = testBoard;
                    
                    const hasEnough = this.hasEnoughConnectablePairs();
                    const isSolvable = this.isSolvable();
                    
                    // å¦‚æœæ£‹ç›˜å¯è§£ï¼Œç›´æ¥ä½¿ç”¨
                    if (hasEnough && isSolvable) {
                        this.board = testBoard;
                        break;
                    }
                    
                    // è®°å½•æœ€å¥½çš„æ£‹ç›˜ï¼ˆå³ä½¿ä¸å®Œå…¨å¯è§£ï¼Œä¹Ÿè®°å½•å¯è¿æ¥é…å¯¹æœ€å¤šçš„ï¼‰
                    if (hasEnough) {
                        const pairs = new Map();
                        for (let i = 0; i < testBoard.length; i++) {
                            for (let j = 0; j < testBoard[i].length; j++) {
                                if (testBoard[i][j]) {
                                    const image = testBoard[i][j];
                                    if (!pairs.has(image)) {
                                        pairs.set(image, []);
                                    }
                                    pairs.get(image).push({row: i, col: j});
                                }
                            }
                        }
                        let connectableCount = 0;
                        // ä½¿ç”¨ testBoard æ£€æŸ¥è¿æ¥æ€§
                        for (const [image, positions] of pairs.entries()) {
                            for (let i = 0; i < positions.length; i++) {
                                for (let j = i + 1; j < positions.length; j++) {
                                    if (this.canConnectWithBoard(testBoard, positions[i].row, positions[i].col, positions[j].row, positions[j].col)) {
                                        connectableCount++;
                                    }
                                }
                            }
                        }
                        
                        if (connectableCount > bestScore) {
                            bestScore = connectableCount;
                            bestBoard = testBoard.map(row => row.map(cell => cell));
                        }
                    }
                    
                    this.board = tempBoard;
                    attempts++;
                }
                
                // å¦‚æœè¾¾åˆ°æœ€å¤§å°è¯•æ¬¡æ•°ä»æœªæ‰¾åˆ°å®Œå…¨å¯è§£çš„æ£‹ç›˜ï¼Œä½¿ç”¨æœ€å¥½çš„æ£‹ç›˜
                if (attempts >= maxAttempts && bestBoard) {
                    this.board = bestBoard;
                    console.warn('ä½¿ç”¨æœ€ä½³å¯ç”¨æ£‹ç›˜ï¼ˆå¯è¿æ¥é…å¯¹æ•°ï¼š' + bestScore + 'ï¼‰');
                } else if (attempts >= maxAttempts) {
                    // å¦‚æœè¿å¥½çš„æ£‹ç›˜éƒ½æ²¡æœ‰ï¼Œé‡æ–°ç”Ÿæˆä¸€ä¸ª
                    this.board = this.createBoard();
                    console.warn('è¾¾åˆ°æœ€å¤§å°è¯•æ¬¡æ•°ï¼Œä½¿ç”¨éšæœºæ£‹ç›˜');
                }
                
                this.renderBoard();
                this.gameStarted = true;
                this.score = 0;
                this.moves = 0;
                this.hints = 3;
                this.timeElapsed = 0;

                this.updateDisplay();
                this.startTimer();

                document.getElementById('hintBtn').textContent = `æç¤º (${this.hints})`;
            }

            createBoard() {
                const totalTiles = this.rows * this.cols;
                const pairsNeeded = Math.min(this.pairs, Math.floor(totalTiles / 2));

                // åˆ›å»ºæˆå¯¹çš„å›¾ç‰‡
                const images = [];
                const selectedImages = this.getRandomImages(pairsNeeded);

                for (let i = 0; i < pairsNeeded; i++) {
                    images.push(selectedImages[i], selectedImages[i]); // æ¯å¼ å›¾ç‰‡æ·»åŠ ä¸¤æ¬¡ï¼Œå½¢æˆä¸€å¯¹
                }

                // å¦‚æœè¿˜æœ‰ç©ºä½™ä½ç½®ï¼Œæ·»åŠ æ›´å¤šçš„å¯¹
                while (images.length < totalTiles && images.length < this.imagePaths.length * 2) {
                    const randomImage = this.imagePaths[Math.floor(Math.random() * this.imagePaths.length)];
                    images.push(randomImage, randomImage);
                }

                // ç¡®ä¿æ•°ç»„é•¿åº¦æ­£å¥½ç­‰äºtotalTiles
                while (images.length > totalTiles) {
                    images.pop();
                }

                // æ‰“ä¹±æ•°ç»„
                for (let i = images.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [images[i], images[j]] = [images[j], images[i]];
                }

                // åˆ›å»ºäºŒç»´æ•°ç»„
                const board = [];
                let imageIndex = 0;

                for (let i = 0; i < this.rows; i++) {
                    board[i] = [];
                    for (let j = 0; j < this.cols; j++) {
                        board[i][j] = imageIndex < images.length ? images[imageIndex++] : null;
                    }
                }

                return board;
            }

            renderBoard() {
                const boardElement = document.getElementById('gameBoard');
                boardElement.innerHTML = '';
                boardElement.style.gridTemplateColumns = `repeat(${this.cols}, 1fr)`;

                for (let i = 0; i < this.rows; i++) {
                    for (let j = 0; j < this.cols; j++) {
                        const tile = document.createElement('div');
                        tile.className = 'tile';
                        tile.dataset.row = i;
                        tile.dataset.col = j;

                        if (this.board[i][j]) {
                            const img = document.createElement('img');
                            img.src = this.board[i][j];
                            img.alt = 'Game Tile';

                            // å¦‚æœå›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨emojiä½œä¸ºæ›¿ä»£
                            // ç¡®ä¿ç›¸åŒè·¯å¾„çš„å›¾ç‰‡æ˜¾ç¤ºç›¸åŒçš„emojiï¼Œä»¥ä¿æŒæ¸¸æˆé€»è¾‘æ­£ç¡®
                            img.onerror = () => {
                                img.style.display = 'none';
                                const emoji = document.createElement('div');
                                emoji.style.fontSize = '30px';
                                emoji.style.display = 'flex';
                                emoji.style.alignItems = 'center';
                                emoji.style.justifyContent = 'center';
                                emoji.style.width = '100%';
                                emoji.style.height = '100%';
                                
                                // æ ¹æ®å›¾ç‰‡è·¯å¾„ç”Ÿæˆå›ºå®šçš„emojiï¼Œç¡®ä¿ç›¸åŒè·¯å¾„æ˜¾ç¤ºç›¸åŒemoji
                                const emojis = ['ğŸ', 'ğŸŠ', 'ğŸ‹', 'ğŸŒ', 'ğŸ‰', 'ğŸ‡', 'ğŸ“', 'ğŸ’', 'ğŸŒŸ', 'ğŸˆ', 'ğŸ¨', 'ğŸ¯', 'ğŸª', 'ğŸ­', 'ğŸ¬', 'ğŸ®', 'ğŸ¯', 'ğŸ²', 'ğŸ¸', 'ğŸº', 'ğŸ»', 'ğŸ¤', 'ğŸ§', 'ğŸµ', 'ğŸ¶', 'ğŸ¼', 'ğŸ¹', 'ğŸ·', 'ğŸ¸', 'ğŸº'];
                                // ä½¿ç”¨å›¾ç‰‡è·¯å¾„çš„å“ˆå¸Œå€¼æ¥é€‰æ‹©emojiï¼Œç¡®ä¿ç›¸åŒè·¯å¾„æ€»æ˜¯æ˜¾ç¤ºç›¸åŒemoji
                                let hash = 0;
                                const imagePath = this.board[i][j];
                                for (let k = 0; k < imagePath.length; k++) {
                                    hash = ((hash << 5) - hash) + imagePath.charCodeAt(k);
                                    hash = hash & hash; // è½¬æ¢ä¸º32ä½æ•´æ•°
                                }
                                const emojiIndex = Math.abs(hash) % emojis.length;
                                emoji.textContent = emojis[emojiIndex];
                                tile.appendChild(emoji);
                            };

                            img.onload = () => {
                                // å›¾ç‰‡åŠ è½½æˆåŠŸï¼Œç¡®ä¿æ ·å¼æ­£ç¡®
                                img.style.width = '100%';
                                img.style.height = '100%';
                                img.style.objectFit = 'cover';
                                img.style.borderRadius = '6px';
                            };

                            tile.appendChild(img);
                        } else {
                            tile.classList.add('empty');
                        }

                        tile.addEventListener('click', () => this.handleTileClick(i, j));
                        boardElement.appendChild(tile);
                    }
                }
            }

            handleTileClick(row, col) {
                if (!this.gameStarted || !this.board[row][col]) return;

                const tile = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);

                if (this.selectedTiles.length === 0) {
                    this.selectedTiles.push({ row, col, element: tile });
                    tile.classList.add('selected');
                } else if (this.selectedTiles.length === 1) {
                    const first = this.selectedTiles[0];

                    if (first.row === row && first.col === col) {
                        tile.classList.remove('selected');
                        this.selectedTiles = [];
                        return;
                    }

                    this.selectedTiles.push({ row, col, element: tile });
                    tile.classList.add('selected');

                    this.moves++;
                    this.updateDisplay();

                    if (this.canConnect(first.row, first.col, row, col)) {
                        this.handleMatch();
                    } else {
                        setTimeout(() => {
                            this.clearSelection();
                        }, 500);
                    }
                }
            }

            canConnect(row1, col1, row2, col2) {
                // æ£€æŸ¥æ˜¯å¦æ˜¯ç›¸åŒçš„å›¾ç‰‡
                if (this.board[row1][col1] !== this.board[row2][col2]) {
                    return false;
                }

                // å®ç°çœŸæ­£çš„è¿è¿çœ‹è§„åˆ™ï¼šæœ€å¤šç”¨3æ¡ç›´çº¿ï¼ˆ2ä¸ªè½¬æŠ˜ç‚¹ï¼‰è¿æ¥
                const result = this.findPath(row1, col1, row2, col2);

                // å¦‚æœæ˜¯è¾¹ç•Œä½ç½®çš„å›¾ç‰‡ï¼Œè®°å½•è¿æ¥ç»“æœç”¨äºè°ƒè¯•
                const isEdge1 = row1 === 0 || row1 === this.rows-1 || col1 === 0 || col1 === this.cols-1;
                const isEdge2 = row2 === 0 || row2 === this.rows-1 || col2 === 0 || col2 === this.cols-1;
                if (isEdge1 || isEdge2) {
                    console.log(`è¾¹ç•Œè¿æ¥æµ‹è¯•: (${row1},${col1}) -> (${row2},${col2}) = ${result}`);
                }

                return result;
            }

            findPath(row1, col1, row2, col2) {
                // 0ä¸ªè½¬æŠ˜ç‚¹ï¼šç›´æ¥è¿æ¥
                if (this.canDirectConnect(row1, col1, row2, col2)) {
                    return true;
                }

                // 1ä¸ªè½¬æŠ˜ç‚¹ï¼šä¸€ä¸ªè½¬å¼¯
                if (this.canConnectWithOneCorner(row1, col1, row2, col2)) {
                    return true;
                }

                // 2ä¸ªè½¬æŠ˜ç‚¹ï¼šä¸¤ä¸ªè½¬å¼¯
                if (this.canConnectWithTwoCorners(row1, col1, row2, col2)) {
                    return true;
                }

                return false;
            }

            // æ£€æŸ¥æ˜¯å¦å¯ä»¥ç›´æ¥è¿æ¥ï¼ˆ0ä¸ªè½¬æŠ˜ç‚¹ï¼‰
            canDirectConnect(row1, col1, row2, col2) {
                // åŒä¸€è¡Œï¼šæ°´å¹³è¿æ¥
                if (row1 === row2) {
                    const start = Math.min(col1, col2);
                    const end = Math.max(col1, col2);

                    // æ£€æŸ¥è·¯å¾„ä¸Šçš„æ¯ä¸ªç‚¹ï¼ˆä¸åŒ…æ‹¬èµ·ç‚¹å’Œç»ˆç‚¹ï¼‰
                    for (let col = start + 1; col < end; col++) {
                        // å¦‚æœç‚¹åœ¨è¾¹ç•Œå†…ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰é˜»æŒ¡
                        if (row1 >= 0 && row1 < this.rows && col >= 0 && col < this.cols) {
                            if (this.board[row1][col] !== null) {
                                return false; // è·¯å¾„ä¸Šæœ‰é˜»æŒ¡
                            }
                        }
                        // å¦‚æœç‚¹åœ¨è¾¹ç•Œå¤–ï¼Œå…è®¸é€šè¿‡ï¼ˆè¾¹ç•Œå¤–çš„ç‚¹å¯ä»¥ä½œä¸ºè·¯å¾„çš„ä¸€éƒ¨åˆ†ï¼‰
                    }
                    return true;
                }

                // åŒä¸€åˆ—ï¼šå‚ç›´è¿æ¥
                if (col1 === col2) {
                    const start = Math.min(row1, row2);
                    const end = Math.max(row1, row2);

                    // æ£€æŸ¥è·¯å¾„ä¸Šçš„æ¯ä¸ªç‚¹ï¼ˆä¸åŒ…æ‹¬èµ·ç‚¹å’Œç»ˆç‚¹ï¼‰
                    for (let row = start + 1; row < end; row++) {
                        // å¦‚æœç‚¹åœ¨è¾¹ç•Œå†…ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰é˜»æŒ¡
                        if (row >= 0 && row < this.rows && col1 >= 0 && col1 < this.cols) {
                            if (this.board[row][col1] !== null) {
                                return false; // è·¯å¾„ä¸Šæœ‰é˜»æŒ¡
                            }
                        }
                        // å¦‚æœç‚¹åœ¨è¾¹ç•Œå¤–ï¼Œå…è®¸é€šè¿‡ï¼ˆè¾¹ç•Œå¤–çš„ç‚¹å¯ä»¥ä½œä¸ºè·¯å¾„çš„ä¸€éƒ¨åˆ†ï¼‰
                    }
                    return true;
                }

                return false;
            }

            // æ£€æŸ¥æ˜¯å¦å¯ä»¥ç”¨ä¸€ä¸ªè½¬æŠ˜ç‚¹è¿æ¥
            canConnectWithOneCorner(row1, col1, row2, col2) {
                // å°è¯•ä¸¤ä¸ªè½¬æŠ˜ç‚¹ä½ç½®
                // è½¬æŠ˜ç‚¹1: (row1, col2)
                if (this.isValidCorner(row1, col2) &&
                    this.canDirectConnect(row1, col1, row1, col2) &&
                    this.canDirectConnect(row1, col2, row2, col2)) {
                    return true;
                }

                // è½¬æŠ˜ç‚¹2: (row2, col1)
                if (this.isValidCorner(row2, col1) &&
                    this.canDirectConnect(row1, col1, row2, col1) &&
                    this.canDirectConnect(row2, col1, row2, col2)) {
                    return true;
                }

                return false;
            }

            // æ£€æŸ¥æ˜¯å¦å¯ä»¥ç”¨ä¸¤ä¸ªè½¬æŠ˜ç‚¹è¿æ¥
            canConnectWithTwoCorners(row1, col1, row2, col2) {
                // æ–¹æ³•1ï¼šç®€åŒ–çš„è¾¹ç•ŒUå½¢æ£€æµ‹ - ç›´æ¥æ£€æŸ¥å››ä¸ªæ–¹å‘

                // Uå½¢1: ä¸¤ä¸ªç‚¹éƒ½å¯ä»¥å‘ä¸Šåˆ°è¾¾è¾¹ç•Œ (-1è¡Œ)
                if (this.canReachRowBoundary(row1, col1, -1) && this.canReachRowBoundary(row2, col2, -1)) {
                    return true; // åœ¨ä¸Šè¾¹ç•Œå¤–å¯ä»¥è¿æ¥
                }

                // Uå½¢2: ä¸¤ä¸ªç‚¹éƒ½å¯ä»¥å‘ä¸‹åˆ°è¾¾è¾¹ç•Œ (rowsè¡Œ)
                if (this.canReachRowBoundary(row1, col1, this.rows) && this.canReachRowBoundary(row2, col2, this.rows)) {
                    return true; // åœ¨ä¸‹è¾¹ç•Œå¤–å¯ä»¥è¿æ¥
                }

                // Uå½¢3: ä¸¤ä¸ªç‚¹éƒ½å¯ä»¥å‘å·¦åˆ°è¾¾è¾¹ç•Œ (-1åˆ—)
                if (this.canReachColBoundary(row1, col1, -1) && this.canReachColBoundary(row2, col2, -1)) {
                    return true; // åœ¨å·¦è¾¹ç•Œå¤–å¯ä»¥è¿æ¥
                }

                // Uå½¢4: ä¸¤ä¸ªç‚¹éƒ½å¯ä»¥å‘å³åˆ°è¾¾è¾¹ç•Œ (colsåˆ—)
                if (this.canReachColBoundary(row1, col1, this.cols) && this.canReachColBoundary(row2, col2, this.cols)) {
                    return true; // åœ¨å³è¾¹ç•Œå¤–å¯ä»¥è¿æ¥
                }

                // æ–¹æ³•2ï¼šæ ‡å‡†çš„ä¸¤è½¬æŠ˜ç‚¹æœç´¢ç®—æ³•
                // å…ˆæ‰¾æ‰€æœ‰å¯èƒ½çš„ç¬¬ä¸€ä¸ªè½¬æŠ˜ç‚¹ï¼ˆä»èµ·ç‚¹å¯è¾¾çš„ç‚¹ï¼‰
                const firstCorners = [];
                for (let row = -1; row <= this.rows; row++) {
                    for (let col = -1; col <= this.cols; col++) {
                        // è·³è¿‡èµ·ç‚¹å’Œç»ˆç‚¹
                        if ((row === row1 && col === col1) || (row === row2 && col === col2)) continue;
                        // æ£€æŸ¥èµ·ç‚¹åˆ°è¯¥ç‚¹æ˜¯å¦å¯ä»¥ç›´æ¥è¿æ¥ï¼Œä¸”è¯¥ç‚¹å¯ä»¥ä½œä¸ºè½¬æŠ˜ç‚¹
                        if (this.canDirectConnect(row1, col1, row, col) && this.isValidCorner(row, col)) {
                            firstCorners.push({row, col});
                        }
                    }
                }

                // ä»æ¯ä¸ªç¬¬ä¸€ä¸ªè½¬æŠ˜ç‚¹æ‰¾ç¬¬äºŒä¸ªè½¬æŠ˜ç‚¹
                for (let corner1 of firstCorners) {
                    for (let row = -1; row <= this.rows; row++) {
                        for (let col = -1; col <= this.cols; col++) {
                            // è·³è¿‡ç¬¬ä¸€ä¸ªè½¬æŠ˜ç‚¹ã€èµ·ç‚¹å’Œç»ˆç‚¹
                            if ((row === corner1.row && col === corner1.col) ||
                                (row === row1 && col === col1) ||
                                (row === row2 && col === col2)) continue;
                            
                            // æ£€æŸ¥ä¸‰ä¸ªæ¡ä»¶ï¼š
                            // 1. ç¬¬ä¸€ä¸ªè½¬æŠ˜ç‚¹åˆ°ç¬¬äºŒä¸ªè½¬æŠ˜ç‚¹å¯è¾¾
                            // 2. ç¬¬äºŒä¸ªè½¬æŠ˜ç‚¹åˆ°ç»ˆç‚¹å¯è¾¾
                            // 3. ç¬¬äºŒä¸ªè½¬æŠ˜ç‚¹æ˜¯æœ‰æ•ˆçš„ï¼ˆè¾¹ç•Œå¤–æˆ–ç©ºä½ï¼‰
                            if (this.canDirectConnect(corner1.row, corner1.col, row, col) &&
                                this.canDirectConnect(row, col, row2, col2) &&
                                this.isValidCorner(row, col)) {
                                return true;
                            }
                        }
                    }
                }

                return false;
            }

            // æ£€æŸ¥æŸä¸ªç‚¹æ˜¯å¦å¯ä»¥ä½œä¸ºè½¬æŠ˜ç‚¹
            isValidCorner(row, col) {
                // åœ¨è¾¹ç•Œå¤–çš„ç‚¹ä¹Ÿå¯ä»¥ä½œä¸ºè½¬æŠ˜ç‚¹
                if (row < 0 || row >= this.rows || col < 0 || col >= this.cols) {
                    return true;
                }
                // åœ¨è¾¹ç•Œå†…çš„ç‚¹å¿…é¡»æ˜¯ç©ºçš„
                return this.board[row][col] === null;
            }

            // æ£€æŸ¥æ˜¯å¦å¯ä»¥é€šè¿‡æŸä¸ªç‚¹è¿æ¥
            canConnectViaPoint(row, col, row1, col1, row2, col2) {
                // æ£€æŸ¥ä»è¿™ä¸ªç‚¹åˆ°ç›®æ ‡ç‚¹çš„è¿æ¥
                return this.isValidCorner(row, col) &&
                       this.canDirectConnect(row1, col1, row, col) &&
                       this.canDirectConnect(row, col, row2, col2);
            }

            // æ£€æŸ¥æ˜¯å¦å¯ä»¥åˆ°è¾¾æŒ‡å®šçš„è¡Œè¾¹ç•Œ
            canReachRowBoundary(row, col, targetRow) {
                if (targetRow === -1) {
                    // å‘ä¸Šåˆ°è¾¾-1è¡Œï¼ˆä¸Šè¾¹ç•Œå¤–ï¼‰
                    for (let r = row - 1; r >= 0; r--) {
                        if (r >= 0 && r < this.rows && this.board[r] && this.board[r][col] !== null) {
                            return false; // è·¯å¾„è¢«é˜»æŒ¡
                        }
                    }
                    return true;
                } else if (targetRow === this.rows) {
                    // å‘ä¸‹åˆ°è¾¾rowsè¡Œï¼ˆä¸‹è¾¹ç•Œå¤–ï¼‰
                    for (let r = row + 1; r < this.rows; r++) {
                        if (r >= 0 && r < this.rows && this.board[r] && this.board[r][col] !== null) {
                            return false; // è·¯å¾„è¢«é˜»æŒ¡
                        }
                    }
                    return true;
                }
                return false;
            }

            // æ£€æŸ¥æ˜¯å¦å¯ä»¥åˆ°è¾¾æŒ‡å®šçš„åˆ—è¾¹ç•Œ
            canReachColBoundary(row, col, targetCol) {
                if (targetCol === -1) {
                    // å‘å·¦åˆ°è¾¾-1åˆ—ï¼ˆå·¦è¾¹ç•Œå¤–ï¼‰
                    for (let c = col - 1; c >= 0; c--) {
                        if (c >= 0 && c < this.cols && this.board[row] && this.board[row][c] !== null) {
                            return false; // è·¯å¾„è¢«é˜»æŒ¡
                        }
                    }
                    return true;
                } else if (targetCol === this.cols) {
                    // å‘å³åˆ°è¾¾colsåˆ—ï¼ˆå³è¾¹ç•Œå¤–ï¼‰
                    for (let c = col + 1; c < this.cols; c++) {
                        if (c >= 0 && c < this.cols && this.board[row] && this.board[row][c] !== null) {
                            return false; // è·¯å¾„è¢«é˜»æŒ¡
                        }
                    }
                    return true;
                }
                return false;
            }

    
            handleMatch() {
                const [first, second] = this.selectedTiles;

                // æ·»åŠ åŒ¹é…åŠ¨ç”»
                first.element.classList.add('matched');
                second.element.classList.add('matched');

                // æ¸…é™¤æ£‹ç›˜ä¸Šçš„å›¾ç‰‡
                setTimeout(() => {
                    this.board[first.row][first.col] = null;
                    this.board[second.row][second.col] = null;
                    first.element.classList.add('empty');
                    second.element.classList.add('empty');
                    first.element.classList.remove('selected', 'matched');
                    second.element.classList.remove('selected', 'matched');
                }, 500);

                // å¢åŠ åˆ†æ•°
                this.score += 100;
                this.updateDisplay();

                // æ¸…é™¤é€‰æ‹©
                this.selectedTiles = [];

                // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
                setTimeout(() => {
                    if (this.checkGameEnd()) {
                        this.endGame(true);
                    }
                }, 600);
            }

            clearSelection() {
                this.selectedTiles.forEach(tile => {
                    tile.element.classList.remove('selected');
                });
                this.selectedTiles = [];
            }

            showHint() {
                if (!this.gameStarted) {
                    alert('è¯·å…ˆå¼€å§‹æ¸¸æˆï¼');
                    return;
                }

                if (this.hints <= 0) {
                    alert('æç¤ºæ¬¡æ•°å·²ç”¨å®Œï¼');
                    return;
                }

                // æ¸…é™¤ä¹‹å‰çš„é€‰æ‹©
                this.clearSelection();

                // å¯»æ‰¾å¯ä»¥åŒ¹é…çš„ä¸€å¯¹
                let found = false;
                for (let r1 = 0; r1 < this.rows; r1++) {
                    for (let c1 = 0; c1 < this.cols; c1++) {
                        if (!this.board[r1][c1]) continue;

                        for (let r2 = 0; r2 < this.rows; r2++) {
                            for (let c2 = 0; c2 < this.cols; c2++) {
                                if (r1 === r2 && c1 === c2) continue;
                                if (!this.board[r2][c2]) continue;

                                if (this.canConnect(r1, c1, r2, c2)) {
                                    // é«˜äº®æç¤º
                                    const tile1 = document.querySelector(`[data-row="${r1}"][data-col="${c1}"]`);
                                    const tile2 = document.querySelector(`[data-row="${r2}"][data-col="${c2}"]`);

                                    if (tile1 && tile2) {
                                        // ä½¿ç”¨æ›´æ˜æ˜¾çš„æç¤ºæ•ˆæœ
                                        tile1.style.background = '#f39c12';
                                        tile1.style.border = '3px solid #e67e22';
                                        tile1.style.transform = 'scale(1.1)';
                                        tile1.style.zIndex = '10';
                                        
                                        tile2.style.background = '#f39c12';
                                        tile2.style.border = '3px solid #e67e22';
                                        tile2.style.transform = 'scale(1.1)';
                                        tile2.style.zIndex = '10';

                                        // æ·»åŠ é—ªçƒåŠ¨ç”»
                                        let blinkCount = 0;
                                        const blinkInterval = setInterval(() => {
                                            const opacity = blinkCount % 2 === 0 ? '0.7' : '1';
                                            tile1.style.opacity = opacity;
                                            tile2.style.opacity = opacity;
                                            blinkCount++;
                                            if (blinkCount >= 6) {
                                                clearInterval(blinkInterval);
                                            }
                                        }, 200);

                                        setTimeout(() => {
                                            tile1.style.background = '';
                                            tile1.style.border = '';
                                            tile1.style.transform = '';
                                            tile1.style.zIndex = '';
                                            tile1.style.opacity = '';
                                            
                                            tile2.style.background = '';
                                            tile2.style.border = '';
                                            tile2.style.transform = '';
                                            tile2.style.zIndex = '';
                                            tile2.style.opacity = '';
                                        }, 2000);

                                        this.hints--;
                                        this.score = Math.max(0, this.score - 50);
                                        this.updateDisplay();
                                        document.getElementById('hintBtn').textContent = `æç¤º (${this.hints})`;
                                        found = true;
                                        return;
                                    }
                                }
                            }
                        }
                    }
                }

                // å¦‚æœæ²¡æœ‰æ‰¾åˆ°å¯è¿æ¥çš„é…å¯¹
                if (!found) {
                    alert('å½“å‰æ²¡æœ‰å¯è¿æ¥çš„é…å¯¹ï¼');
                }
            }

            checkGameEnd() {
                for (let i = 0; i < this.rows; i++) {
                    for (let j = 0; j < this.cols; j++) {
                        if (this.board[i][j]) return false;
                    }
                }
                return true;
            }

            // æ£€æŸ¥æ£‹ç›˜æ˜¯å¦æœ‰è¶³å¤Ÿçš„å¯è¿æ¥é…å¯¹
            hasEnoughConnectablePairs() {
                const pairs = new Map(); // å­˜å‚¨æ¯ç§å›¾ç‰‡çš„æ‰€æœ‰ä½ç½®
                
                // æ”¶é›†æ‰€æœ‰å›¾ç‰‡çš„ä½ç½®
                for (let i = 0; i < this.rows; i++) {
                    for (let j = 0; j < this.cols; j++) {
                        if (this.board[i][j]) {
                            const image = this.board[i][j];
                            if (!pairs.has(image)) {
                                pairs.set(image, []);
                            }
                            pairs.get(image).push({row: i, col: j});
                        }
                    }
                }

                // ç»Ÿè®¡å¯è¿æ¥çš„é…å¯¹æ•°é‡
                let connectableCount = 0;
                let totalPairs = 0;
                
                for (const [image, positions] of pairs.entries()) {
                    // å¯¹äºæ¯ç§å›¾ç‰‡ï¼Œæ£€æŸ¥æ‰€æœ‰å¯èƒ½çš„é…å¯¹
                    for (let i = 0; i < positions.length; i++) {
                        for (let j = i + 1; j < positions.length; j++) {
                            totalPairs++;
                            const pos1 = positions[i];
                            const pos2 = positions[j];
                            if (this.canConnect(pos1.row, pos1.col, pos2.row, pos2.col)) {
                                connectableCount++;
                            }
                        }
                    }
                }

                // æ ¹æ®éš¾åº¦è®¾ç½®æœ€å°å¯è¿æ¥é…å¯¹æ¯”ä¾‹
                // ç®€å•éš¾åº¦è‡³å°‘éœ€è¦60%çš„é…å¯¹å¯è¿æ¥ï¼Œä¸­ç­‰40%ï¼Œå›°éš¾30%
                const minRatio = {
                    easy: 0.6,
                    medium: 0.4,
                    hard: 0.3
                }[this.difficulty] || 0.4;

                // è‡³å°‘è¦æœ‰ä¸€å®šæ•°é‡çš„å¯è¿æ¥é…å¯¹
                // ç®€å•éš¾åº¦è‡³å°‘éœ€è¦æ€»é…å¯¹æ•°çš„60%ï¼Œä½†è‡³å°‘è¦æœ‰4å¯¹å¯è¿æ¥
                const minConnectable = this.difficulty === 'easy' 
                    ? Math.max(4, Math.floor(totalPairs * minRatio))
                    : Math.max(3, Math.floor(totalPairs * minRatio));
                
                return connectableCount >= minConnectable;
            }

            // æ£€æŸ¥æ£‹ç›˜æ˜¯å¦å¯è§£ï¼ˆæ‰€æœ‰å›¾ç‰‡éƒ½èƒ½è¢«æ¶ˆé™¤ï¼‰
            isSolvable() {
                // åˆ›å»ºæ£‹ç›˜å‰¯æœ¬ç”¨äºæ¨¡æ‹Ÿ
                const boardCopy = this.board.map(row => row.map(cell => cell));
                
                // ä½¿ç”¨é€’å½’å›æº¯ç®—æ³•å°è¯•æ¶ˆé™¤æ‰€æœ‰é…å¯¹
                return this.solveBoard(boardCopy);
            }

            // é€’å½’å›æº¯ç®—æ³•è§£å†³æ£‹ç›˜ï¼ˆå¸¦æ·±åº¦é™åˆ¶å’Œä¼˜åŒ–ï¼‰
            solveBoard(board, depth = 0, maxDepth = 50) {
                // é˜²æ­¢é€’å½’è¿‡æ·±
                if (depth > maxDepth) {
                    return false;
                }

                // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰å›¾ç‰‡éƒ½å·²æ¶ˆé™¤
                let hasTiles = false;
                for (let i = 0; i < board.length; i++) {
                    for (let j = 0; j < board[i].length; j++) {
                        if (board[i][j] !== null) {
                            hasTiles = true;
                            break;
                        }
                    }
                    if (hasTiles) break;
                }
                
                if (!hasTiles) {
                    return true; // æ‰€æœ‰å›¾ç‰‡éƒ½å·²æ¶ˆé™¤ï¼Œæ£‹ç›˜å¯è§£
                }

                // æ‰¾åˆ°æ‰€æœ‰å¯è¿æ¥çš„é…å¯¹
                const connectablePairs = [];
                
                for (let r1 = 0; r1 < board.length; r1++) {
                    for (let c1 = 0; c1 < board[r1].length; c1++) {
                        if (board[r1][c1] === null) continue;
                        
                        for (let r2 = 0; r2 < board.length; r2++) {
                            for (let c2 = 0; c2 < board[r2].length; c2++) {
                                if (r1 === r2 && c1 === c2) continue;
                                if (board[r2][c2] === null) continue;
                                if (board[r1][c1] !== board[r2][c2]) continue;
                                
                                // æ£€æŸ¥æ˜¯å¦å¯ä»¥è¿æ¥ï¼ˆä½¿ç”¨ä¼ å…¥çš„æ£‹ç›˜çŠ¶æ€ï¼‰
                                if (this.canConnectWithBoard(board, r1, c1, r2, c2)) {
                                    connectablePairs.push({r1, c1, r2, c2});
                                }
                            }
                        }
                    }
                }

                // å¦‚æœæ²¡æœ‰å¯è¿æ¥çš„é…å¯¹ï¼Œæ£‹ç›˜ä¸å¯è§£
                if (connectablePairs.length === 0) {
                    return false;
                }

                // å°è¯•æ¶ˆé™¤æ¯ä¸ªå¯è¿æ¥çš„é…å¯¹ï¼ˆä¼˜å…ˆå°è¯•ç›´æ¥è¿æ¥çš„é…å¯¹ï¼‰
                // å…ˆå°è¯•ç›´æ¥è¿æ¥çš„é…å¯¹ï¼ˆ0ä¸ªè½¬æŠ˜ç‚¹ï¼‰
                const directPairs = [];
                const otherPairs = [];
                
                for (const pair of connectablePairs) {
                    if (this.canDirectConnectWithBoard(board, pair.r1, pair.c1, pair.r2, pair.c2)) {
                        directPairs.push(pair);
                    } else {
                        otherPairs.push(pair);
                    }
                }
                
                // å…ˆå°è¯•ç›´æ¥è¿æ¥çš„é…å¯¹
                const sortedPairs = [...directPairs, ...otherPairs];
                
                for (const pair of sortedPairs) {
                    // åˆ›å»ºæ–°çš„æ£‹ç›˜çŠ¶æ€
                    const newBoard = board.map(row => row.map(cell => cell));
                    
                    // æ¶ˆé™¤è¿™å¯¹å›¾ç‰‡
                    newBoard[pair.r1][pair.c1] = null;
                    newBoard[pair.r2][pair.c2] = null;
                    
                    // é€’å½’æ£€æŸ¥å‰©ä½™æ£‹ç›˜æ˜¯å¦å¯è§£
                    if (this.solveBoard(newBoard, depth + 1, maxDepth)) {
                        return true;
                    }
                }

                return false; // æ‰€æœ‰å°è¯•éƒ½å¤±è´¥ï¼Œæ£‹ç›˜ä¸å¯è§£
            }

            // ä½¿ç”¨æŒ‡å®šæ£‹ç›˜çŠ¶æ€æ£€æŸ¥æ˜¯å¦å¯ä»¥ç›´æ¥è¿æ¥
            canDirectConnectWithBoard(board, row1, col1, row2, col2) {
                // åŒä¸€è¡Œï¼šæ°´å¹³è¿æ¥
                if (row1 === row2) {
                    const start = Math.min(col1, col2);
                    const end = Math.max(col1, col2);

                    for (let col = start + 1; col < end; col++) {
                        if (row1 >= 0 && row1 < board.length && col >= 0 && col < board[row1].length) {
                            if (board[row1][col] !== null) {
                                return false;
                            }
                        }
                    }
                    return true;
                }

                // åŒä¸€åˆ—ï¼šå‚ç›´è¿æ¥
                if (col1 === col2) {
                    const start = Math.min(row1, row2);
                    const end = Math.max(row1, row2);

                    for (let row = start + 1; row < end; row++) {
                        if (row >= 0 && row < board.length && col1 >= 0 && col1 < board[row].length) {
                            if (board[row][col1] !== null) {
                                return false;
                            }
                        }
                    }
                    return true;
                }

                return false;
            }

            // ä½¿ç”¨æŒ‡å®šæ£‹ç›˜çŠ¶æ€æ£€æŸ¥æ˜¯å¦å¯ä»¥è¿æ¥
            canConnectWithBoard(board, row1, col1, row2, col2) {
                // æ£€æŸ¥æ˜¯å¦æ˜¯ç›¸åŒçš„å›¾ç‰‡
                if (board[row1][col1] !== board[row2][col2]) {
                    return false;
                }

                // ä½¿ç”¨ä¸´æ—¶æ£‹ç›˜çŠ¶æ€æ£€æŸ¥è·¯å¾„
                const tempBoard = this.board;
                this.board = board;
                const result = this.findPath(row1, col1, row2, col2);
                this.board = tempBoard;
                
                return result;
            }

            startTimer() {
                this.timer = setInterval(() => {
                    this.timeElapsed++;
                    this.updateTimer();
                }, 1000);
            }

            stopTimer() {
                if (this.timer) {
                    clearInterval(this.timer);
                    this.timer = null;
                }
            }

            updateTimer() {
                const minutes = Math.floor(this.timeElapsed / 60);
                const seconds = this.timeElapsed % 60;
                document.getElementById('time').textContent =
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }

            updateDisplay() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('moves').textContent = this.moves;
                this.updateTimer();
            }

            restartGame() {
                this.stopTimer();
                this.gameStarted = false;
                this.selectedTiles = [];
                document.getElementById('gameBoard').innerHTML = '';
                this.startGame();
            }

            endGame(won) {
                this.stopTimer();
                this.gameStarted = false;

                const overlay = document.getElementById('overlay');
                const gameOver = document.getElementById('gameOver');
                const title = document.getElementById('gameOverTitle');
                const message = document.getElementById('gameOverMessage');

                if (won) {
                    title.textContent = 'ğŸ‰ æ­å–œé€šå…³ï¼';
                    message.innerHTML = `
                        å®Œæˆæ—¶é—´ï¼š${document.getElementById('time').textContent}<br>
                        æœ€ç»ˆå¾—åˆ†ï¼š${this.score}<br>
                        ä½¿ç”¨æ­¥æ•°ï¼š${this.moves}<br>
                        éš¾åº¦çº§åˆ«ï¼š${this.getDifficultyText()}
                    `;
                } else {
                    title.textContent = 'æ¸¸æˆç»“æŸ';
                    message.textContent = `æœ€ç»ˆå¾—åˆ†ï¼š${this.score}`;
                }

                overlay.style.display = 'block';
                gameOver.style.display = 'block';
            }

            getDifficultyText() {
                const texts = {
                    easy: 'ç®€å•',
                    medium: 'ä¸­ç­‰',
                    hard: 'å›°éš¾'
                };
                return texts[this.difficulty];
            }
        }

        // åˆå§‹åŒ–æ¸¸æˆ
        const game = new LianLianKan();

        // å…¨å±€å‡½æ•°
        function restartGame() {
            document.getElementById('overlay').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            game.restartGame();
        }
    </script>
</body>
</html>